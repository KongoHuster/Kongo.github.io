<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>三、Hexo 搭建个人博客系列：主题美化篇</title>
    <url>/2020/06/20/Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E7%AF%87/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/20/Nl8KL8.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">幻彩魔方</div>
</center>

<blockquote>
<p>本文搭建Hexo主要参考<a href="http://yearito.cn/tags/Hexo/" target="_blank" rel="noopener">Yearito’s Blog</a></p>
</blockquote>
<h4 id="一、修改博客字体"><a href="#一、修改博客字体" class="headerlink" title="一、修改博客字体"></a>一、修改博客字体</h4><p>在 Google Fonts 上找到心仪的字体，然后在主题配置文件中为不同的应用场景配置字体：</p>
<a id="more"></a>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # 外链字体库地址，例如 &#x2F;&#x2F;fonts.googleapis.com (默认值)</span><br><span class="line">  host:</span><br><span class="line"></span><br><span class="line">  # 全局字体，应用在 body 元素上</span><br><span class="line">  global:</span><br><span class="line">    external: true</span><br><span class="line">    family: Monda</span><br><span class="line"></span><br><span class="line">  # 标题字体 (h1, h2, h3, h4, h5, h6)</span><br><span class="line">  headings:</span><br><span class="line">    external: true</span><br><span class="line">    family: Roboto Slab</span><br><span class="line"></span><br><span class="line">  # 文章字体</span><br><span class="line">  posts:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line"></span><br><span class="line">  # Logo 字体</span><br><span class="line">  logo:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line"></span><br><span class="line">  # 代码字体，应用于 code 以及代码块</span><br><span class="line">  codes:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br></pre></td></tr></table></figure>

<h4 id="二、文章页末美化"><a href="#二、文章页末美化" class="headerlink" title="二、文章页末美化"></a>二、文章页末美化</h4><h5 id="为标签添加图标"><a href="#为标签添加图标" class="headerlink" title="为标签添加图标"></a>为标签添加图标</h5><p>默认情况下标签前缀是 # 字符，用户可以通过修改主题源码将标签的字符前缀改为图标前缀</p>
<p>在文章布局模板中找到文末标签相关代码段，将 # 换成 <i class="fa fa-tags"></i> 即可：</p>
<blockquote>
<p>themes\next\layout_macro\post.swig</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &lt;footer class&#x3D;&quot;post-footer&quot;&gt;</span><br><span class="line">    &#123;% if post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">      &lt;div class&#x3D;&quot;post-tags&quot;&gt;</span><br><span class="line">        &#123;% for tag in post.tags %&#125;</span><br><span class="line">-          &lt;a href&#x3D;&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel&#x3D;&quot;tag&quot;&gt;# &#123;&#123; tag.name &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">+          &lt;a href&#x3D;&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel&#x3D;&quot;tag&quot;&gt;&lt;i class&#x3D;&quot;fa fa-tags&quot;&gt;&lt;&#x2F;i&gt; &#123;&#123; tag.name &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    ...</span><br><span class="line">  &lt;&#x2F;footer&gt;</span><br></pre></td></tr></table></figure>

<h5 id="添加结束标记"><a href="#添加结束标记" class="headerlink" title="添加结束标记"></a>添加结束标记</h5><p>新建布局模板文件 post-end-tag.swig，添加如下代码：</p>
<blockquote>
<p>themes\next\layout_macro\post-end-tag.swig</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &lt;div style&#x3D;&quot;text-align:center;color:#bfbfbf;font-size:16px;&quot;&gt;</span><br><span class="line">      &lt;span&gt;-------- 本文结束 &lt;&#x2F;span&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;fa fa-&#123;&#123; config.post_end_tag.icon &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">      &lt;span&gt; 感谢阅读 --------&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>在文章布局模板中添加如下代码：</p>
<blockquote>
<p>themes\next\layout_macro\post</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;#####################&#125;</span><br><span class="line">&#123;### END POST BODY ###&#125;</span><br><span class="line">&#123;#####################&#125;</span><br><span class="line"></span><br><span class="line">+ &#123;% if config.post_end_tag.enabled and not is_index %&#125;</span><br><span class="line">+   &lt;div&gt;</span><br><span class="line">+     &#123;% include &#39;post-end-tag.swig&#39; %&#125;</span><br><span class="line">+   &lt;&#x2F;div&gt;</span><br><span class="line">+ &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include &#39;wechat-subscriber.swig&#39; %&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>在站点配置文件末尾添加如下代码：</p>
<blockquote>
<p>_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_end_tag:</span><br><span class="line">  enabled: true  # 是否开启文末的本文结束标记</span><br><span class="line">  icon: paw # 结束标记之间的图标</span><br></pre></td></tr></table></figure>
<p>重启服务器后即可在文末看到结束标记。</p>
<h4 id="三、页面加载进度条"><a href="#三、页面加载进度条" class="headerlink" title="三、页面加载进度条"></a>三、页面加载进度条</h4><p>当网络不好的时候可能会在打开站点或跳转文章时出现短暂的白屏，此时如果能有加载进度提示将会提高用户操作体验。</p>
<p>在根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-pace themes&#x2F;next&#x2F;source&#x2F;lib&#x2F;pace</span><br></pre></td></tr></table></figure>
<p>在主题配置文件中设置 pace: true。</p>
<p>默认提供了多种主题的进度条加载样式，有顶部提示的，有中间提示的，还有全页面遮挡提示的，个人认为默认的进度条效果就恰如其当，既能够在页面空白的时候起到加载作用，也不会因为太过花里胡哨而喧宾夺主，尤其是当你如果使用了不蒜子的站点访问统计的功能的时候，常常会遇到所有资源都加载完毕而不蒜子还在等待响应，如果这个时候在页面较显眼的位置出现一个停滞不前的进度条，很让人抓狂。</p>
<h4 id="四、添加动态背景"><a href="#四、添加动态背景" class="headerlink" title="四、添加动态背景"></a>四、添加动态背景</h4><p>Next 主题可以通过安装插件快速为站点添加不同效果的动态背景。</p>
<p>粒子漂浮聚合</p>
<p>该功能由 theme-next-canvas-nest 插件提供，在根目录下执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest themes&#x2F;next&#x2F;source&#x2F;lib&#x2F;canvas-nest</span><br></pre></td></tr></table></figure>
<p>然后在主题配置文件中设置 canvas_nest: true 即可。</p>
<p>Next v6.5.0 及以上版本支持更多的自定义选项：</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # 是否在移动端显示</span><br><span class="line">  color: &#39;0,0,255&#39; # 动态背景中线条的 RGB 颜色</span><br><span class="line">  opacity: 0.5 # 动态背景中线条透明度</span><br><span class="line">  zIndex: -1 # 动态背景的 z-index 属性值</span><br><span class="line">  count: 99 # 动态背景中线条数量</span><br></pre></td></tr></table></figure>

<h4 id="五、添加看板娘"><a href="#五、添加看板娘" class="headerlink" title="五、添加看板娘"></a>五、添加看板娘</h4><p>在站点根目录下执行以下命令安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure>
<p>在站点配置文件中添加以下下配置项</p>
<blockquote>
<p>_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Live2D</span><br><span class="line"># https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2d</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  pluginRootPath: live2dw&#x2F;</span><br><span class="line">  pluginJsPath: lib&#x2F;</span><br><span class="line">  pluginModelPath: assets&#x2F; Relative)</span><br><span class="line"></span><br><span class="line">  # 脚本加载源</span><br><span class="line">  scriptFrom: local # 默认从本地加载脚本</span><br><span class="line">  # scriptFrom: jsdelivr # 从 jsdelivr CDN 加载脚本</span><br><span class="line">  # scriptFrom: unpkg # 从 unpkg CDN 加载脚本</span><br><span class="line">  # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 从自定义地址加载脚本</span><br><span class="line">  tagMode: false # 只在有 &#123;&#123; live2d() &#125;&#125; 标签的页面上加载 &#x2F; 在所有页面上加载</span><br><span class="line">  log: false # 是否在控制台打印日志</span><br><span class="line"></span><br><span class="line">  # 选择看板娘模型</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-shizuku  # npm package的名字</span><br><span class="line">    # use: wanko # &#x2F;live2d_models&#x2F; 目录下的模型文件夹名称</span><br><span class="line">    # use: .&#x2F;wives&#x2F;wanko # 站点根目录下的模型文件夹名称</span><br><span class="line">    # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 自定义网络数据源</span><br><span class="line">  display:</span><br><span class="line">    position: left # 显示在左边还是右边</span><br><span class="line">    width: 100 # 宽度</span><br><span class="line">    height: 180 # 高度</span><br><span class="line">  mobile:</span><br><span class="line">    show: false</span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 0.7 # 默认透明度</span><br></pre></td></tr></table></figure>

<p>此时重启服务器暂时还看不到看板娘，需要手动下载或安装模型资源。可以从 <a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">hexo live2d</a> 模型预览 里找到你喜欢的角色，然后根据 live2d-widget-models 中提供的方法来下载模型数据.</p>
<p>例如通过以下命令下载模型 shizuku：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install live2d-widget-model-shizuku</span><br></pre></td></tr></table></figure>
<p>因为修改了站点配置文件，所以需要重启服务器才能预览模型效果。</p>
<p>如果设置了 live2d.tagMode: true，则可以在指定页面中插入以下标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; live2d() &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>只有拥有该标签的页面才会渲染 live2d 模型，这样以来就可以精确控制在哪些页面上显示看板娘了。</p>
<p>如果只想在一级菜单页面上显示看板娘，可以在 Header 模板中添加以下代码：</p>
<blockquote>
<p>themes\next\layout_partials\header\index.swig</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ &#123;% if is_index %&#125;</span><br><span class="line">+   &#123;&#123; live2d() &#125;&#125;</span><br><span class="line">+ &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="六、个性化回到顶部"><a href="#六、个性化回到顶部" class="headerlink" title="六、个性化回到顶部"></a>六、个性化回到顶部</h4><p>原理很简单，将 back-to-top 按钮添加图片背景，并添加 CSS3 动效即可。</p>
<p>首先，找到自己喜欢的图片素材放到 source\images\ 目录下。</p>
<p>你可以点击下方按钮下载本站所使用的小猫上吊素材（ 小猫咪这么可爱，当然要多放点孜然啦…）</p>
<p><a href="http://yearito.cn/images/scroll.png" target="_blank" rel="noopener">下载图片</a></p>
<p>然后在自定义样式文件中添加如下代码：</p>
<blockquote>
<p>themes\next\source\css\ _custom\custom.styl</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;自定义回到顶部样式</span><br><span class="line">.back-to-top &#123;</span><br><span class="line">  right: 60px;</span><br><span class="line">  width: 70px;  &#x2F;&#x2F;图片素材宽度</span><br><span class="line">  height: 900px;  &#x2F;&#x2F;图片素材高度</span><br><span class="line">  top: -900px;</span><br><span class="line">  bottom: unset;</span><br><span class="line">  transition: all .5s ease-in-out;</span><br><span class="line">  background: url(&quot;&#x2F;images&#x2F;scroll.png&quot;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;隐藏箭头图标</span><br><span class="line">  &gt; i &#123;</span><br><span class="line">    display: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;.back-to-top-on &#123;</span><br><span class="line">    bottom: unset;</span><br><span class="line">    top: 100vh &lt; (900px + 200px) ? calc( 100vh - 900px - 200px ) : 0px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷新浏览器即可预览效果。</p>
<h4 id="七、鼠标点击特效"><a href="#七、鼠标点击特效" class="headerlink" title="七、鼠标点击特效"></a>七、鼠标点击特效</h4><p>点击下方按钮下载相应的脚本，并置于 themes\next\source\js\cursor\ 目录下：</p>
<p><a href="https://script-1256884783.file.myqcloud.com/cursor/fireworks.js" target="_blank" rel="noopener">下载</a></p>
<p>在主题自定义布局文件中添加以下代码：</p>
<blockquote>
<p>themes\next\layout_custom\custom.swig</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# 鼠标点击特效 #&#125;</span><br><span class="line">&#123;% if theme.cursor_effect &#x3D;&#x3D; &quot;fireworks&quot; %&#125;</span><br><span class="line">  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;fireworks.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect &#x3D;&#x3D; &quot;explosion&quot; %&#125;</span><br><span class="line">  &lt;canvas class&#x3D;&quot;fireworks&quot; style&#x3D;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;animejs&#x2F;2.2.0&#x2F;anime.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;explosion.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect &#x3D;&#x3D; &quot;love&quot; %&#125;</span><br><span class="line">  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;love.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect &#x3D;&#x3D; &quot;text&quot; %&#125;</span><br><span class="line">  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;text.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">themes\next\layout\_layout.swig</span><br><span class="line">      ...</span><br><span class="line">      &#123;% include &#39;_third-party&#x2F;exturl.swig&#39; %&#125;</span><br><span class="line">      &#123;% include &#39;_third-party&#x2F;bookmark.swig&#39; %&#125;</span><br><span class="line">      &#123;% include &#39;_third-party&#x2F;copy-code.swig&#39; %&#125;</span><br><span class="line"></span><br><span class="line">+     &#123;% include &#39;_custom&#x2F;custom.swig&#39; %&#125;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">  &lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>在主题配置文件中添加以下代码：</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mouse click effect: fireworks | explosion | love | text</span><br><span class="line">cursor_effect: fireworks</span><br></pre></td></tr></table></figure>
<p>这样即可在配置文件中一键快速切换鼠标点击特效。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>二、Hexo 搭建个人博客系列：写作技巧篇</title>
    <url>/2020/06/13/Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7%E7%AF%87/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/20/NlQqVH.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">梦境夜空</div>
</center>

<blockquote>
<p>本文搭建Hexo主要参考<a href="http://yearito.cn/tags/Hexo/" target="_blank" rel="noopener">Yearito’s Blog</a></p>
</blockquote>
<h3 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h3><p>在博客目录下执行如下命令新建一篇文章</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果未指定文章的布局（layout），则默认使用 post 布局，生成的文档存放于 source_posts\ 目录下，打开后使用 Markdown 语法进行写作，保存后刷新浏览器即可看到文章。</p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>布局是什么概念呢，你可以理解为新建文档时的一个模板，基于布局生成的文档将会继承布局的样式。</p>
<p>Hexo 默认有三种布局：post、 page 和 draft，用户可以在 scaffolds 目录下新建文档来自定义布局格式，还可以修改站点配置文件中的 default_layout参数来指定生成文档时的默认布局。</p>
<h4 id="文章（post）"><a href="#文章（post）" class="headerlink" title="文章（post）"></a>文章（post）</h4><p>基于 post 布局生成的文档存在于 source_posts\ 目录下，该目录下的文档会作为博客正文显示在网站中。</p>
<h4 id="页面（page）"><a href="#页面（page）" class="headerlink" title="页面（page）"></a>页面（page）</h4><p>page 布局用于生成类似 首页 和 归档 这样的页面。默认的 Next 主题样式中只包含首页和归档这两个链接，可以通过修改主题配置文件中的 menu 字段来新增更多页面菜单。</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  about: &#x2F;about&#x2F; || user</span><br><span class="line">+ tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">+ categories: &#x2F;categories&#x2F; || th</span><br><span class="line">+ archives: &#x2F;archives&#x2F; || archive</span><br></pre></td></tr></table></figure>

<h4 id="草稿（draft）"><a href="#草稿（draft）" class="headerlink" title="草稿（draft）"></a>草稿（draft）</h4><p>draft 布局用于创建草稿，生成的文档存在于 source_drafts\ 目录中，默认配置下将不会把该目录下的文档渲染到网站中。</p>
<p>通过以下命令将草稿发布为正式文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo publish &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>该命令会将 source_drafts\ 目录下</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>四、Hexo 搭建个人博客系列：进阶设置篇</title>
    <url>/2020/06/21/Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%E8%BF%9B%E9%98%B6%E8%AE%BE%E7%BD%AE%E7%AF%87/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/21/Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%E8%BF%9B%E9%98%B6%E8%AE%BE%E7%BD%AE%E7%AF%87/星辰.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">醉美星辰</div>
</center>

<blockquote>
<p>本文搭建Hexo主要参考<a href="http://yearito.cn/tags/Hexo/" target="_blank" rel="noopener">Yearito’s Blog</a></p>
</blockquote>
<h4 id="一、后台管理界面"><a href="#一、后台管理界面" class="headerlink" title="一、后台管理界面"></a>一、后台管理界面</h4><a id="more"></a>
<p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-admin</span><br></pre></td></tr></table></figure>
<p>浏览器访问localhost:4000/admin</p>
<h4 id="二、站点访问量统计"><a href="#二、站点访问量统计" class="headerlink" title="二、站点访问量统计"></a>二、站点访问量统计</h4><p>在页脚布局模板文件首行添加如下代码：</p>
<blockquote>
<p>themes\next\layout_partial\footer.swig</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>在文件末尾添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;br&gt;</span><br><span class="line">Total &lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt; views.</span><br><span class="line">&lt;br&gt;</span><br><span class="line">您是闳的第&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;个小伙伴</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;span id&#x3D;&quot;busuanzi_value_page_pv&quot;&gt;&lt;&#x2F;span&gt; Hits</span><br></pre></td></tr></table></figure>

<h4 id="三、站点及文章字数统计"><a href="#三、站点及文章字数统计" class="headerlink" title="三、站点及文章字数统计"></a>三、站点及文章字数统计</h4><p>在根目录下执行如下命令安装相关依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<p>启用该功能需要同时修改站点配置文件和主题配置文件。</p>
<p>将如下配置项添加到站点配置文件中，这些配置项主要用于控制每项统计信息是否显示。</p>
<blockquote>
<p>_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true # 统计单篇文章字数</span><br><span class="line">  time: false # 取消估算单篇文章阅读时间</span><br><span class="line">  total_symbols: true # 统计站点总字数</span><br><span class="line">  total_time: false # 取消估算站点总阅读时间</span><br></pre></td></tr></table></figure>
<p>在主题配置文件中做如下修改，这些配置项主要用于控制统计信息的显示样式。</p>
<blockquote>
<p>themes\next\ _config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: false # 统计信息不换行显示</span><br><span class="line">  item_text_post: true # 文章统计信息中是否显示“本文字数&#x2F;阅读时长”等描述文字</span><br><span class="line">  item_text_total: true # 站点统计信息中是否显示“本文字数&#x2F;阅读时长”等描述文字</span><br><span class="line">  awl: 4 # Average Word Length：平均字符长度</span><br><span class="line">  wpm: 275 # Words Per Minute：阅读速度</span><br></pre></td></tr></table></figure>
<p>汉字的平均字符长度为 1.5，如果在文章中使用纯中文进行写作（没有混杂英文），那么推荐设置 awl: 2 及 wpm: 300，但是如果文章中存在英文，建议设置 awl: 4 及 wpm: 275。</p>
<h4 id="四、添加评论功能"><a href="#四、添加评论功能" class="headerlink" title="四、添加评论功能"></a>四、添加评论功能</h4><p>Next 已经内置了 Valine 组件，在主题配置文件中开启评论功能即可，同时，由于 Valine 是基于 Leancloud 提供后端服务的，所以需要填写 LeanCloud 的 App ID 和 App Key。</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid:  ***&lt;app_id***</span><br><span class="line">  appkey: ***&lt;app_key&gt;***</span><br><span class="line">  notify: false  # 收到新评论是否邮件通知</span><br><span class="line">  verify: false  # 是否开启验证码</span><br><span class="line">  placeholder:  # 默认填充文字</span><br><span class="line">  avatar: mm  # 设置默认评论列表</span><br><span class="line">  guest_info: nick,mail  # 评论区头部表单</span><br><span class="line">  pageSize: 10  # 每页评论数</span><br><span class="line">  visitor: true  # 同时开启文章阅读次数统计</span><br></pre></td></tr></table></figure>

<h4 id="五、添加打赏功能"><a href="#五、添加打赏功能" class="headerlink" title="五、添加打赏功能"></a>五、添加打赏功能</h4><p>启用主题配置文件中的打赏相关字段，并将个人收款码图片置于 themes\next\source\images\ 目录下，注意保持图片命名与配置文件中一致：</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  # If true, reward will be displayed in every article by default.</span><br><span class="line">  enable: true</span><br><span class="line">  animation: true</span><br><span class="line">  comment: 你的支持就是我前进的动力</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  #wechatpay: &#x2F;images&#x2F;wechatpay.png</span><br><span class="line">  #alipay: &#x2F;images&#x2F;alipay.png</span><br><span class="line">  #paypal: &#x2F;images&#x2F;paypal.png</span><br><span class="line">  #bitcoin: &#x2F;images&#x2F;bitcoin.png</span><br><span class="line">  wechatpay: &#x2F;images&#x2F;wechatpay.jpg</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.jpg</span><br></pre></td></tr></table></figure>

<h4 id="六、添加图片灯箱"><a href="#六、添加图片灯箱" class="headerlink" title="六、添加图片灯箱"></a>六、添加图片灯箱</h4><p>添加灯箱功能，实现点击图片后放大聚焦图片，并支持幻灯片播放、全屏播放、缩略图、快速分享到社交媒体等，该功能由 fancyBox 提供<br>在根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fancybox3 themes&#x2F;next&#x2F;source&#x2F;lib&#x2F;fancybox</span><br></pre></td></tr></table></figure>
<p>在主题配置文件中设置 fancybox: true：</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fancybox: true</span><br></pre></td></tr></table></figure>

<h4 id="七、文章加密访问"><a href="#七、文章加密访问" class="headerlink" title="七、文章加密访问"></a>七、文章加密访问</h4><p>该功能由 hexo-blog-encrypt 插件提供。</p>
<p>在站点根目录中执行以下命令安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-blog-encrypt --save</span><br></pre></td></tr></table></figure>
<p>在站点配置文件中添加如下字段：</p>
<blockquote>
<p>_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">encrypt:</span><br><span class="line">  enable: true</span><br><span class="line">  default_abstract: 此文章已被加密，需要输入密码访问。  &#x2F;&#x2F;首页文章列表中加密文章的默认描述文案</span><br><span class="line">  default_message: 请输入密码以阅读这篇私密文章。  &#x2F;&#x2F;文章详情页的密码输入框上的默认描述文案</span><br></pre></td></tr></table></figure>
<p>然后在文章 Front-Matter 中添加 password 字段用于设置文章访问密码。重启服务器，这个时候可能需要经历较长一段时间的加密过程，请耐心等待，加密完成后刷新页面将会显示密码输入框，输入密码后才能继续访问文章内容。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>一、搭建个人博客系列：基础建站篇</title>
    <url>/2020/06/13/Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%99%E7%AF%87/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img.pc841.com/2018/0730/20180730081702510.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">《逆水寒》</div>
</center>

<blockquote>
<p>本文搭建Hexo主要参考<a href="http://yearito.cn/tags/Hexo/" target="_blank" rel="noopener">Yearito’s Blog</a></p>
</blockquote>
<p>Hexo 是一个高效简洁的静态博客框架，支持 Markdown 写作语法，插件丰富，主题优雅，部署方便。目前已成为多数人博客建站的选择。</p>
<a id="more"></a>
<p>本文为 Hexo 搭建个人博客系列中的第一篇。第一章中介绍了如何在Mac本地搭建 Hexo 博客，第二章中介绍了如何安装使用 Next 主题，第三章和第四章分别介绍了针对于站点和文章详情页的一些基础优化方案。</p>
<h3 id="一、开始使用"><a href="#一、开始使用" class="headerlink" title="一、开始使用"></a>一、开始使用</h3><p>下载 npm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew install npm</span><br></pre></td></tr></table></figure>
<p>在命令行中通过 npm 来安装 Hexo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>-g 表示全局安装，会将 Hexo 命令加入环境变量中，以使其在 cmd 下有效。</p>
<p>新建博客目录，然后在该路径下执行初始化命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p>在根目录下执行如下命令启动 hexo 的内置 Web 服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>该命令还会启动一个简易的 Web 服务器用于提供对内存中网页资源的访问（工作机制类似于 webpack-dev-server），Web 服务器默认监听 4000 端口，用户可在浏览器中通过地址 localhost:4000 访问博客。</p>
<p><a href="https://imgchr.com/i/tvZgrF" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/13/tvZgrF.jpg" alt="tvZgrF.jpg"></a></p>
<center>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">Hexo 默认主题</div>
</center>


<p>此外，可以通过添加命令行参数来支持高级用法：</p>
<ul>
<li>当 4000 端口已被其他应用占用时，可以添加 -p / –port 参数来设置 Web 服务监听的端口号，如hexo s -p 8000</li>
<li>默认情况下，hexo 监听项目目录的文件变化，用户对于项目文件的任何改动都会触发实时解析编译并更新内存中的网页资源，也就是说，用户在本地修改后刷新浏览器就可以看到改动效果。如果不希望 hexo 监听项目目录的文件变化，可以添加 -s / –static 参数，这样本地改动就不会触发 hexo 实时解析更新。</li>
</ul>
<h3 id="二、更换-Next-主题"><a href="#二、更换-Next-主题" class="headerlink" title="二、更换 Next 主题"></a>二、更换 Next 主题</h3><p>Next 作为一款符合广大程序员审美的主题，还是有着较高的出场率的。Hexo 中切换主题的方式非常简单，只需要将主题文件拷贝至根目录下的 themes 文件夹中， 然后修改 _config.yml 文件中的 theme 字段即可。</p>
<p>在根目录下执行以下命令下载主题文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>打开站点配置文件，将 theme 字段的值修改为 next。</p>
<blockquote>
<p>_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>这个时候刷新浏览器页面并不会发生变化，需要重启服务器并刷新才能使主题生效。</p>
<p><img src="https://s1.ax1x.com/2020/06/13/tvQYJH.jpg" alt="tvQYJH.jpg"></p>
<center>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">Hexo next主题</div>
</center>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果重启服务器仍无效，尝试使用 hexo clean 清除缓存</span><br></pre></td></tr></table></figure>

<p>Next 默认主题风格为 Muse，用户可以在主题配置文件中修改 scheme 字段以选择自己喜欢的主题风格：</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<h3 id="三、站点优化"><a href="#三、站点优化" class="headerlink" title="三、站点优化"></a>三、站点优化</h3><h4 id="1-完善站点基础信息"><a href="#1-完善站点基础信息" class="headerlink" title="1.完善站点基础信息"></a>1.完善站点基础信息</h4><p>在站点配置文件中完善网站基本信息：</p>
<blockquote>
<p>_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Yearito&#39;s Blog  # 站点名称</span><br><span class="line">description: Stay hungry, stay foolish.  # 站点描述</span><br><span class="line">language: zh-CN # 设置网站语言为简体中文</span><br><span class="line">author: yearito  # 作者名称</span><br></pre></td></tr></table></figure>
<h4 id="2-修改站点页脚"><a href="#2-修改站点页脚" class="headerlink" title="2.修改站点页脚"></a>2.修改站点页脚</h4><p>在主题配置文件中修改网站页脚信息：</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:  # 底部信息区</span><br><span class="line">  since: 2018  # 建站时间</span><br><span class="line">  icon:</span><br><span class="line">    name: heart   # 图标名称</span><br><span class="line">    animated: true   # 开启动画</span><br><span class="line">    color: &quot;#ff0000&quot;   # 图标颜色</span><br><span class="line"></span><br><span class="line">  powered:</span><br><span class="line">    enable: true  # 显示由 Hexo 强力驱动</span><br><span class="line">    version: false  # 隐藏 Hexo 版本号</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    enable: true  # 显示所用的主题名称</span><br><span class="line">    version: false  # 隐藏主题版本号</span><br></pre></td></tr></table></figure>

<h4 id="3-取消数字编号"><a href="#3-取消数字编号" class="headerlink" title="3.取消数字编号"></a>3.取消数字编号</h4><p>在主题配置文件中关闭目录中的数字编号：</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  number: false  # 关闭目录中的数字编号</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 网络互连.md</title>
    <url>/2018/10/06/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E4%BA%92%E8%BF%9E.md/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/21/N8NY7t.jpg">
    <br>
</center>

<h2 id="一、-什么是交换机"><a href="#一、-什么是交换机" class="headerlink" title="一、 什么是交换机"></a>一、 什么是交换机</h2><ul>
<li>有多个输入端和多个输出端的设备</li>
<li>可将分组或数据帧从一个输入端口传输到一个或多个输出端口</li>
</ul>
<a id="more"></a>
<h2 id="二、交换网络"><a href="#二、交换网络" class="headerlink" title="二、交换网络"></a>二、交换网络</h2><h3 id="1-星形拓扑优点"><a href="#1-星形拓扑优点" class="headerlink" title="1.星形拓扑优点"></a>1.星形拓扑优点</h3><ul>
<li>构建网络链接大量主机</li>
<li>构建网络覆盖大片地理区域</li>
<li>增加新主机不会影响现有主机的性能</li>
</ul>
<h3 id="2-分组交换网络分类"><a href="#2-分组交换网络分类" class="headerlink" title="2.分组交换网络分类"></a>2.分组交换网络分类</h3><ul>
<li>电话网络: 电路交换网络</li>
<li>计算机网络: 分组交换网络</li>
</ul>
<h3 id="3-交换-转发"><a href="#3-交换-转发" class="headerlink" title="3.交换/转发"></a>3.交换/转发</h3><h4 id="（1）三种方法"><a href="#（1）三种方法" class="headerlink" title="（1）三种方法"></a>（1）三种方法</h4><ul>
<li>数据报, 无连接 </li>
<li>虚电路, 面向连接（VCI 具有”链路局部作用域”, 而非全局意义<br>）</li>
<li>源路由（源节点为每一个分组提供网络交换分组时所需的路由信息<br>）</li>
</ul>
<h3 id="4-网桥和局域网交换机"><a href="#4-网桥和局域网交换机" class="headerlink" title="4.网桥和局域网交换机"></a>4.网桥和局域网交换机</h3><h4 id="（1）透明网桥"><a href="#（1）透明网桥" class="headerlink" title="（1）透明网桥"></a>（1）透明网桥</h4><ul>
<li>问题：如何自适应构造转发表?</li>
<li>动机：根据数据帧转发过程自学习构造转发表</li>
<li>解决方案：逆向学习、主机与端口的映射关系学习</li>
</ul>
<h4 id="（2）虚拟局域网-VLAN"><a href="#（2）虚拟局域网-VLAN" class="headerlink" title="（2）虚拟局域网 (VLAN)"></a>（2）虚拟局域网 (VLAN)</h4><ul>
<li>每一个虚拟局域网分配一个标识符</li>
<li>只有两个网段的标识符相同时, 才能完成数据帧的转发 </li>
</ul>
<h2 id="三、互联网络"><a href="#三、互联网络" class="headerlink" title="三、互联网络"></a>三、互联网络</h2><h3 id="1-什么是互联网"><a href="#1-什么是互联网" class="headerlink" title="1.什么是互联网?"></a>1.什么是互联网?</h3><ul>
<li>“单一”网络的互联集合</li>
<li>视为“网络的网络”: 由许多较小的网络构成</li>
<li>范例: Internet, 当今应用最为广泛的全球性互联网</li>
</ul>
<h3 id="2-服务模型"><a href="#2-服务模型" class="headerlink" title="2.服务模型"></a>2.服务模型</h3><ul>
<li>数据报的一种服务模型</li>
<li>数据流的一种服务模型</li>
</ul>
<h3 id="3-IP服务模型"><a href="#3-IP服务模型" class="headerlink" title="3. IP服务模型"></a>3. IP服务模型</h3><h4 id="分段与重组"><a href="#分段与重组" class="headerlink" title="分段与重组"></a>分段与重组</h4><ul>
<li>主机按照与之直接相连的网络的MTU发送分组</li>
<li>分段重组由目的主机完成</li>
</ul>
<h4 id="网络层的两大核心功能"><a href="#网络层的两大核心功能" class="headerlink" title="网络层的两大核心功能"></a>网络层的两大核心功能</h4><ul>
<li>转发: 将路由器输入端口收到的分组从正确的输出端口发送出去</li>
<li>路由选择: 决定分组从源节点到达目的节点的路径</li>
</ul>
<h3 id="4-全球互联网"><a href="#4-全球互联网" class="headerlink" title="4.全球互联网"></a>4.全球互联网</h3><h4 id="编址方案"><a href="#编址方案" class="headerlink" title="编址方案"></a>编址方案</h4><ul>
<li>Flat 扁平化编址方案</li>
<li>Hierarchy 层次化编址方案</li>
</ul>
<h4 id="层次化地址空间"><a href="#层次化地址空间" class="headerlink" title="层次化地址空间"></a>层次化地址空间</h4><h3 id="5-子网划分"><a href="#5-子网划分" class="headerlink" title="5.子网划分"></a>5.子网划分</h3><ul>
<li>寻址: 子网掩码</li>
<li>IP 转发</li>
</ul>
<h3 id="6-无分类路由选择"><a href="#6-无分类路由选择" class="headerlink" title="6.无分类路由选择"></a>6.无分类路由选择</h3><p>问题：IP地址固定结构的低效性</p>
<p>动机：IP地址不采用固定的分类结构</p>
<p>解决方案：CIDR 汇聚路由</p>
<h3 id="6-无分类路由选择-CIDR"><a href="#6-无分类路由选择-CIDR" class="headerlink" title="6.无分类路由选择(CIDR)"></a>6.无分类路由选择(CIDR)</h3><ul>
<li>最长前缀匹配</li>
</ul>
<h3 id="7-地址转换"><a href="#7-地址转换" class="headerlink" title="7.地址转换"></a>7.地址转换</h3><ul>
<li>ARP工作原理:ip地址到屋里地址转换的问题</li>
</ul>
<h3 id="8-动态主机配置协议-DHCP"><a href="#8-动态主机配置协议-DHCP" class="headerlink" title="8.动态主机配置协议 (DHCP)"></a>8.动态主机配置协议 (DHCP)</h3><h3 id="9-DHCP-工作原理"><a href="#9-DHCP-工作原理" class="headerlink" title="9.DHCP 工作原理"></a>9.DHCP 工作原理</h3><h3 id="10-ICMP"><a href="#10-ICMP" class="headerlink" title="10.ICMP"></a>10.ICMP</h3><ul>
<li>ICMP分组格式</li>
<li>ICMP的应用: traceroute</li>
</ul>
<h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><ul>
<li>路由表和转发表</li>
<li>本节讨论小到中型网络的路由选择问题, 而非整个Internet的.</li>
</ul>
<h3 id="1、用图表示网络"><a href="#1、用图表示网络" class="headerlink" title="1、用图表示网络"></a>1、用图表示网络</h3><ul>
<li>节点: 路由器</li>
<li>边: 链路</li>
<li>寻找两个节点之间较低成本的路径的问题</li>
</ul>
<h3 id="2、距离向量-RIP"><a href="#2、距离向量-RIP" class="headerlink" title="2、距离向量 (RIP)"></a>2、距离向量 (RIP)</h3><h4 id="设计选项"><a href="#设计选项" class="headerlink" title="设计选项"></a>设计选项</h4><ul>
<li>如何获得拓扑信息</li>
<li>什么时候分发拓扑信息</li>
</ul>
<h4 id="距离向量路由选择"><a href="#距离向量路由选择" class="headerlink" title="距离向量路由选择"></a>距离向量路由选择</h4><h4 id="无穷计算问题的解决方案"><a href="#无穷计算问题的解决方案" class="headerlink" title="无穷计算问题的解决方案"></a>无穷计算问题的解决方案</h4><h3 id="3、链路状态-OSPF"><a href="#3、链路状态-OSPF" class="headerlink" title="3、链路状态(OSPF)"></a>3、链路状态(OSPF)</h3><ul>
<li>可靠洪泛</li>
<li>路由计算 </li>
<li>OSPF 协议</li>
</ul>
<h3 id="4、路由评价指标"><a href="#4、路由评价指标" class="headerlink" title="4、路由评价指标"></a>4、路由评价指标</h3>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 TCP</title>
    <url>/2018/10/06/%E7%AC%AC%E4%BA%94%E7%AB%A0%20TCP/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/21/N8Ur8O.jpg">

</center>

<!-- <center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="./InterNet/5.jpg">
</center> -->

<h2 id="一、拥塞"><a href="#一、拥塞" class="headerlink" title="一、拥塞"></a>一、拥塞</h2><h4 id="1-当网络负载持续大于其承载能力则发生拥塞"><a href="#1-当网络负载持续大于其承载能力则发生拥塞" class="headerlink" title="1.当网络负载持续大于其承载能力则发生拥塞"></a>1.当网络负载持续大于其承载能力则发生拥塞</h4><h4 id="2-拥塞现象的体现"><a href="#2-拥塞现象的体现" class="headerlink" title="2.拥塞现象的体现"></a>2.拥塞现象的体现</h4><ul>
<li>持续的分组丢失</li>
<li>分组时延不断增加</li>
</ul>
<a id="more"></a>

<h2 id="二、资源分配"><a href="#二、资源分配" class="headerlink" title="二、资源分配"></a>二、资源分配</h2><h3 id="1-网络模型"><a href="#1-网络模型" class="headerlink" title="1. 网络模型"></a>1. 网络模型</h3><ul>
<li>分组交换网</li>
<li>无连接流</li>
<li>服务模型</li>
</ul>
<h3 id="2-资源分配性能评估指标"><a href="#2-资源分配性能评估指标" class="headerlink" title="2.资源分配性能评估指标"></a>2.资源分配性能评估指标</h3><p>能力 = 吞吐量/时延</p>
<ul>
<li>吞吐量</li>
<li>时延</li>
</ul>
<h3 id="3-拥塞控制方法分类"><a href="#3-拥塞控制方法分类" class="headerlink" title="3.拥塞控制方法分类"></a>3.拥塞控制方法分类</h3><ul>
<li>端到端拥塞控制</li>
<li>网络协助拥塞控制</li>
</ul>
<h2 id="三、排队规则"><a href="#三、排队规则" class="headerlink" title="三、排队规则"></a>三、排队规则</h2><h3 id="1-排队规则-FIFO"><a href="#1-排队规则-FIFO" class="headerlink" title="1.排队规则: FIFO"></a>1.排队规则: FIFO</h3><ul>
<li>调度算法 vs 缓存管理</li>
<li>FIFO: First-In-First-Out / FCFS : First-Come-First-Served</li>
<li>缓存管理: 分组丢弃策略</li>
</ul>
<h3 id="2-排队规则-优先调度"><a href="#2-排队规则-优先调度" class="headerlink" title="2.排队规则: 优先调度"></a>2.排队规则: 优先调度</h3><ul>
<li>优先传输高优先级队列中的分组</li>
<li>不同类型的流量具有不同的优先级</li>
</ul>
<h3 id="3-排队规则-循环调度"><a href="#3-排队规则-循环调度" class="headerlink" title="3.排队规则: 循环调度"></a>3.排队规则: 循环调度</h3><ul>
<li>分组被分成不同类别(与优先级排队一样)</li>
<li>在类之间不存在严格的服务优先级，循环调度器在这些类之间轮流提供服务。 </li>
</ul>
<h3 id="4-排队规则-加权公平排队调度"><a href="#4-排队规则-加权公平排队调度" class="headerlink" title="4.排队规则:加权公平排队调度"></a>4.排队规则:加权公平排队调度</h3><ul>
<li>分组分类，在每个类的等待区域排队, 调度器循环为各类分组提供服务</li>
<li>每个类被分配一个加权，因此每一类在任何时间间隔内可能得到不同数量的服务</li>
<li>模拟比特级的循环调度，计算每个分组的发送完毕时间Fi, 并按照Fi的先后时间发送分组</li>
</ul>
<h2 id="四、TCP-拥塞控制"><a href="#四、TCP-拥塞控制" class="headerlink" title="四、TCP 拥塞控制"></a>四、TCP 拥塞控制</h2><h3 id="1-两个基本问题"><a href="#1-两个基本问题" class="headerlink" title="1.两个基本问题"></a>1.两个基本问题</h3><ul>
<li>如何察觉网络拥塞?<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以超时作为网络拥塞的标志</span><br></pre></td></tr></table></figure></li>
<li>如何调整发送速率?<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP维护一个CongestionWindow 变量</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-接收窗口-vs-拥塞窗口"><a href="#2-接收窗口-vs-拥塞窗口" class="headerlink" title="2.接收窗口 vs 拥塞窗口"></a>2.接收窗口 vs 拥塞窗口</h3><ul>
<li>流量控制</li>
<li>拥塞控制</li>
<li>不同的概念, 但是采用类似的机制</li>
</ul>
<h3 id="3-TCP的两种丢包"><a href="#3-TCP的两种丢包" class="headerlink" title="3.TCP的两种丢包"></a>3.TCP的两种丢包</h3><ul>
<li>超时</li>
<li>三个重复的ACK</li>
</ul>
<h3 id="4-快速重传与快速恢复"><a href="#4-快速重传与快速恢复" class="headerlink" title="4.快速重传与快速恢复"></a>4.快速重传与快速恢复</h3><h3 id="5-TCP的发展"><a href="#5-TCP的发展" class="headerlink" title="5.TCP的发展"></a>5.TCP的发展</h3><ul>
<li>基于简单滑动窗口的流量控制机制.</li>
<li>慢启动, 拥塞避免, 快速重传.</li>
<li>快速恢复.</li>
<li>对快速重传进行了修订.</li>
</ul>
<h3 id="6-拥塞避免"><a href="#6-拥塞避免" class="headerlink" title="6.拥塞避免"></a>6.拥塞避免</h3><ul>
<li>DECbit</li>
<li>RED</li>
<li>基于源</li>
</ul>
<h2 id="五、服务质量-QoS"><a href="#五、服务质量-QoS" class="headerlink" title="五、服务质量(QoS)"></a>五、服务质量(QoS)</h2><h3 id="1、应用需求"><a href="#1、应用需求" class="headerlink" title="1、应用需求"></a>1、应用需求</h3><ul>
<li>多媒体应用和服务质量</li>
<li>多媒体网络应用 </li>
<li>点播流媒体音频和视频 </li>
<li>存储式流媒体音频和视频</li>
<li>直播流媒体音频和视频</li>
</ul>
<h3 id="2-区分服务-EF、AF"><a href="#2-区分服务-EF、AF" class="headerlink" title="2.区分服务(EF、AF)"></a>2.区分服务(EF、AF)</h3><ul>
<li>提供多个服务等级</li>
<li>音频应用和FTP传输</li>
<li>区分服务(DiffServ)</li>
<li>边缘路由器分组标记</li>
<li>分类和调节</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业,难舍喻家山</title>
    <url>/2020/06/21/%E6%AF%95%E4%B8%9A-%E9%9A%BE%E8%88%8D%E5%96%BB%E5%AE%B6%E5%B1%B1/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/21/%E6%AF%95%E4%B8%9A-%E9%9A%BE%E8%88%8D%E5%96%BB%E5%AE%B6%E5%B1%B1/山川岁月.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">山川岁月</div>
</center>

<center>文 |  易子闳</center> 

<p>&emsp;&emsp;弃我去者，昨日之日不可留；乱我心者，今日之日多烦忧。坐上了南下的动车，在车上思绪万千。因为疫情，我们只有短短的三日回学校毕业，没有想象中的热闹与繁华，只有满眼的落寞与冷清。回学校办了手续，独自骑上电动车，满富仪式感地游览校园，不知怎的，思绪如流水般流淌，泪水和雨水在眼眸交织，慢慢回忆过往，慢慢与喻家山告别。</p>
<a id="more"></a>
<p>&emsp;&emsp;子在川上曰：逝者如斯乎，不舍昼夜。多少人的青春留在了喻家山下，多少的回忆成了过往，有多少想说的话，多少想表达的情感，都化成了朋友圈一张张或哭或笑的照片，都揉进了一首首或慷慨激昂或低沉婉转的歌曲里。历史，对于旁观者只是一段故事，而对于亲历者却是数不尽的喜悦与感伤。分享之人，必有想说之事，可未必所有人都会停留听你诉说，对过客来说，你说的是故事，可对你来说却是四年的轰轰烈烈的时光呀。光阴何尝不是一条河流，我们伫立在河中央，河水从身旁流过，带着丝丝无情与坚定，无论我们如何努力，它还是义无反顾地流走了。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/21/%E6%AF%95%E4%B8%9A-%E9%9A%BE%E8%88%8D%E5%96%BB%E5%AE%B6%E5%B1%B1/时间倒影.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">时间倒影</div>
</center>

<p>&emsp;&emsp;多少个日夜，每当我在聚精会神地阅读学习的时候，灯突然灭了，这是启明的规定：在启明楼里的学生必须十二点离开。我多么恨那只拉电闸的手，它恶狠狠地又从我的生命中割走了一天。走出启明，一个人在回去的路上，望着朦胧月色，我泪眼汪汪，感叹时光流逝。弃我去的不是日历上一个个日子，而是我生命中的岁月；甚至不仅仅是我的岁月，而是我自己。我们的生命或许是由一个个自己组成，他会因为韵苑可口的拉面而开心，他会因为做错事而懊恼不已，他会为了微机原理课设而彻夜不眠。他仿佛是个孤儿，被遗留在过去的岁月里，他举目无亲，孑然一身。<br>我大声向他呼喊，多么想把他带回，可是我无法与岁月的洪流抗衡，他慢慢成了过往和回忆。或许正是因为成为了回忆，我开始怀恋考试月和胡杨坐绿皮车去主图啃一本本厚厚的专业书，开始觉得在深信服写C++只有成长没有痛苦，开始以为除了淇营就数我和矢量唱歌最好听。岁月的急流带走了自己，也扭曲了记忆，让我们记住了快乐，忘却了痛苦，满满的苦尽甘来的滋味。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/21/%E6%AF%95%E4%B8%9A-%E9%9A%BE%E8%88%8D%E5%96%BB%E5%AE%B6%E5%B1%B1/星辰大海.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">星辰大海</div>
</center>

<p>&emsp;&emsp;临走之前，和新睿聊大学四年到深夜，新睿觉得要是大学四年可以重新来过，那绝对不会这么过。对啊，我还没打卡学校34座食堂，还没把东湖的各个路线摸熟，还没在启明楼下螺蛳粉店最后被推倒之前去吃上最后一碗螺蛳粉，还没去蹭过节节爆满的深度中国，还没在学校里见到自己喜欢的作家方方，还没……还在喻家山时觉得她平白无奇，要走时，她的点点滴滴，化成颗颗璀璨夺目的珍珠，散落在时间的长河，熠熠生辉。在日后的某年某月，和挚友闲聊时，才会把它们从长河中拾起，串成打上了喻家山和Dian烙印的珍珠项链。</p>
<p>&emsp;&emsp;因为失去青春，我们才懂得长大；因为失去岁月，我们才知道缅怀时间。每个人的大学四年，都有自己专属的特点，我们四处找寻团队，交往朋友，就是想把最珍贵的岁月揉进喻家山的历史长河，磨砺颗颗珍珠。回首自己的四年，时光被熔铸在《第一行代码》和《深入理解Java虚拟机》中，被回响于网安组服务器声声轰鸣声中，被填充在海底捞过后的满天星里，被藏匿在游客如织的樱园里，被浸润在团队导师声声教诲之中。人们把失去的称为过去，尚未得到的称为未来，停在手里的称为现在。可是时间何时停留过，现在转瞬即逝，成为过去，我们又拥有什么？</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/21/%E6%AF%95%E4%B8%9A-%E9%9A%BE%E8%88%8D%E5%96%BB%E5%AE%B6%E5%B1%B1/深林小屋.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">深林小屋</div>
</center>

<p>&emsp;&emsp;许多年后，当我们回到喻家山下，看着那一张张陌生稚嫩的面孔，我们难免会怅然若失，因为许多年前，我们才是喻家山的主人，我们才是那篮球场上飞驰的身影，我们才是东九楼里冥思苦想的少年。嫉妒之情油然而生，他们成了喻家山母亲的最小的孩子，他们可以在校园里大喊大笑，他们成了老师心头最疼爱关心的学生。当年喻园吃过的油条最香甜，当年追过的姑娘最动人，当年我们见证了喻家山下那段悲壮的抗疫史，当年我们成了有史以来最特殊的毕业生。可是，多年后，我们努力推掉手头的工作，和当年的同学相聚，我们寻访恩师，故地重游，企图找回当年的爱恨情仇，酸甜苦辣，然而这一切都是徒劳。我们终于怅然发现，时光带走的不只是我们最美好的青春，而是由当年善良的人，高大的梧桐，壮丽的大楼，巍峨的喻家山，蔚蓝的天空一起组成的世界，其中还包含着我们的爱和忧愁，感觉和性情，我们当年整个的心灵世界呀！</p>
<p>&emsp;&emsp;莫问前路无知己，天下谁人不识君。多年前，喻家山下走出了微信之父张小龙，中国网球第一人李娜，中国外科之父裘法祖。喻家山人在各行各业崭露头角，独领风骚。我们处在喻家山的不同的时代，但是却得到了喻家山同样的哺育与关爱，今天的他们，必定会是明天的我们。</p>
]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 基础</title>
    <url>/2018/10/06/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/21/N8NUtf.jpg">
    <br>
</center>

<h1 id="第一章-基础"><a href="#第一章-基础" class="headerlink" title="第一章 基础"></a>第一章 基础</h1><h2 id="一、什么是网络"><a href="#一、什么是网络" class="headerlink" title="一、什么是网络"></a>一、什么是网络</h2><a id="more"></a>
<h3 id="（1）-什么是网络"><a href="#（1）-什么是网络" class="headerlink" title="（1） 什么是网络"></a>（1） 什么是网络</h3><ul>
<li>将两个或多个实体连接为在一起的系统；</li>
</ul>
<h3 id="（2）计算机网络"><a href="#（2）计算机网络" class="headerlink" title="（2）计算机网络"></a>（2）计算机网络</h3><ul>
<li>自主计算机的互联集合</li>
<li>互联网是一个典型的计算机网络</li>
</ul>
<h3 id="（3）协议"><a href="#（3）协议" class="headerlink" title="（3）协议"></a>（3）协议</h3><ul>
<li>控制发送和接受信息</li>
<li>例如：TCP、IP、HTTP、Skype</li>
</ul>
<h2 id="二、如何建造计算机网络"><a href="#二、如何建造计算机网络" class="headerlink" title="二、如何建造计算机网络"></a>二、如何建造计算机网络</h2><h3 id="1-连通性"><a href="#1-连通性" class="headerlink" title="1 连通性"></a>1 连通性</h3><p>（1）链路</p>
<ul>
<li>点到点链路</li>
<li>节点：中间结点</li>
</ul>
<p>（2）交换网络</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">交换网络</span><br><span class="line"></span><br><span class="line">一种基础网络</span><br><span class="line"></span><br><span class="line">两种类型的交换网络：电路交换和分组交换</span><br></pre></td></tr></table></figure>

<p>（3）网络互连</p>
<ul>
<li>多个独立的网络相互连接形成互联网</li>
<li>路由器、网关：连接两个或多个网络的特殊节点</li>
</ul>
<p>（4）主机和主机的连通性</p>
<ul>
<li>直接连接或间接连接</li>
<li>网络节点的识别</li>
</ul>
<p>（5）路由</p>
<ul>
<li>如何将报文发至目的节点</li>
</ul>
<h3 id="2-可拓展的连通性"><a href="#2-可拓展的连通性" class="headerlink" title="2 可拓展的连通性"></a>2 可拓展的连通性</h3><p>（1）梅特卡夫定律</p>
<ul>
<li>是指网络价值以用户数量的平方的速度增长。 这个法则告诉我们：网络中总人数是n，网络价值是n×n=n²。</li>
</ul>
<h3 id="3-通信网络的分类"><a href="#3-通信网络的分类" class="headerlink" title="3 通信网络的分类"></a>3 通信网络的分类</h3><ul>
<li>交换网络（考试会考计算时间）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">电路交换--多路复用、时分复用、频分复用</span><br><span class="line">        --网络资源被分成片</span><br><span class="line">        --优点：带宽保证、通信可靠、路由机制简单、数据包结构的额外开销小</span><br><span class="line">        --缺点：浪费带宽、受限连接、连接建立延时、网络状态</span><br><span class="line">        --电话网</span><br><span class="line">        </span><br><span class="line">分组交换：数据通过离散的数据分组进行传输</span><br><span class="line">        --先把较长的报文划分较短的、固定长的数据段</span><br><span class="line">        --每个数据前添加收不构成分组</span><br><span class="line">        --统计复用</span><br><span class="line">        --实例：ip数据网</span><br><span class="line">报文交换</span><br></pre></td></tr></table></figure></li>
<li>广播网络</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传播时延</span><br><span class="line"></span><br><span class="line">传输时延</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">排队</span><br><span class="line"></span><br><span class="line">丢包</span><br></pre></td></tr></table></figure>

<h3 id="4-通用服务"><a href="#4-通用服务" class="headerlink" title="4 通用服务"></a>4 通用服务</h3><h4 id="1-什么是通用服务"><a href="#1-什么是通用服务" class="headerlink" title="(1)什么是通用服务"></a>(1)什么是通用服务</h4><ul>
<li>一些可以被应用车农夫调用的构件</li>
</ul>
<h4 id="2-相同的通信模式"><a href="#2-相同的通信模式" class="headerlink" title="(2)相同的通信模式"></a>(2)相同的通信模式</h4><ul>
<li>请求/响应</li>
<li>消息流</li>
</ul>
<h4 id="3-三类故障"><a href="#3-三类故障" class="headerlink" title="(3)三类故障"></a>(3)三类故障</h4><ul>
<li>比特错误</li>
<li>分组丢失</li>
<li>节点宕机</li>
</ul>
<h3 id="5-分层结构中的一些基本概念"><a href="#5-分层结构中的一些基本概念" class="headerlink" title="5 分层结构中的一些基本概念"></a>5 分层结构中的一些基本概念</h3><h4 id="（1）实体"><a href="#（1）实体" class="headerlink" title="（1）实体"></a>（1）实体</h4><h4 id="（2）协议"><a href="#（2）协议" class="headerlink" title="（2）协议"></a>（2）协议</h4><ul>
<li>语法：数据与控制信息的结构或格式</li>
<li>语义：需要发出何种控制信息，完成何的种动作以及做出何种响应。</li>
<li>同步：事件实现顺序详细说明。</li>
</ul>
<h2 id="三、非常重要，但是自己已经弄懂的了问题"><a href="#三、非常重要，但是自己已经弄懂的了问题" class="headerlink" title="三、非常重要，但是自己已经弄懂的了问题"></a>三、非常重要，但是自己已经弄懂的了问题</h2><h3 id="1-电路交换的有点和缺点，以及需要辩证地理解其有缺点。"><a href="#1-电路交换的有点和缺点，以及需要辩证地理解其有缺点。" class="headerlink" title="1 电路交换的有点和缺点，以及需要辩证地理解其有缺点。"></a>1 电路交换的有点和缺点，以及需要辩证地理解其有缺点。</h3><p>答：电路交换的优点：带宽保证、通信可靠、路由机制简单、数据包结构的额外开销小。</p>
<p>缺点：浪费带宽、受限连接、连接建立延时、网络状态。</p>
<p>理解：电路交换的优缺点实质就是相互关联的，在一定的环境下，优点可能演变为缺点，缺点可能演变为优点，我们只有真正理解事物的本质，才能让事物为我们所用，取长补短。</p>
<h3 id="2-分组交换的优点和缺点，以及需要辩证地理解其有缺点。"><a href="#2-分组交换的优点和缺点，以及需要辩证地理解其有缺点。" class="headerlink" title="2 分组交换的优点和缺点，以及需要辩证地理解其有缺点。"></a>2 分组交换的优点和缺点，以及需要辩证地理解其有缺点。</h3><p>答：优点：不存在带宽浪费、多路复用技术、服务、健壮性。</p>
<p>缺点：无法保证带宽、每个分组的开销、复杂的端到端控制、时延和拥塞。</p>
<h2 id="四、自己没有弄懂的问题"><a href="#四、自己没有弄懂的问题" class="headerlink" title="四、自己没有弄懂的问题"></a>四、自己没有弄懂的问题</h2><h3 id="1-关于计算机网络应用问题，它对应着现代企业中的什么工作，下一代计算机网络会是怎样的？"><a href="#1-关于计算机网络应用问题，它对应着现代企业中的什么工作，下一代计算机网络会是怎样的？" class="headerlink" title="1 关于计算机网络应用问题，它对应着现代企业中的什么工作，下一代计算机网络会是怎样的？"></a>1 关于计算机网络应用问题，它对应着现代企业中的什么工作，下一代计算机网络会是怎样的？</h3><h3 id="2-Ipv4和Ipv6的相同和区别？"><a href="#2-Ipv4和Ipv6的相同和区别？" class="headerlink" title="2 Ipv4和Ipv6的相同和区别？"></a>2 Ipv4和Ipv6的相同和区别？</h3><h3 id="3-对于分组交换存在的丢包情况，我们在平时上网中是不是下载一个东西，在下到一半的情况下突然下载失败了，这是不是就是丢包了？如果丢包，用户层面是如何体现的？"><a href="#3-对于分组交换存在的丢包情况，我们在平时上网中是不是下载一个东西，在下到一半的情况下突然下载失败了，这是不是就是丢包了？如果丢包，用户层面是如何体现的？" class="headerlink" title="3 对于分组交换存在的丢包情况，我们在平时上网中是不是下载一个东西，在下到一半的情况下突然下载失败了，这是不是就是丢包了？如果丢包，用户层面是如何体现的？"></a>3 对于分组交换存在的丢包情况，我们在平时上网中是不是下载一个东西，在下到一半的情况下突然下载失败了，这是不是就是丢包了？如果丢包，用户层面是如何体现的？</h3><h3 id="4-对于网络7层我们在什么样的工程应用中会遇到，这7层本质是协议，还是什么，设计这么多层是否显得过于冗余？"><a href="#4-对于网络7层我们在什么样的工程应用中会遇到，这7层本质是协议，还是什么，设计这么多层是否显得过于冗余？" class="headerlink" title="4 对于网络7层我们在什么样的工程应用中会遇到，这7层本质是协议，还是什么，设计这么多层是否显得过于冗余？"></a>4 对于网络7层我们在什么样的工程应用中会遇到，这7层本质是协议，还是什么，设计这么多层是否显得过于冗余？</h3><h2 id="五、分层的协议层"><a href="#五、分层的协议层" class="headerlink" title="五、分层的协议层"></a>五、分层的协议层</h2><h3 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h3><ul>
<li>通过封装, 协议实体可以在分组中携带信息通告对等实体如何处理收到的分组</li>
<li>首部/尾部的加载及分-离</li>
</ul>
<h3 id="二、复用与解复用"><a href="#二、复用与解复用" class="headerlink" title="二、复用与解复用"></a>二、复用与解复用</h3><ul>
<li>复用(Multiplexing)来自源节点不同高层实体的数据，将数据解复用(Demultiplexing)至目的节点对应的高层实体</li>
<li>能够区别数据所属的高层实体需要</li>
<li>各种不同类型的解多路复用密钥</li>
<li>在接收端主机解复用：把收到的报文传送到正确的socket</li>
<li>在发送端主机采用复用：从多个得到数据，并添<br>加头部信息 (后面的分用会socket用到)</li>
</ul>
<h3 id="六、OSI七层模型"><a href="#六、OSI七层模型" class="headerlink" title="六、OSI七层模型"></a>六、OSI七层模型</h3><h4 id="1-各层功能定义"><a href="#1-各层功能定义" class="headerlink" title="1.各层功能定义"></a>1.各层功能定义</h4><ul>
<li>应用层：向终端用户提供各类应用服务, 例如: ftp, telnet</li>
<li>表示层：<br>数据结构表示, 数据格式转换(加密、压缩)</li>
<li>会话层：<br>提供会话管理, 接入控制, 数据传输同步等</li>
<li>传输层：<br>实现终端进程之间的逻辑信道</li>
<li>网络层：<br>处理分组交换网络中的路由选择</li>
<li>数据链路层：<br>收集比特流组合成帧</li>
<li>物理层：<br>处理通信链路上的原始比特流传输</li>
</ul>
<h4 id="2-传输模型"><a href="#2-传输模型" class="headerlink" title="2.传输模型"></a>2.传输模型</h4><ul>
<li>每个层次可以在数据的前后追加本层附加的数据</li>
</ul>
<h4 id="3-网络体系架构的五层模型"><a href="#3-网络体系架构的五层模型" class="headerlink" title="3. 网络体系架构的五层模型"></a>3. 网络体系架构的五层模型</h4><ul>
<li>应用进程数据先传送到应用层</li>
<li>加上应用层首部，成为应用层 PDU</li>
<li>加上运输层首部，成为运输层报文</li>
<li>加上网络层首部，成为 IP 数据报（或分组）</li>
<li>最下面的物理层把比特流传送到物理媒体</li>
</ul>
<h3 id="六、互联网的体系结构"><a href="#六、互联网的体系结构" class="headerlink" title="六、互联网的体系结构"></a>六、互联网的体系结构</h3><h4 id="1-分层结构"><a href="#1-分层结构" class="headerlink" title="1.分层结构"></a>1.分层结构</h4><ul>
<li>应用层</li>
<li>传输层：<br>进程与进程之间的消息传输, 两个主要的协议:<br>TCP (Transmission Control Protocol)<br>UDP (User Datagram Protocol) </li>
<li>IP层：<br>主机到主机的数据分组传输<br>唯一协议: IP</li>
<li>网络接入层：没有指定该层的实际细节，可以是任意一种底层网络</li>
</ul>
<h4 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2.设计原则"></a>2.设计原则</h4><ul>
<li>沙漏模型是Internet能够快速适应用户新应用需求和网络技术更新的关键.</li>
<li>“Simple Core and Complex Host’’ Philosophy</li>
</ul>
<h4 id="3-分组交换网中时延的四个来源"><a href="#3-分组交换网中时延的四个来源" class="headerlink" title="3.分组交换网中时延的四个来源"></a>3.分组交换网中时延的四个来源</h4><ul>
<li>节点处理时延 </li>
<li>排队延时</li>
<li>传输延时</li>
<li>传播延时</li>
</ul>
<h4 id="4-网络性能-吞吐量"><a href="#4-网络性能-吞吐量" class="headerlink" title="4.网络性能: 吞吐量"></a>4.网络性能: 吞吐量</h4><ul>
<li>吞吐量: 发送者与接收者之间比特交换的速率 (比特/单位时间)</li>
<li>瞬时: 在给定时间点的速率</li>
</ul>
<h3 id="七、网络性能"><a href="#七、网络性能" class="headerlink" title="七、网络性能"></a>七、网络性能</h3><h4 id="1-链路带宽"><a href="#1-链路带宽" class="headerlink" title="1.链路带宽"></a>1.链路带宽</h4><ul>
<li>原始定义：信号的频带宽度, 用 Hertz (Hz) 表示</li>
<li>网络定义: 一段特定的时间内网络所能传送的比特数, 用<br>bits per second (bps)表示</li>
</ul>
<h4 id="2-应用性能需求"><a href="#2-应用性能需求" class="headerlink" title="2.应用性能需求"></a>2.应用性能需求</h4><ul>
<li>平均速率及突发流量</li>
<li>内存溢出导致的数据包丢弃</li>
<li>时延抖动</li>
</ul>
<h3 id="八-套接字编程"><a href="#八-套接字编程" class="headerlink" title="八.套接字编程"></a>八.套接字编程</h3><ul>
<li>Socket：一个本地的，应用程序创建的，操作系统控制的接口。</li>
<li>套接字(socket): 应用进程之间的接口，实现端到端的传输协议</li>
<li>Socket API类别<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PF_INET : 用于互联网编程</span><br><span class="line">PF_UNIX: 用于Unix 管道编程</span><br><span class="line">PF_PACKET:直接访问网络接口 (i.e, 绕过TCP &#x2F; IP协议栈)</span><br></pre></td></tr></table></figure></li>
<li>两种基本socket API分别支持两种传输服务:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SOCK_STREAM: 可靠的，字节流服务 (TCP)  SOCK_DGRAM: 非可靠的数据报服务 (UDP)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="没有懂的问题"><a href="#没有懂的问题" class="headerlink" title="没有懂的问题"></a>没有懂的问题</h3><p>1.为什么网络体系架构没有像OSI一样分为7层；</p>
<p>2.链路带宽对于吞吐量有什么影响；</p>
<p>3.对于Socket编程没有在华为组这样的使用经历，我们该怎么深入了解socket编程。</p>
<h3 id="懂了的问题"><a href="#懂了的问题" class="headerlink" title="懂了的问题"></a>懂了的问题</h3><h4 id="1-带宽与吞吐量的区别？"><a href="#1-带宽与吞吐量的区别？" class="headerlink" title="1.带宽与吞吐量的区别？"></a>1.带宽与吞吐量的区别？</h4><p>答：吞吐量和带宽是很容易搞混的一个词，两者的单位都是Mbps。先来看两者对应的英语，吞吐量：throughput；带宽：Max net bitrate。当讨论通信链路的带宽时，一般是指链路上每秒所能传送的比特数，它取决于链路时钟速率和信道编码，在计算机网络中又称为线速。可以说以太网的带宽是10Mbps。但是需要区分链路上的可用带宽（带宽）与实际链路中每秒所能传送的比特数（吞吐量）。通常更倾向于用“吞吐量”一词来表示一个系统的测试性能。这样，因为实现受各种低效率因素的影响，所以由一段带宽为10Mbps的链路连接的一对节点可能只达到2Mbps的吞吐量。这样就意味着，一个主机上的应用能够以2Mbps的速度向另外的一个主机发送数据。</p>
<h4 id="2-网络延迟是怎样产生的？"><a href="#2-网络延迟是怎样产生的？" class="headerlink" title="2.网络延迟是怎样产生的？"></a>2.网络延迟是怎样产生的？</h4><p>网络延迟 = 传输延迟 + 处理延迟 + 缓冲队列延迟</p>
<ul>
<li>1）传输延迟这个延迟很好理解，指光、电信号在有线介质上的延迟，或无线电信号在空气介质中的延迟，这种传输延迟只和光速有关、或电信号的传输速度有关，用户无法改变该延迟。对于一条选定的端对端路径，此值是恒定的。</li>
<li>2）处理延迟接收IP包，查询转发表，硬件、或软件转发，包括封装、解封装、编码、解码时间，经过设备越多，设备吞吐能力越弱（一秒可以转发多少Gb的数据），延迟越大。但对于一条选定的端对端路径，此值也是恒定的。</li>
<li>3）缓冲队列延迟当端到端的路径上，没有任何网络拥塞，缓冲队列的延迟几户为0，网络转发性能达到线速度，好像两端用一根线直连。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>海尔集团总裁周云杰华科毕业典礼演讲：智商＋情商＋逆商铸就魂商</title>
    <url>/2020/06/21/%E5%8D%8E%E4%B8%AD%E5%A4%A7%E4%BA%BA%E5%90%8E%E6%B5%AA%E5%85%A5%E6%B5%B7-%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/21/%E5%8D%8E%E4%B8%AD%E5%A4%A7%E4%BA%BA%E5%90%8E%E6%B5%AA%E5%85%A5%E6%B5%B7-%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F/思维隧道.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">思维隧道</div>
</center>

<blockquote>
<p>本文是海尔集团总裁周云杰在华科2020届毕业典礼演讲辞，听了后感觉对自己思维冲击很大，于是将其收录在自己的博客中，方便日后学习，进步。</p>
</blockquote>
<a id="more"></a>

<p>&emsp;&emsp;尊敬的校领导，尊敬的老师们，亲爱的同学们，大家好。感谢母校邀请我在特殊的时期，以这种特别的方式参加同学们的毕业典礼，一场突如其来的疫情，让2020届毕业生注定是与众不同的。</p>
<p>&emsp;&emsp;人生本身是一场修行，它充满了无数的不确定性，但同时也孕育着无限的可能。所以今天我用7分钟的时间分享三点体会，送给即将走向社会的同学们</p>
<br>
<center><font size="4">一、少年转身不追华丽，但求速度</font></center>
<br>

<p>&emsp;&emsp;人生本身是一场修行，它充满了无数的不确定性，同时也孕育着无限的可能。人生有很多第一次，但毕业踏上社会是人生中比较大的一次转身。</p>
<p>&emsp;&emsp;上学时学校以你为中心。但我建议从今天起就忘记：“我学习成绩很好，我来自名校”。因为从今以后，你不再是中心，你的价值要体现在为他人、为社会创造的价值上。</p>
<p>&emsp;&emsp;角色转换的快慢将决定你事业起步的速度，甚至决定你人生的方向。转身不必华丽，但必须追求速度。</p>
<br>
<center><font size="4">第二，智商+情商+逆商才会铸就魂商。</font></center>
<br>


<p>&emsp;&emsp;能从这个校门走出去的都具有高智商，但我所说的高智商指的是知行合一。《道德经》有云：胜人者有力，自胜者强。既不妄自菲薄，也不妄自尊大，能时刻战胜满足感的人，才是真正高智商的人。情商的高低决定了有多少人帮你，成就事业并不取决于你自己有多大的能耐，拥有多少资源，而在于你可以调动多少人，可以整合多少资源，这就是德鲁克所说的企业即人，管理即借力，高智商需要良好的沟通能力，其关键在于能否换位思考。</p>
<p>&emsp;&emsp;余秋雨说过，这世界上有些时候山是水的故事，云是风的故事。但有些时候星不是夜的故事，情不是爱的故事。生命的旅途中苦过了才知甜蜜，痛过了才懂坚强，傻过了才会成长。有逆商的人不会被困难打倒，视挫折为财富，学会做自己的心理医生。</p>
<p>&emsp;&emsp;高魂商意味着有着大开大合的人生格局，有着改变世界的家国情怀。比如乔布斯曾经说过，活着就是为了改变世界。我们华中大也有一位优秀的校友，张小龙，他发明了微信，改变了人们的生活，也改变了世界。所以我的第二个体会是高智商加高情商，适合从政；高智商加高逆商，适合做科研；高情商加高逆商，适合做企业。当然如果你同时拥有了三高，你可能就会迸发出魂商，成为伟大的政治家，伟大的科学家或者伟大的企业家，这都会是你的选项。</p>
<br>
<center><font size="4">第三，成功的道路并不拥挤，因为坚持的人太少。</font></center>
<br>


<p>&emsp;&emsp;成功是每个人的梦想，但每个成功者的背后又都潜伏着失败的危机。因为成功之前的每一天，你都面对的是失败，而且一旦成功，成功便成为过去时，我很欣赏电视剧《天道》里的一句台词：忍，是一条线；能，又是一条线，这两者之间是你的生存空间，如果做到了忍人所不能忍，能人所不能，那么你的生存空间就会比别人大。</p>
<p>&emsp;&emsp;没有郭平师兄等多位校友在任正非先生领导下的坚持，就没有今天的华为；没有陈宗年等三位师兄的坚持，就没有今天的海康威视；没有黄立师兄的坚持，就没有今天的高德红外；当然没有张瑞敏先生的坚持，也不会有今天的海尔。所以我的第三个体会是在前进的道路上选择与谁同行，比要去的远方更重要。你和你的同伴比别人多坚持一会儿，可能你就成功了。</p>
<p>&emsp;&emsp;萧伯纳说过，改变世界的是这样一群人，他们一直在寻找梦想中的乐园，当他们找不到时，便亲手创造了它。祝愿2020届的同学们带着“明德、厚学、求是、创新”的校训，亲手去创造自己的乐园。</p>
]]></content>
      <categories>
        <category>文集及讲座</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 端到端协议</title>
    <url>/2018/10/06/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/21/N8NyBn.jpg">
    <br>
</center>

<h2 id="一、支持通用服务"><a href="#一、支持通用服务" class="headerlink" title="一、支持通用服务"></a>一、支持通用服务</h2><ul>
<li>目标 1: 网络支持各种不同的应用 </li>
<li>目标 2: 网络在现实网络条件下支持各种不同的应用</li>
</ul>
<a id="more"></a>

<h2 id="二、进程间如何通信"><a href="#二、进程间如何通信" class="headerlink" title="二、进程间如何通信"></a>二、进程间如何通信</h2><h3 id="1-传输层-上层协议的观点"><a href="#1-传输层-上层协议的观点" class="headerlink" title="1.传输层: 上层协议的观点"></a>1.传输层: 上层协议的观点</h3><ul>
<li>保证消息的传输</li>
<li>传送过程中保证消息发送时的顺序</li>
<li>最多传送每个消息的一个副本</li>
<li>支持任意大的消息</li>
<li>支持发送方与接收方之间的同步</li>
<li>允许接收方对发送方进行流量控制</li>
<li>支持每台主机上的多个应用进程</li>
</ul>
<h3 id="2-传输层-下层网络的观点"><a href="#2-传输层-下层网络的观点" class="headerlink" title="2.传输层: 下层网络的观点"></a>2.传输层: 下层网络的观点</h3><ul>
<li>底层网络可以提供的服务:</li>
<li>不可靠的分组传送</li>
<li>不确定的时延</li>
<li>有限大小的分组</li>
</ul>
<h3 id="3-用户数据报协议-UDP"><a href="#3-用户数据报协议-UDP" class="headerlink" title="3.用户数据报协议(UDP)"></a>3.用户数据报协议(UDP)</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>仅在IP基础上增加了一级解多路复用功能</li>
<li>面向报文</li>
<li>无连接</li>
<li>不保证消息的可靠传送</li>
<li>无流量控制 </li>
</ul>
<h4 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h4><ul>
<li>控制数据发送的内容和时间</li>
<li>不存在连接建立时延</li>
<li>无状态连接</li>
<li>报文首部开销较小</li>
</ul>
<h4 id="UDP的缺点"><a href="#UDP的缺点" class="headerlink" title="UDP的缺点"></a>UDP的缺点</h4><ul>
<li>“尽最大努力交付”</li>
<li>无拥塞控制</li>
<li>抑制TCP流</li>
</ul>
<h4 id="采用UDP协议的应用"><a href="#采用UDP协议的应用" class="headerlink" title="采用UDP协议的应用"></a>采用UDP协议的应用</h4><ul>
<li>简单查询协议(例如域名解析系统, DNS)</li>
<li>多媒体应用</li>
</ul>
<h2 id="三、TCP-服务模型"><a href="#三、TCP-服务模型" class="headerlink" title="三、TCP 服务模型"></a>三、TCP 服务模型</h2><h3 id="1-TCP面临的挑战"><a href="#1-TCP面临的挑战" class="headerlink" title="1.TCP面临的挑战"></a>1.TCP面临的挑战</h3><ul>
<li>连接</li>
<li>超时重传</li>
<li>乱序到达</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<h3 id="2-三次握手"><a href="#2-三次握手" class="headerlink" title="2.三次握手"></a>2.三次握手</h3><p>主要是为了防止已经失效的连接请求报文段又被接收方<br>收到而导致的错误</p>
<h3 id="3-TCP-滑动窗口算法"><a href="#3-TCP-滑动窗口算法" class="headerlink" title="3.TCP 滑动窗口算法"></a>3.TCP 滑动窗口算法</h3><ul>
<li>可靠有序的数据传送</li>
<li>流量控制</li>
<li>防止回绕</li>
<li>保持管道满载</li>
</ul>
<h3 id="4-TCP中的触发传输"><a href="#4-TCP中的触发传输" class="headerlink" title="4.TCP中的触发传输"></a>4.TCP中的触发传输</h3><ul>
<li>傻瓜窗口症状</li>
<li>当应用层交付数据速度较快，而网络速率较慢时，较小的报文段浪费带宽</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 开始连接</title>
    <url>/2018/10/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BC%80%E5%A7%8B%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/21/N8NNAP.jpg">
    <br>
</center>

<h3 id="一、适配器之间的通信"><a href="#一、适配器之间的通信" class="headerlink" title="一、适配器之间的通信"></a>一、适配器之间的通信</h3><ul>
<li>发送端：将分组封装为数据帧，增加差错检测、可靠传输、留空等功能</li>
<li>接收端：完成差错检测、实施可靠传输</li>
</ul>
<a id="more"></a>

<h3 id="二、直接网络的研究问题"><a href="#二、直接网络的研究问题" class="headerlink" title="二、直接网络的研究问题"></a>二、直接网络的研究问题</h3><ul>
<li>编码：对发送到电缆或光纤上的比特进行编码, 使其能被接收主机所理解</li>
<li>帧定界：把物理链路上传输的比特序列描述为完整的消息，以便传送到端节点</li>
<li>差错检测</li>
<li>可靠传输</li>
<li>通信：如果链路静态共享, 很容易处理</li>
</ul>
<h3 id="三、网络硬件"><a href="#三、网络硬件" class="headerlink" title="三、网络硬件"></a>三、网络硬件</h3><h4 id="1-节点"><a href="#1-节点" class="headerlink" title="1.节点"></a>1.节点</h4><ul>
<li>网络中的两种稀缺资源: 节点的内存及网络链路带宽</li>
<li>网络适配器是节点接入网络的专用设备</li>
</ul>
<h4 id="2-网络适配器"><a href="#2-网络适配器" class="headerlink" title="2.网络适配器"></a>2.网络适配器</h4><ul>
<li>功能<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进行串行&#x2F;并行转换;</span><br><span class="line"></span><br><span class="line">对数据进行缓存;</span><br><span class="line"></span><br><span class="line">设备驱动程序（数据链路层协议）</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="3-链路"><a href="#3-链路" class="headerlink" title="3.链路"></a>3.链路</h4><ul>
<li>导向型媒质: 信号在固态媒质上传播, 例如同轴电缆, 光纤, 双绞线</li>
<li>非导向型媒质: 信号自由传播, 例如电磁波</li>
<li>物理媒介：有线，无线</li>
<li>链路容量（通信信道、信道容量）</li>
</ul>
<h3 id="四、编码"><a href="#四、编码" class="headerlink" title="四、编码"></a>四、编码</h3><h4 id="1-不归零-NRZ-Non-Return-to-Zero"><a href="#1-不归零-NRZ-Non-Return-to-Zero" class="headerlink" title="1.不归零 NRZ (Non-Return to Zero)"></a>1.不归零 NRZ (Non-Return to Zero)</h4><ul>
<li>问题: 连续的1s 或 0s</li>
</ul>
<p>连续的 0s可能被误认为没有信号</p>
<p>连续的 1s可能导致基线漂移</p>
<p>时钟恢复困难（同步问题）</p>
<h4 id="2-曼彻斯特编码"><a href="#2-曼彻斯特编码" class="headerlink" title="2.曼彻斯特编码"></a>2.曼彻斯特编码</h4><ul>
<li>缺点: 信号跳变速率翻倍，比特率是信号跳变速率（波特率）的一半</li>
</ul>
<h3 id="五、组帧"><a href="#五、组帧" class="headerlink" title="五、组帧"></a>五、组帧</h3><h4 id="1-帧定界问题"><a href="#1-帧定界问题" class="headerlink" title="1.帧定界问题"></a>1.帧定界问题</h4><ul>
<li>两个节点之间的数据传输以块为单位(帧)</li>
<li>能够识别数据帧的开始和结束</li>
</ul>
<h3 id="六、可靠传输"><a href="#六、可靠传输" class="headerlink" title="六、可靠传输"></a>六、可靠传输</h3><h4 id="1-停止等待协议"><a href="#1-停止等待协议" class="headerlink" title="1.停止等待协议"></a>1.停止等待协议</h4><ul>
<li><p>链路带宽利用率较低</p>
</li>
<li><p>示例 </p>
</li>
</ul>
<p>链路带宽为2 Mbps, RTT为45 ms, 数据帧大小为1.5KB<br>每一个RTT内, 发送方仅能发送一个数据帧<br>吞吐量为1500x8/0.045 = 266.7kbps</p>
<h4 id="2-连续ARQ协议"><a href="#2-连续ARQ协议" class="headerlink" title="2.连续ARQ协议"></a>2.连续ARQ协议</h4><ul>
<li><p>Go-Back-N</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一次性发送N个数据帧；</span><br><span class="line"></span><br><span class="line">如果第k个帧丢失, 对[k, k+N-1]范围内的所有帧重传。</span><br><span class="line"></span><br><span class="line">优点: 接收方不需要缓存接收到的乱序帧，确认简单</span><br><span class="line"></span><br><span class="line">缺点: 正确帧也可能被重传，效率较低</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择性重传</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一次性发送N个数据帧；</span><br><span class="line"></span><br><span class="line">如果第k个帧丢失, 仅重传第k个帧；</span><br><span class="line"></span><br><span class="line">接收方对每一个帧进行确认。</span><br><span class="line"></span><br><span class="line">优点: 链路利用率较高</span><br><span class="line"></span><br><span class="line">缺点: 接收方更复杂</span><br></pre></td></tr></table></figure>

<h4 id="3-滑动窗口协议ARQ"><a href="#3-滑动窗口协议ARQ" class="headerlink" title="3.滑动窗口协议ARQ"></a>3.滑动窗口协议ARQ</h4><ul>
<li>发送方:发送方在未收到确认前能够发送的数据帧的最大个数</li>
</ul>
<h3 id="七、多路访问控制"><a href="#七、多路访问控制" class="headerlink" title="七、多路访问控制"></a>七、多路访问控制</h3><h4 id="1-两种类型的“链路”"><a href="#1-两种类型的“链路”" class="headerlink" title="1.两种类型的“链路”:"></a>1.两种类型的“链路”:</h4><ul>
<li>点到点链路</li>
<li>广播链路(共享的有线/无线传输媒质)</li>
</ul>
<h4 id="2-共享广播链路通信的基本问题"><a href="#2-共享广播链路通信的基本问题" class="headerlink" title="2.共享广播链路通信的基本问题"></a>2.共享广播链路通信的基本问题</h4><ul>
<li>干扰: 如果两个或多个节点同时传输</li>
<li>冲突: 如果节点同时收到两个或多个信号</li>
</ul>
<h4 id="3-基本解决方法"><a href="#3-基本解决方法" class="headerlink" title="3.基本解决方法"></a>3.基本解决方法</h4><ul>
<li>首先、寻址</li>
<li>其次，多路访问控制协议</li>
</ul>
<h4 id="4-MAC协议"><a href="#4-MAC协议" class="headerlink" title="4.MAC协议"></a>4.MAC协议</h4><ul>
<li><p>静态信道划分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在每次循环中每一个节点占用信道固定时长 (时隙, 长度 &#x3D; 数据帧传输时延) </span><br><span class="line"></span><br><span class="line">将信道划分为较小的 “分片” (时隙, 频率, 编码)</span><br><span class="line"></span><br><span class="line">每一个分片被分配给某一节点专用</span><br></pre></td></tr></table></figure></li>
<li><p>随机接入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不划分信道, 允许冲突发生;</span><br><span class="line">“避免” 冲突或冲突“恢复”;</span><br><span class="line">更适合于基于分组的数据通信;</span><br><span class="line">案例: Aloha, CSMA, …</span><br></pre></td></tr></table></figure>
</li>
<li><p>轮转发送</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">节点轮流发送;</span><br><span class="line">待发送数据量大的节点占用信道更长时间;</span><br><span class="line">无冲突;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="八、问题"><a href="#八、问题" class="headerlink" title="八、问题"></a>八、问题</h3><h4 id="1-已经懂了的问题"><a href="#1-已经懂了的问题" class="headerlink" title="1.已经懂了的问题"></a>1.已经懂了的问题</h4><ul>
<li><p>1.物理链路和数据链路是什么关系？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据链路可以粗略地理解为数据通道。物理层要为终端设备间的数据通信提供传输媒体及其</span><br><span class="line">连接.媒体是长期的,连接是有生存期的.在连接生存期内,收发两端可以进行不等的一次或多次数</span><br><span class="line">据通信.每次通信都要经过建立通信联络和拆除通信联络两过程.这种建立起来的数据收发关系就</span><br><span class="line">叫作数据链路.而在物理媒体上传输的数据难免受到各种不可靠因素的影响而产生差错,为了弥补</span><br><span class="line">物理层上的不足,为上层提供无差错的数据传输,就要能对数据进行检错和纠错.数据链路的建立,</span><br><span class="line">拆除,对数据的检错,纠错是数据链路层的基本任务.</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.检错码和纠错码的区别是什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">检错码：只检错不纠正</span><br><span class="line">纠错码：发现错误并给以纠正</span><br><span class="line">检错码：一种编码。指在传输过程中发生错误后，在接收端能自动检查并发现错误的编码。目前常用的检错码有奇偶校验码、恒比码等 检错码的两大类别:奇偶校验编码和循环冗余编码。</span><br><span class="line">纠错码(error correcting code)，在传输过程中发生错误后能在收端自行发现或纠正的码。仅用来发现错误的码一般常称为检错码。为使一种码具有检错或纠错能力，须对原码字增加多余的码元，以扩大码字之间的差别 ，即把原码字按某种规则变成有一定剩余度（见信源编码）的码字，并使每个码字的码之间有一定的关系。关系的建立称为编码。码字到达收端后，可以根据编码规则是否满足以判定有无错误。当不能满足时，按一定规则确定错误所在位置并予以纠正。纠错并恢复原码字的过程称为译码。检错码与其他手段结合使用，可以纠错。</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="3">
<li>如何理解CRC的基本工作原理?</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CRC校验原理看起来比较复杂，好难懂，因为大多数书上基本上是以二进制的多项式形式来说明的。其实很简单的问题，其根本思想就是先在要发送的帧后面附加一个数（这个就是用来校验的校验码，但要注意，这里的数也是二进制序列的，下同），生成一个新帧发送给接收端。当然，这个附加的数不是随意的，它要使所生成的新帧能与发送端和接收端共同选定的某个特定数整除（注意，这里不是直接采用二进制除法，而是采用一种称之为“模2除法”）。到达接收端后，再把接收到的新帧除以（同样采用“模2除法”）这个选定的除数。因为在发送端发送数据帧之前就已通过附加一个数，做了“去余”处理（也就已经能整除了），所以结果应该是没有余数。如果有余数，则表明该帧在传输过程中出现了差错。</span><br></pre></td></tr></table></figure>

<ul>
<li>4.如何理解滑动窗口控制机理的工作原理?<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP滑动窗口技术通过动态改变窗口大小来调节两台主机间数据传输。每个TCP&#x2F;IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。TCP使用肯定确认技术，其确认号指的是下一个所期待的字节。假定发送方设备以每一次三个数据包的方式发送数据，也就是说，窗口大小为3。发送方发送序列号为1、2、3的三个数据包，接收方设备成功接收数据包，用序列号4确认。发送方设备收到确认，继续以窗口大小3发送数据。当接收方设备要求降低或者增大网络流量时，可以对窗口大小进行减小或者增加，本例降低窗口大小为2，每一次发送两个数据包。当接收方设备要求窗口大小为0，表明接收方已经接收了全部数据，或者接收方应用程序没有时间读取数据，要求暂停发送。发送方接收到携带窗口号为0的确认，停止这一方向的数据传输。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-未理解的问题"><a href="#2-未理解的问题" class="headerlink" title="2.未理解的问题"></a>2.未理解的问题</h4><ul>
<li>1.Go-back-N和选择重传有什么相同之处，他们的最大区别在哪？</li>
<li>2.我们该如何提高停止-等待协议的效率？</li>
<li>3.NS-3我们在实验时时如何模拟现实世界多用户，多并发量的场景的？</li>
</ul>
<h3 id="九、以太网"><a href="#九、以太网" class="headerlink" title="九、以太网"></a>九、以太网</h3><h4 id="1、802-x-标准背景介绍"><a href="#1、802-x-标准背景介绍" class="headerlink" title="1、802.x 标准背景介绍"></a>1、802.x 标准背景介绍</h4><ul>
<li>IEEE 802将数据链路层功能划分为两个子层<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LLC (逻辑链路控制) 子层</span><br><span class="line">MAC (介质访问控制) 子层</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2、物理属性"><a href="#2、物理属性" class="headerlink" title="2、物理属性"></a>2、物理属性</h4><ul>
<li>不能超过四个中继器</li>
<li>一个以太网中最多容纳1024台主机</li>
<li>分类：粗缆、细缆、双绞线</li>
</ul>
<h4 id="3、Ethernet-集线器vs-Ethernet-交换机"><a href="#3、Ethernet-集线器vs-Ethernet-交换机" class="headerlink" title="3、Ethernet 集线器vs. Ethernet 交换机"></a>3、Ethernet 集线器vs. Ethernet 交换机</h4><ul>
<li><p>Ethernet 集线器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">层1设备</span><br><span class="line">简单的信号中继器</span><br><span class="line">为节点提供共享链路</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ethernet Switch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">层2设备</span><br><span class="line">识别数据帧的地址, 完成数据帧的存储转发</span><br><span class="line">为节点提供独立的链接</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-介质访问控制协议"><a href="#4-介质访问控制协议" class="headerlink" title="4.介质访问控制协议"></a>4.介质访问控制协议</h4><ul>
<li>帧定界</li>
<li>差错检测</li>
<li>寻址</li>
<li>多路访问控制算法</li>
</ul>
<h4 id="5-Ethernet-CSMA-CD-协议"><a href="#5-Ethernet-CSMA-CD-协议" class="headerlink" title="5.Ethernet CSMA/CD 协议"></a>5.Ethernet CSMA/CD 协议</h4><h4 id="十、无线网络"><a href="#十、无线网络" class="headerlink" title="十、无线网络"></a>十、无线网络</h4><h4 id="1-无线链路-高比特误码率"><a href="#1-无线链路-高比特误码率" class="headerlink" title="1.无线链路: 高比特误码率"></a>1.无线链路: 高比特误码率</h4><ul>
<li>电磁波的反射</li>
<li>产生多条不同长度的传播路径</li>
<li>在接收方产生模糊信号</li>
</ul>
<h4 id="2-802-11-信道与关联"><a href="#2-802-11-信道与关联" class="headerlink" title="2.802.11: 信道与关联"></a>2.802.11: 信道与关联</h4><h4 id="3-CA-冲突避免-而不是检测"><a href="#3-CA-冲突避免-而不是检测" class="headerlink" title="3. CA: 冲突避免, 而不是检测"></a>3. CA: 冲突避免, 而不是检测</h4><h4 id="4-隐藏终端问题"><a href="#4-隐藏终端问题" class="headerlink" title="4.隐藏终端问题"></a>4.隐藏终端问题</h4><ul>
<li>依赖于物理载波监听, 可能产生隐藏终端问题</li>
</ul>
<h4 id="5-暴露终端问题"><a href="#5-暴露终端问题" class="headerlink" title="5.暴露终端问题"></a>5.暴露终端问题</h4><ul>
<li>虚拟载波监听</li>
<li>RTS/CTS机制</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>PCIe简介</title>
    <url>/2020/06/22/PCIe%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/PCIe%E7%AE%80%E4%BB%8B/neqwon.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">蓝天小屋</div>
</center>

<h4 id="一、PCI-X总线基本概念"><a href="#一、PCI-X总线基本概念" class="headerlink" title="一、PCI-X总线基本概念"></a>一、PCI-X总线基本概念</h4><p>PCI-X总线在PCI总线的基础上发展而来，其在软件和硬件层面上都是兼容PCI总线的，但是却显著的提高了总线的性能。也就是说PCI-X的设备可以直接插到PCI的插槽中去，PCI的设备也可以直接插到PCI-X的插槽中去。</p>
<a id="more"></a>

<p>从硬件层面上来说，PCI-X继承了PCI总线中的Reflected-Wave Signaling，但是在信号的输入端加入了输入寄存器以增强时序性能，提高了总线的时钟频率。在PCI-X2.0的Spec中还提出了DDR和QDR技术，进一步提高了PCI-X总线的带宽。</p>
<p>一个典型的PCI-X总线系统的例子如下图所示：</p>
<p><img src="https://s1.ax1x.com/2020/03/28/GkefGn.png" alt="GkefGn.png"></p>
<p>下面是一个PCI-X 突发读存储操作（Burst Memory Read Bus Cycle）的例子：</p>
<p><img src="https://s1.ax1x.com/2020/03/28/GkeTqU.png" alt="GkeTqU.png"></p>
<p>在PCI总线中，以总线主机从从机设备读操作为例，当从机设备尚未准备好结束这次操作（从机设备未就绪，且数据尚未发送完）时，可以通过锁存数据并插入等待周期，或者发起Retry操作。PCI-X总线采用了一种叫做Split Transaction的方式来处理这种情况，如下图所示。此时，发起读操作的总线主机被称为Requester，而接受并向总线上发送数据的从机设备被称为Completer。</p>
<p>注：PCIe Spec中继承了PCI-X的这种命名方式。</p>
<p><img src="https://s1.ax1x.com/2020/03/28/GkeIMV.png" alt="GkeIMV.png"></p>
<p>采用这种方式的PCI-X总线的总线传输利用率（效率）可以达到85%，而标准的PCI总线只有50%-60%。关于Split Transaction的详细内容，建议大家去参考PCI-X的Spec，这里不再详细地介绍。此外，PCI-X总线还在配置地址寄存器（Configuration Address Register）中加入了NS（No Snoop）和RO（Relaxed Ordering）两位以提高总线传输效率。</p>
<p>前面的文章中介绍过，PCI总线的中断操作是通过一系列的边带信号（Sideband Signals）来完成的，在PCI-X Spce中引入了消息信号中断（MSI，Message Signaled Interrupts）的机制，以取代这些边带信号，进而精简系统设计。</p>
<h4 id="二、PCIe简介"><a href="#二、PCIe简介" class="headerlink" title="二、PCIe简介"></a>二、PCIe简介</h4><p>PCI-Express是继ISA和PCI总线之后的第三代I/O总线，即3GIO。 由Intel在2001年的IDF上提出，由PCI-SIG（PCI特殊兴趣组织）认证发布后才改名为“PCI-Express”。它的主要优势就是数据传输速率高，另外还有抗干扰能力强，传输距离远，功耗低等优点。 </p>
<p>注：第一代总线一般指ISA、EISA、VESA和Micro Platforms。第二代总线一般指PCI、AGP和PCI-X。</p>
<p><img src="https://s1.ax1x.com/2020/03/28/GknVk4.png" alt="GknVk4.png"></p>
<p>图中的PCI-E的传输速率指的是实际的有效传输速率，为RAW Data速率的80%，因为PCI-E（Gen1&amp;Gen2，Gen3中使用了新的方式，即128b/130b）中使用了8b/10b编解码技术。</p>
<p>PCI-Express总线的Spec中明确规定了PCI-Express的缩写为PCIe，但很多情况下，大家为了方便常把它缩写为PCI-E。</p>
<p>PCI-E接口根据总线位宽不同而有所差异，一个PCI Express连接可以被配置成x1， x2， x4， x8， x12， x16和x32的数据带宽。 (x2 and x12 link widths are optional) PCI-E各种位宽Device可以自由搭配使用，比如x1 的卡可以插到x8的插槽中使用， x8的卡可以插到x16的插槽中使用，升级方便。 </p>
<p><img src="https://s1.ax1x.com/2020/03/28/GknA7F.png" alt="GknA7F.png"></p>
<p>一些常见的PCI-E设备如下图所示：</p>
<p><img src="https://s1.ax1x.com/2020/03/28/Gknk0U.png" alt="Gknk0U.png"></p>
]]></content>
      <categories>
        <category>UEFI</category>
      </categories>
      <tags>
        <tag>UEFI</tag>
      </tags>
  </entry>
  <entry>
    <title>UEFI 详解</title>
    <url>/2020/06/22/UEFI-%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/UEFI-%E8%AF%A6%E8%A7%A3/静默山水.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">静默山水</div>
</center>

<h4 id="一、UEFI-是什么？"><a href="#一、UEFI-是什么？" class="headerlink" title="一、UEFI 是什么？"></a>一、UEFI 是什么？</h4><p>UEFI - Unified Extensible Firmware Interface<br>从规范的角度来看，它是一个规范，定义了计算机操作系统和平台固件之间的接口规范.</p>
<a id="more"></a>

<p>从实体的角度来讲，BIOS 和 UEFI 是两种不同类型的计算机固件（什么是固件？就是固化在计算机主板上某个非易失存储区（EEPROM）中的小系统），计算机启动都是先启动它，然后加载真正的操作系统，计算机启动后进入配置界面，我们能直观看到的是 UEFI 固件的 UI，我们通过 UI 来配置这个固件的可配置项，比如：操作系统启动顺序，启动等待时间等等，在 BIOS 时代，所有的设置都只能存储在主板上，容量很小，无法扩展，而 UEFI 将基础固件烧制在主板存储区中，然后在磁盘上创建 EFI 系统分区来存储更多的内容和数据，通过 UEFI 规范来定义如何使用扩展的方式来定制和扩展功能。</p>
<h4 id="二、EFI-系统分区"><a href="#二、EFI-系统分区" class="headerlink" title="二、EFI 系统分区"></a>二、EFI 系统分区</h4><p>我们知道在 UEFI 之前的 BIOS 时代，操作系统的 bootlloader 是存放在主引导记录（MBR）中的，容量受限，所以 UEFI 中引入了一个新的系统分区 ESP (EFI System Partition) ，该分区用来存储操作系统的 bootloader 和 EFI 驱动程序等数据，当计算机启动后，UEFI 固件从该分区中加载所需要的硬件驱动，执行 bootloader 启动指定的操作系统。在 Windows 系统中默认该分区不可见，可以参照 如何查看 EFI 分区内容 查看 EFI 分区中的内容。</p>
<h4 id="三、EFI-可执行文件"><a href="#三、EFI-可执行文件" class="headerlink" title="三、EFI 可执行文件"></a>三、EFI 可执行文件</h4><p>UEFI 标准定义了一种可执行文件格式，所有的 UEFI 固件都能够执行以这种格式编写的代码，操作系统 bootloader 都采用这种格式编写，比如 Windows 10 64位操作系统的 bootloader 叫做 bootx64.efi，该文件存放在 EFI 系统分区的 Boot 文件夹下，如果一台机器上安装了多个厂商的操作系统，他们的 bootloader 都位于 EFI 系统分区的 Boot 目录中，UEFI 就是通过执行这个 bootloader 来启动指定的操作系统。</p>
<p><img src="https://s1.ax1x.com/2020/03/28/GkAytI.png" alt="GkAytI.png"></p>
<h4 id="四、GPT-分区表"><a href="#四、GPT-分区表" class="headerlink" title="四、GPT 分区表"></a>四、GPT 分区表</h4><p>GUID 分区表格式与 UEFI规范具有密切联系，而且它并不特别复杂，GPT 是 UEFI 规范提供的良好基础架构之一。GPT 仅仅是分区表的一种标准（磁盘起始位置的信息定义了磁盘所包含的分区）。相比 MBR/MS-DOS 分区表，这种分区表对分区的定义要好得多，并且 UEFI 规范要求 UEFI 兼容固件必须能识别 GPT（也要求固件能识别 MBR，以保证向后兼容）。</p>
<h4 id="五、BIOS-如何启动"><a href="#五、BIOS-如何启动" class="headerlink" title="五、BIOS 如何启动"></a>五、BIOS 如何启动</h4><p>在了解 UEFI 启动之前，我们看一下 BIOS 的启动过程，BIOS 启动过程非常简单，你需要在第一块磁盘上有一个 MBR（主引导记录，这是一个标准，它定义了一种格式来描述该磁盘分区，并在特定的地方包含一个 boot loader），BIOS 通过加载 MBR 中的这段 boot loader 代码去启动操作系统，操作系统安装程序负责在系统安装过程中将 boot loader 代码写入到 MBR 中的特定区域。</p>
<p><a href="https://imgchr.com/i/GkEzM8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/28/GkEzM8.png" alt="GkEzM8.png"></a></p>
<p>从 BIOS 的启动过程中我们可以看出，BIOS 方案存在以下问题：</p>
<ul>
<li>处理不便，你需要特殊工具来写入 MBR，如果要查看 MBR 中包含的内容，唯一的方法几乎就是把 MBR dump 出来，然后进行检查</li>
<li>MBR 容量受限，无法容纳现代操作系统的 bootloader</li>
<li>无法实现从其他启动目标来启动系统，比如：网络启动</li>
<li>固件层以上的其他层（比如在操作系统中）无法配置固件的启动行为，BIOS 没有提供相应机制</li>
</ul>
<h4 id="六、UEFI-如何启动"><a href="#六、UEFI-如何启动" class="headerlink" title="六、UEFI 如何启动"></a>六、UEFI 如何启动</h4><p>UEFI 规范定义了一个 boot manager, 它是一个固件策略引擎，可以灵活配置，通过下图的对比图可以看到 UEFI 的启动过程。整个流程没有什么神奇的地方，主要的优势是灵活性和可配置型以及可定制的安全性。</p>
<p><img src="https://s1.ax1x.com/2020/03/28/GkViIs.png" alt="GkViIs.png"></p>
<h4 id="七、Secure-Boot"><a href="#七、Secure-Boot" class="headerlink" title="七、Secure Boot"></a>七、Secure Boot</h4><p>安全启动解决的问题就是 rootkit 攻击问题。<br>UEFI 规范规定了固件可以包含一系列签名，并拒绝运行未签名或签名与固件中包含的签名不一致的 EFI 可执行文件，通俗地讲，安全启动就是使用非对称加密和数字签名技术来确保整个启动链的安全，所有不合法的 UEFI 执行程序和驱动程序都不允许执行，这样就解决了操作系统加载前的启动安全问题。当然这是一个可选项，用户可以在 UEFI 配置界面关闭 Secure Boot。</p>
<h4 id="八、为什么需要BIOS和UEFI？"><a href="#八、为什么需要BIOS和UEFI？" class="headerlink" title="八、为什么需要BIOS和UEFI？"></a>八、为什么需要BIOS和UEFI？</h4><p>与大多数人基本的概念不同，在某种意义上来说，X86体系比ARM体系更加开放。X86是很多小伙伴一起玩，以生态圈的概念提供产品，并对自己那部分负责；而ARM体系虽然也依赖生态圈，但最终有个大Boss统合整个生态链，提供最后产品并对该产品负总责。</p>
<p>X86生态圈玩家众多，有OS 厂商（OSV）定期发布操作系统，如Windows，Ubuntu；芯片厂商提供CPU，如Intel, AMD；主板厂商（OEM）提供电脑主板；独立硬件供应商（IHV）生产扩展板卡如显卡等等PCIE扩展卡，再如内存厂家推出一代一代不同的内存条等等。</p>
<p>DIY玩家可以自由选择搭配合适/兼容的产品搭配出自己心仪的机器，休闲上网用户花2000多元就可以搭配出一套可用的电脑，而游戏玩家则可能花费上万元才能满足游戏配置需求。还有些品牌机厂商如Dell和联想等，他们提供整套最终产品给用户。但他们实际上是在所有小伙伴的零件基础上拼凑出个产品，技术不强，话语权弱，并不能统一整个产业链。用户津津乐道的反而是用的什么CPU，安装的什么操作系统，用的那种显卡等等。Windows死机、蓝屏和缓慢等等时候，用户往往会抱怨微软和Intel，而不是品牌厂商。</p>
<p>ARM体系由最后品牌厂商统合整个产品，它负责打通整个产业链，并对其中所有部分负责，话语权极强，同时对技术也相对较强。用户面对的具体品牌的产品，而不是碎片化的各个部分。强势的如Apple，硬件软件一起抓，完全组成闭环的链条。稍差也如华为等安卓手机，要负责安卓系统在自己手机移植部分（BSP），客户出了问题并不会找谷歌，而会去找华为。</p>
<p>在X86生态圈十分强势的微软，自己负责操作系统开发，跳过品牌直接服务最终用户，甚至不经允许直接升级操作系统，闹出不少风波。强势也带来了副作用，它要直接面对数千数万种千奇百怪的硬件产品，如何才能用一个软件安装包服务于这么多种设备呢？必须要一个软件抽象层封装这些硬件差别！</p>
<p>这就引出了BIOS和UEFI的最主要的功能：初始化硬件和提供硬件的软件抽象。</p>
<p>ARM体系也要初始化具体主板相关硬件如GPIO和内存等，这些一般在BSP中完成。与X86体系不同之处在于这些硬件完全定制化，初始化的时候就预先知道有哪些设备，Solder Down了哪个品牌的哪种内存颗粒，到时候就照方抓药，初始化一大堆寄存器而已。X86系统配置情况在开机时候是不知道的，需要探测（Probe）、Training(内存和PCIe)和枚举（PCIe等等即插即用设备），相对较复杂。<br>BIOS和UEFI提供了整个主板、包括主板上外插的设备的软件抽象。通过探测、Training和枚举，BIOS就有了系统所有硬件的信息。它通过几组详细定义好的接口，把这些信息抽象后传递给操作系统，这些信息包括SMBIOS（专栏稍后介绍）、ACPI表（ACPI与UEFI），内存映射表（E820或者UEFI运行时）等等。通过这层映射，才能做到做到操作系统完全不改而能够适配到所有机型和硬件。<br>在某种程度上来讲，BIOS和UEFI是将操作系统BSP部分单独封装后下放到主板或者BIOS提供商来完成。这在过去带来了巨大的好处，WinXP、Win7现在还可以运行在更新的电脑硬件上，新的硬件只要自己更改一下就行了，兼容性是ARM体系所不能比拟的。当然割裂的生态圈也带来了用户感受的千差万别，这也受到广泛诟病。各自为政也窒息了创新，带来了同质化。为此，Intel越俎代庖，提出了变形本等等概念；而微软更直接出了Surface，似乎要与过去的小伙伴争食。其实这些都是不得已而为之，今后的发展还需要拭目以待。</p>
<p>arm社区最近为了进入x86的传统优势领域，也开始接受uefi，不过一般只在服务器领域。个别厂商为了支持Windows而在平板等设备支持uefi，某厂商在手机上也要引入uefi。不过这些只是支流，并且他们并不吧自己叫做BIOS，而叫做Bootloader。</p>
]]></content>
      <categories>
        <category>UEFI</category>
      </categories>
      <tags>
        <tag>UEFI</tag>
      </tags>
  </entry>
  <entry>
    <title>华为性格测试</title>
    <url>/2020/06/22/%E5%8D%8E%E4%B8%BA%E6%80%A7%E6%A0%BC%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/%E5%8D%8E%E4%B8%BA%E6%80%A7%E6%A0%BC%E6%B5%8B%E8%AF%95/p21383.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">钢铁侠</div>
</center>

<blockquote>
<p>华为的性格测试还是比较坑的，建议面试者在做之前看看攻略，自己就挂过一次，需要注意前后一致，还有不要想着领导别人，螺丝钉性格比较合适</p>
</blockquote>
<a id="more"></a>

<h4 id="1-最合适的性格"><a href="#1-最合适的性格" class="headerlink" title="1 最合适的性格"></a>1 最合适的性格</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我信守自己做出的承诺</span><br><span class="line"></span><br><span class="line">我觉得人们信守承诺相当重要</span><br><span class="line"></span><br><span class="line">我坚持按时完成任务</span><br><span class="line"></span><br><span class="line">我做事广泛听取别人的意见</span><br><span class="line"></span><br><span class="line">做事前我会征询大家的意见</span><br><span class="line"></span><br><span class="line">我愿意花时间去帮助别人</span><br><span class="line"></span><br><span class="line">我做事不喜欢半途而废</span><br><span class="line"></span><br><span class="line">我必须了解底层原理才能更有效的学习</span><br><span class="line"></span><br><span class="line">我倾向于根据客观事实做决定</span><br><span class="line"></span><br><span class="line">我必须找到解决问题的办法</span><br><span class="line"></span><br><span class="line">我需要了解论点背后的逻辑</span><br><span class="line"></span><br><span class="line">我喜欢创新</span><br><span class="line"></span><br><span class="line">做事时我喜欢有新方法、新点子</span><br><span class="line"></span><br><span class="line">我能想出很多主意</span><br><span class="line"></span><br><span class="line">我喜欢提出很多主意</span><br><span class="line"></span><br><span class="line">我喜欢提出独到的见解</span><br><span class="line"></span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>

<h4 id="2-适中的性格"><a href="#2-适中的性格" class="headerlink" title="2 适中的性格"></a>2 适中的性格</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我善于和别人建立融洽关系</span><br><span class="line"></span><br><span class="line">我喜欢有压力的环境下工作</span><br><span class="line"></span><br><span class="line">我喜欢忙碌的生活</span><br><span class="line"></span><br><span class="line">我需要有明确的远景计划</span><br><span class="line"></span><br><span class="line">我喜欢思考未来</span><br><span class="line"></span><br><span class="line">我给自己设定了长远目标</span><br><span class="line"></span><br><span class="line">我经常展望未来</span><br><span class="line"></span><br><span class="line">我对未来比较乐观</span><br><span class="line"></span><br><span class="line">我相信未来的事情会是好的</span><br><span class="line"></span><br><span class="line">我做事很有远见</span><br><span class="line"></span><br><span class="line">做事的时候我需要有章可循</span><br><span class="line"></span><br><span class="line">我做事井井有条</span><br><span class="line"></span><br><span class="line">我非常注重细节</span><br><span class="line"></span><br><span class="line">我善于同时处理多项任务</span><br><span class="line"></span><br><span class="line">我循规蹈矩地去做事情</span><br><span class="line"></span><br><span class="line">我喜欢对数据进行统计与分析</span><br><span class="line"></span><br><span class="line">我喜欢讨论抽象性的问题</span><br><span class="line"></span><br><span class="line">我善于处理数字资料</span><br><span class="line"></span><br><span class="line">我不容易被别人激怒</span><br><span class="line"></span><br><span class="line">不信任他人</span><br><span class="line"></span><br><span class="line">我在陌生朋友交流时会轻松自在</span><br><span class="line"></span><br><span class="line">我大部分时间是快乐的</span><br><span class="line"></span><br><span class="line">我有强烈的好奇心</span><br><span class="line"></span><br><span class="line">我喜欢有竞争的工作</span><br><span class="line"></span><br><span class="line">我是一个竞争心很强的人</span><br></pre></td></tr></table></figure>

<h4 id="3-不适合的性格"><a href="#3-不适合的性格" class="headerlink" title="3 不适合的性格"></a>3 不适合的性格</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我掌控着自己的未来</span><br><span class="line"></span><br><span class="line">我在重大事情发生前会紧张</span><br><span class="line"></span><br><span class="line">我想有人陪在我身边</span><br><span class="line"></span><br><span class="line">我坚持自己的做事方式</span><br><span class="line"></span><br><span class="line">我善于结交朋友</span><br><span class="line"></span><br><span class="line">我喜欢结识陌生人</span><br><span class="line"></span><br><span class="line">我善于谈判</span><br><span class="line"></span><br><span class="line">我善于推销</span><br><span class="line"></span><br><span class="line">我是个很健谈的人</span><br><span class="line"></span><br><span class="line">我关注别人的做事目的与做事动机</span><br><span class="line"></span><br><span class="line">我善于理解人们背后的的动机</span><br><span class="line"></span><br><span class="line">我善于体会他人的感受</span><br><span class="line"></span><br><span class="line">我要超越别人</span><br><span class="line"></span><br><span class="line">我有较大的野心</span><br><span class="line"></span><br><span class="line">我想成为团队中的领导</span><br><span class="line"></span><br><span class="line">我更愿意领导别人</span><br><span class="line"></span><br><span class="line">我喜欢挑战别人的想法</span><br><span class="line"></span><br><span class="line">我享受独自工作</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>性格测试</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓面试笔记</title>
    <url>/2020/06/22/%E5%AE%89%E5%8D%93%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/%E5%AE%89%E5%8D%93%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/438yjy.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">林间小格</div>
</center>

<blockquote>
<p>本科面试笔记</p>
</blockquote>
<a id="more"></a>
<h3 id="一、四大组件问题"><a href="#一、四大组件问题" class="headerlink" title="一、四大组件问题"></a>一、四大组件问题</h3><h4 id="1-四大组件是什么"><a href="#1-四大组件是什么" class="headerlink" title="1.四大组件是什么"></a>1.四大组件是什么</h4><p>1）Activity：用户可操作的可视化界面，为用户提供一个完成操作指令的窗口。一个 Activity 通常是一个单独的屏幕，Activity 通过 Intent 来进行通信。Android 中会维持一个 Activity Stack， 当一个新 Activity 创建时，它就会放到栈顶，这个 Activity 就处于运行状态。 </p>
<p>2）Service：服务，运行在手机后台，适合执行不需和用户交互且还需长期运行的任务。 </p>
<p>3）ContentProvider：内容提供者，使一个应用程序的指定数据集提供给其他应用程序，其 他应用可通过 ContentResolver 类从该内容提供者中获取或存入数据。它提供了一种跨进程 数据共享的方式，当数据被修改后，ContentResolver 接口的 notifyChange 函数通知那些注册 监控特定 URI 的 ContentObserver 对象。</p>
<p>4）Broadcast Receiver: 广播接收者，运用在应用程序间传输信息，可以使用广播接收器来让 应用对一个外部事件做出响应。</p>
<h4 id="2-Activity生命周期和简单用法"><a href="#2-Activity生命周期和简单用法" class="headerlink" title="2.Activity生命周期和简单用法"></a>2.Activity生命周期和简单用法</h4><p>Activity：onCreate()-&gt;onStart()-&gt;onResume()-&gt;onPause()-&gt;onStop()-&gt;onDestory() </p>
<p>onCreate()：为 Activity 设置布局，此时界面还不可见；</p>
<p>onStart(): Activity 可见但还不能与用户交互，不能获得焦点 </p>
<p>onRestart(): 重新启动 Activity 时被回调 </p>
<p>onResume(): Activity 可见且可与用户进行交互 </p>
<p>onPause(): 当前 Activity 暂停，不可与用户交互，但还可见。在新 Activity 启动前被系统调用 保存现有的 Activity 中的持久数据、停止动画等。 </p>
<p>onStop(): 当 Activity 被新的 Activity 覆盖不可见时被系统调用 onDestory(): 当 Activity 被系统销毁杀掉或是由于内存不足时调用</p>
<p>onDestory(): 当 Activity 被系统销毁杀掉或是由于内存不足时调用</p>
<h4 id="3-Service生命周期和简单用法"><a href="#3-Service生命周期和简单用法" class="headerlink" title="3.Service生命周期和简单用法"></a>3.Service生命周期和简单用法</h4><p>a) onBind 方式绑定的：onCreate-&gt;onBind-&gt;onUnBind-&gt;onDestory（不管调用 bindService 几次，<br>onCreate 只会调用一次，onStart 不会被调用，建立连接后，service 会一直运行，直到调用 unBindService 或是之前调用的 bindService 的 Context 不存在了，系统会自动停止 Service,对 应的 onDestory 会被调用） </p>
<p>b) startService 启动的：onCreate-&gt;onStartCommand-&gt;onDestory(start 多次，onCreate 只会被 调用一次，onStart会调用多次，该 service 会在后台运行，直至被调用stopService 或是stopSelf) </p>
<p>c) 又被启动又被绑定的服务，不管如何调用 onCreate()只被调用一次，startService 调用多少 次，onStart 就会被调用多少次，而 unbindService 不会停止服务，必须调用 stopService 或是 stopSelf 来停止服务。必须 unbindService 和 stopService(stopSelf）同时都调用了才会停止服 务。</p>
<h4 id="4-BroadcastReceiver-生命周期和简单用法"><a href="#4-BroadcastReceiver-生命周期和简单用法" class="headerlink" title="4.BroadcastReceiver 生命周期和简单用法"></a>4.BroadcastReceiver 生命周期和简单用法</h4><p>a) 动态注册：存活周期是在 Context.registerReceiver 和 Context.unregisterReceiver 之间， BroadcastReceiver 每次收到广播都是使用注册传入的对象处理的。 </p>
<p>b) 静态注册：进程在的情况下，receiver 会正常收到广播，调用 onReceive 方法；生命周期 只存活在 onReceive 函数中，此方法结束，BroadcastReceiver 就销毁了。onReceive()只有十 几秒存活时间，在 onReceive()内操作超过 10S，就会报 ANR。 </p>
<hr>
<p>动态注册广播与静态注册广播的区别</p>
<p>（1）动态注册广播不是常驻型广播，也就是说广播跟随Activity的生命周期。注意在Activity结束前，移除广播接收器。</p>
<p>静态注册是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</p>
<p>（2）当广播为有序广播时：优先级高的先接收（不分静态和动态）。同优先级的广播接收器，动态优先于静态</p>
<p>（3）同优先级的同类广播接收器，静态：先扫描的优先于后扫描的，动态：先注册的优先于后注册的。</p>
<p>（4）当广播为默认广播时：无视优先级，动态广播接收器优先于静态广播接收器。同优先级的同类广播接收器，静态：先扫描的优先于后扫描的，动态：先注册的优先于后册的。</p>
<h4 id="5-ContentProvider-生命周期和简单用法"><a href="#5-ContentProvider-生命周期和简单用法" class="headerlink" title="5.ContentProvider 生命周期和简单用法"></a>5.ContentProvider 生命周期和简单用法</h4><p>ContentProvider：应该和应用的生命周期一样，它属于系统应用，应用启动时，它会跟着初始化，应用关闭或被杀，它会跟着结束。</p>
<h4 id="6-Activity-之间的通信方式"><a href="#6-Activity-之间的通信方式" class="headerlink" title="6.Activity 之间的通信方式"></a>6.Activity 之间的通信方式</h4><p>1）通过 Intent 方式传递参数跳转 </p>
<p>2）通过广播方式 </p>
<p>3）通过接口回调方式 </p>
<p>4）借助类的静态变量或全局变量 </p>
<p>5）借助 SharedPreference或是外部存储，如数据库或本地文件</p>
<h4 id="7-Activity-各种情况下的生命周期"><a href="#7-Activity-各种情况下的生命周期" class="headerlink" title="7.Activity 各种情况下的生命周期"></a>7.Activity 各种情况下的生命周期</h4><ol>
<li>两 个 Activity(A-&gt;B) 切 换 (B 正 常 的 Activity) 的 生 命 周 期 ： onPause(A)-&gt;onCreate(B)-&gt;onStart(B)-&gt;onResume(B)-&gt;oStop(A) 这时如果按回退键回退到 A onPause(B)-&gt;onRestart(A)-&gt;onStart(A)-&gt;onResume(A)-&gt;oStop(B)<br>如果在切换到 B 后调用了 A.finish()，则会走到 onDestory(A)，这时点回退键会退出应用 </li>
</ol>
<p>2) 两个 Activity(A-&gt;B)切换(B 透明主题的 Activity 或是 Dialog 风格的 Acivity)的生命周期： onPause(A)-&gt;onCreate(B)-&gt;onStart(B)-&gt;onResume(B) 这时如果回退到 A onPause(B)-&gt;onResume(A)-&gt;oStop(B)-&gt;onDestory(B) </p>
<p>3) Activity(A) 启 动 后 点 击 Home 键 再 回 到 应 用 的 生 命 周 期 ： onPause(A)-&gt;oStop(A)-&gt;onRestart(A)-&gt;onStart(A)-&gt;onResume(A)</p>
<p>4) Activity 上有 Dialog 的时候, Dialog 并不会影响 Activity 的生命周期</p>
<h4 id="8-横竖屏切换的时候，Activity-各种情况下的生命周期"><a href="#8-横竖屏切换的时候，Activity-各种情况下的生命周期" class="headerlink" title="8.横竖屏切换的时候，Activity 各种情况下的生命周期"></a>8.横竖屏切换的时候，Activity 各种情况下的生命周期</h4><ol>
<li>切换横屏时 ： onSaveInstanceState-&gt;onPause-&gt;onStop-&gt;onDestory-&gt;onCreate-&gt;onStart-&gt;onRestoreInstanceSta te-&gt;onResume </li>
</ol>
<p>2) 切换竖屏时：会打印两次相同的log onSaveInstanceState-&gt;onPause-&gt;onStop-&gt;onDestory-&gt;onCreate-&gt;onStart-&gt;onRestoreInstanceSta te-&gt;onResume-&gt;onSaveInstanceState-&gt;onPause-&gt;onStop-&gt;onDestory-&gt;onCreate-&gt;onStart-&gt;onRe storeInstanceState-&gt;onResume </p>
<p>3) 如 果 在 AndroidMainfest.xml 中 修 改 该 Activity 的 属 性 ， 添 加 android:configChanges=”orientation” 横竖屏切换，打印的 log 一样，同 1) </p>
<h4 id="9-Fragment-生命周期"><a href="#9-Fragment-生命周期" class="headerlink" title="9.Fragment 生命周期"></a>9.Fragment 生命周期</h4><ul>
<li>Fragment 生命周期 :onAttach-&gt;onCreate-&gt;onCreateView-&gt;onActivityCreated-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestoryView-&gt;onDestory-&gt;onDetach </li>
<li>切换到该Fragment ： onAttach-&gt;onCreate-&gt;onCreateView-&gt;onActivityCreated-&gt;onStart-&gt;onResume </li>
<li>按下Power键：onPause-&gt;onSaveInstanceState-&gt;onStop </li>
<li>点亮屏幕解锁：onStart-&gt;onRestoreInstanceState-&gt;onResume </li>
<li>切换到其他 Fragment:onPause-&gt;onStop-&gt;onDestoryView</li>
<li>切回到该Fragment: onCreateView-&gt;onActivityCreated-&gt;onStart-&gt;onResume </li>
<li>退出应用：onPause-&gt;onStop-&gt;onDestoryView-&gt;onDestory-&gt;onDetach</li>
</ul>
<hr>
<p>Fragment与Activity生命周期关系</p>
<p><img src="https://s1.ax1x.com/2020/03/26/GpCAh9.png" alt="GpCAh9.png"></p>
<h4 id="10-Activity-的四种启动模式对比"><a href="#10-Activity-的四种启动模式对比" class="headerlink" title="10.Activity 的四种启动模式对比"></a>10.Activity 的四种启动模式对比</h4><ol>
<li>standard：标准启动模式（默认），每启动一次 Activity，都会创建一个实例，即使从 ActivityA startActivity ActivityA,也会再次创建 A 的实例放于栈顶，当回退时，回到上一个 ActivityA 的 实例。<br>2) singleTop：栈顶复用模式，每次启动 Activity，如果待启动的 Activity 位于栈顶，则不会重 新 创 建 Activity 的 实 例 ， 即 不 会 走 onCreate-&gt;onStart ， 会 直 接 进 入 Activity 的 onPause-&gt;onNewIntent-&gt;onResume 方法<br>3) singleInstance: 单一实例模式，整个手机操作系统里只有一个该 Activity 实例存在，没有 其 他 Actvity,后 续 请 求 均 不 会 创 建 新 的 Activity 。 若 task 中 存 在 实 例 ， 执 行 实 例 的 onNewIntent()。应用场景：闹钟、浏览器、电话<br>4) singleTask：栈内复用，启动的 Activity 如果在指定的 taskAffinity 的 task 栈中存在相应的实 例，则会把它上面的 Activity 都出栈，直到当前 Activity 实例位于栈顶，执行相应的 onNewIntent()方法。如果指定的 task 不存在，创建指定的 taskAffinity 的 task,taskAffinity 的 作用，进入指写 taskAffinity 的 task,如果指定的 task 存在，将 task 移到前台，如果指定的 task 不存在，创建指定的 taskAffinity 的 task. 应用场景：应用的主页面</li>
</ol>
<h4 id="11-说说-ContentProvider、ContentResolver、ContentObserver-之间的关系"><a href="#11-说说-ContentProvider、ContentResolver、ContentObserver-之间的关系" class="headerlink" title="11.说说 ContentProvider、ContentResolver、ContentObserver 之间的关系"></a>11.说说 ContentProvider、ContentResolver、ContentObserver 之间的关系</h4><p>ContentProvider实现各个应用程序间数据共享，用来提供内容给别的应用操作。如联系人应用中就使用了ContentProvider，可以在自己应用中读取和修改联系人信息，不过需要获取相应的权限。它也只是一个中间件，真正的数据源是文件或SQLite等。</p>
<p>ContentResolver内容解析者 ， 用于获取内容提供者提供的数据 ，通过ContentResolver.notifyChange(uri)发出消息 </p>
<p>ContentObserver内容监听者，可以监听数据的改变状态，观察特定 Uri 引起的数据库变化， 继而做一些相应的处理，类似于数据库中的触发器，当 ContentObserver 所观察的 Uri 发生 变化时，便会触发它。</p>
<h4 id="12-下广播-BroadcastReceiver-的理解"><a href="#12-下广播-BroadcastReceiver-的理解" class="headerlink" title="12.下广播 BroadcastReceiver 的理解"></a>12.下广播 BroadcastReceiver 的理解</h4><ul>
<li><p>BroadcastReceiver 是一种全局监听器，用来实现系统中不同组件之间的通信。</p>
</li>
<li><p>有时候也会用 来作为传输少量而且发送频率低的数据，但是如果数据的发送频率比较高或者数量比较大就 不建议用广播接收者来接收了，因为这样的效率很不好，因为 BroadcastReceiver 接收数据的 开销还是比较大的。</p>
</li>
</ul>
<h4 id="13-如何实现-Fragment-的滑动？"><a href="#13-如何实现-Fragment-的滑动？" class="headerlink" title="13.如何实现 Fragment 的滑动？"></a>13.如何实现 Fragment 的滑动？</h4><p>ViewPager+FragmentPagerAdapter+List<Fragment></Fragment></p>
<h4 id="14-fragment-之间传递数据的方式？"><a href="#14-fragment-之间传递数据的方式？" class="headerlink" title="14.fragment 之间传递数据的方式？"></a>14.fragment 之间传递数据的方式？</h4><p>1) 在相应的 fragment 中编写方法，在需要回调的 fragment 里获取对应的 Fragment 实例，调 用相应的方法； </p>
<ol start="2">
<li>采用接口回调的方式进行数据传递； </li>
</ol>
<ul>
<li>a) 在 Fragment1中创建一个接口及接口对应的set 方法; </li>
<li>b) 在Fragment1 中调用接口的方法； </li>
<li>c)在 Fragment2 中实现该接口； </li>
</ul>
<p>3）利用第三方开源框架 EventBus</p>
<h4 id="15-service-和-activity-怎么进行数据交互？"><a href="#15-service-和-activity-怎么进行数据交互？" class="headerlink" title="15.service 和 activity 怎么进行数据交互？"></a>15.service 和 activity 怎么进行数据交互？</h4><p>1）通过 bindService 启动服务，可以在 ServiceConnection 的 onServiceConnected 中获取到 Service 的实例，这样就可以调用 service 的方法，如果 service 想调用 activity 的方法，可以 在 service 中定义接口类及相应的 set 方法，在activity中实现相应的接口，这样 service 就可 以回调接口言法； </p>
<p>2）通过广播方式</p>
<h4 id="16-在-manifest-和代码中如何注册和使用-BroadcastReceiver"><a href="#16-在-manifest-和代码中如何注册和使用-BroadcastReceiver" class="headerlink" title="16.在 manifest 和代码中如何注册和使用 BroadcastReceiver?"></a>16.在 manifest 和代码中如何注册和使用 BroadcastReceiver?</h4><p>1）mainfest 中注册:静态注册的广播接收者就是一个常驻在系统中的全局监听器，也就是说 如果你应用中配置了一个静态的 BroadcastReceiver，而且你安装了应用而无论应用是否处于 运行状态，广播接收者都是已经常驻在系统中了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;receiver android:name&#x3D;&quot;.MyBroadcastReceiver&quot;&gt; </span><br><span class="line">    &lt;intent-filter&gt; </span><br><span class="line">        &lt;action android:name&#x3D;&quot;com.smilexie.test.intent.mybroadcastreceiver&quot;&#x2F;&gt; </span><br><span class="line">    &lt;&#x2F;intent-filter&gt; </span><br><span class="line">&lt;&#x2F;receiver&gt;</span><br></pre></td></tr></table></figure>
<p>2) 动态注册:动态注册的广播接收者只有执行了 registerReceiver(receiver, filter)才会开始监听 广播消息，并对广播消息作为相应的处理。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IntentFilter fiter &#x3D; new IntentFilter(&quot;com.smilexie.test.intent.mybroadcastreceiver&quot;); </span><br><span class="line">MyBroadcastReceiver receiver &#x3D; new MyBroadcastReceiver(); </span><br><span class="line">registerReceiver(receiver, filter);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;撤销广播接受者的动态注册 unregisterReceiver(receiver);</span><br></pre></td></tr></table></figure>

<h4 id="17-AlertDialog-popupWindow区别"><a href="#17-AlertDialog-popupWindow区别" class="headerlink" title="17.AlertDialog,popupWindow区别"></a>17.AlertDialog,popupWindow区别</h4><p>（1）Popupwindow 在显示之前一定要设置宽高，Dialog 无此限制。 </p>
<p>（2）Popupwindow 默认不会响应物理键盘的 back，除非显示设置了 popup.setFocusable(true); 而在点击 back 的时候，Dialog 会消失。</p>
<p>（3）Popupwindow 不会给页面其他的部分添加蒙层，而Dialog 会。  </p>
<p>（4） Popupwindow 没有标题 ， Dialog 默认有标 题 ， 可以通过 dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);取消标题 </p>
<p>（5）二者显示的时候都要设置 Gravity。如果不设置，Dialog 默认是 Gravity.CENTER。</p>
<h4 id="18-HttpClient-与-HttpUrlConnection-的区别"><a href="#18-HttpClient-与-HttpUrlConnection-的区别" class="headerlink" title="18.HttpClient 与 HttpUrlConnection 的区别"></a>18.HttpClient 与 HttpUrlConnection 的区别</h4><ul>
<li><p>首先 HttpClient 和 HttpUrlConnection 这两种方式都支持 Https 协议，都是以流的形式进行上<br>传或者下载数据，也可以说是以流的形式进行数据的传输，还有 ipv6,以及连接池等功能。 </p>
</li>
<li><p>HttpClient 这个拥有非常多的 API，所以如果想要进行扩展的话，并且不破坏它的兼容性的话， 很难进行扩展，也就是这个原因，Google 在 Android6.0 的时候，直接就弃用了这个 HttpClient. </p>
</li>
<li><p>而HttpUrlConnection 相对来说就是比较轻量级了，API 比较少，容易扩展，并且能够满足 Android 大部分的数据传输。比较经典的一个框架 volley，在 2.3 版本以前都是使用 HttpClient, 在 2.3 以后就使用了 HttpUrlConnection。</p>
</li>
</ul>
<h4 id="19-java-虚拟机和-Dalvik-虚拟机的区别"><a href="#19-java-虚拟机和-Dalvik-虚拟机的区别" class="headerlink" title="19.java 虚拟机和 Dalvik 虚拟机的区别"></a>19.java 虚拟机和 Dalvik 虚拟机的区别</h4><p>Java 虚拟机： </p>
<ul>
<li><p>1、java 虚拟机基于栈。 基于栈的机器必须使用指令来载入和操作栈上数据，所需指令更多。</p>
</li>
<li><p>2、java 虚拟机运行的是 java 字节码。（java 类会被编译成一个或多个字节码.class 文件） </p>
</li>
</ul>
<p>Dalvik 虚拟机： </p>
<ul>
<li><p>1、dalvik 虚拟机是基于寄存器的 </p>
</li>
<li><p>2、Dalvik 运行的是自定义的.dex 字节码格式。（java 类被编译成.class 文件后，会通过一个 dx 工具将所有的.class 文件转换成一个.dex 文件，然后 dalvik 虚拟机会从其中读取指令和数 据</p>
</li>
<li><p>3、常量池已被修改为只使用 32 位的索引，以 简化解释器。</p>
</li>
<li><p>4、一个应用，一个虚拟机实例，一个进程（所有 android 应用的线程都是对应一个 linux 线 程，都运行在自己的沙盒中，不同的应用在不同的进程中运行。每个 android dalvik 应用程 序都被赋予了一个独立的 linux PID(app_*)</p>
</li>
</ul>
<h4 id="20-进程保活"><a href="#20-进程保活" class="headerlink" title="20.进程保活"></a>20.进程保活</h4><p>当前业界的 Android 进程保活手段主要分为黑、白、灰三种，其大致的实现思路如下： </p>
<ol>
<li>黑色保活：不同的 app 进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所谓黑色保活，就是利用不同的 app 进程使用广播来进行相互唤醒。</span><br><span class="line"></span><br><span class="line">举个3个比较常见的场景：</span><br><span class="line">1：开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒 app 场景 </span><br><span class="line"></span><br><span class="line">2：接入第三方 SDK 也会唤醒相应的 app 进程，如微信 sdk 会唤醒微信，支付宝 sdk 会 唤醒支付宝。由此发散开去，就会直接触发了下面的场景3场景 </span><br><span class="line"></span><br><span class="line">3：假如你手机里装了支付宝、淘宝、天猫、UC 等阿里系的 app，那么你打开任意一个阿里系的 app 后，有可能就顺便把其他阿里系的 app 给唤醒了。（只是拿阿里打个比方，其实BAT系都差不多）</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>白色保活：启动前台 Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">白色保活手段非常简单，就是调用系统 api 启动一个前台的 Service 进程，这样会在系统的 通知栏生成一个 Notification，用来让用户知道有这样一个 app 在运行着，哪怕当前的 app 退到了后台。</span><br></pre></td></tr></table></figure>
</li>
<li><p>灰色保活：利用系统的漏洞启动前台 Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">灰色保活，这种保活手段是应用范围最广泛。它是利用系统的漏洞来启动一个前台的 Service 进程，与普通的启动方式区别在于，它不会在系统通知栏处出现一个 Notification，看起来就 </span><br><span class="line">如同运行着一个后台 Service 进程一样。这样做带来的好处就是，用户无法察觉到你运行着 一个前台进程（因为看不到 Notification）,但你的进程优先级又是高于普通后台</span><br><span class="line">进程的。那 么如何利用系统的漏洞呢，大致的实现思路和代码如下： </span><br><span class="line"></span><br><span class="line">思路一：API &lt; 18，启动前台 Service 时直接传入 new Notification()； </span><br><span class="line"></span><br><span class="line">思路二：API &gt;&#x3D; 18，同时启动两个 id 相同的前台 Service，然后再将后启动的 Service 做 stop 处理</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="21-什么是-oom-adj？"><a href="#21-什么是-oom-adj？" class="headerlink" title="21.什么是 oom_adj？"></a>21.什么是 oom_adj？</h4><p>概念</p>
<ul>
<li>它是 linux 内核分配给 每个系统进程的一个值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收。</li>
</ul>
<p>对于 oom_adj 的作用，你只需要记住以下几点即可： </p>
<ul>
<li>进程的 oom_adj 越大，表示此进程优先级越低，越容易被杀回收；越小，表示进程优先级 越高，越不容易被杀回收 </li>
<li>普通 app 进程的 oom_adj&gt;=0,系统进程的 oom_adj 才可能&lt;0 </li>
<li>有些手机厂商把这些知名的 app 放入了自己的白名单中，保证了进程不死来提高用户体验 （如微信、QQ、陌陌都在小米的白名单中）。如果从白名单中移除，他们终究还是和普通 app 一样躲避不了被杀的命运，为了尽量避免被杀，还是老老实实去做好优化工作吧。 </li>
<li>所以，进程保活的根本方案终究还是回到了性能优化上，进程永生不死终究是个彻头彻尾的 伪命题！</li>
</ul>
<h4 id="22-讲解一下-Context"><a href="#22-讲解一下-Context" class="headerlink" title="22.讲解一下 Context"></a>22.讲解一下 Context</h4><ul>
<li>Context 是一个抽象基类。在翻译为上下文，也可以理解为环境，是提供一些程序的运行环境基础信息。</li>
<li>Context 下有两个子类，ContextWrapper 是上下文功能的封装类，而 ContextImpl 则是上下文功能的实现类。而ContextWrapper又有三个直接的子类，ContextThemeWrapper、 Service 和 Application。</li>
<li>Context 一共有三种类型，分别是 Application、Activity 和 Service。这三个类虽然分别各种承担着不同的作用，但它们都属于 Context 的一种，而它 们具体 Context 的功能则是由 ContextImpl 类去实现的，因此在绝大多数场景下，Activity、 Service 和 Application 这三种类型的 Context 都是可以通用的。</li>
<li>Context 一共有三种类型，分别是 Application、Activity 和 Service。这三个类虽然分别各种承担着不同的作用，但它们都属于 Context 的一种，而它 们具体 Context 的功能则是由 ContextImpl 类去实现的，因此在绝大多数场景下，Activity、 Service 和 Application 这三种类型的 Context 都是可以通用的。</li>
<li>getApplicationContext()和 getApplication()方法得到的对象都是同一个 application 对象，只是 对象的类型不一样。</li>
<li>Context 数量 = Activity 数量 + Service 数量 + 1 （1 为 Application）</li>
</ul>
<h4 id="23-理解-Activity，View-Window-三者关系"><a href="#23-理解-Activity，View-Window-三者关系" class="headerlink" title="23.理解 Activity，View, Window 三者关系"></a>23.理解 Activity，View, Window 三者关系</h4><p>Activity 像一个工匠（控制单元），Window 像窗户（承载模型），View 像窗花（显示视图） LayoutInflater 像剪刀，Xml 配置像窗花图纸。 </p>
<p>1：Activity 构造的时候会初始化一个 Window，准确的说是 PhoneWindow。</p>
<p>2：这个 PhoneWindow 有一个“ViewRoot”，这个“ViewRoot”是一个 View 或者说 ViewGroup， 是最初始的根视图。 </p>
<p>3：“ViewRoot”通过 addView 方法来一个个的添加 View。比如 TextView，Button 等。</p>
<p>4：这些 View 的事件监听，是由 Window完成的。</p>
<h4 id="24-View-的绘制流程"><a href="#24-View-的绘制流程" class="headerlink" title="24.View 的绘制流程"></a>24.View 的绘制流程</h4><p>View 的绘制流程：OnMeasure()——&gt;OnLayout()——&gt;OnDraw() </p>
<p>第一步：OnMeasure()：测量视图大小。从顶层父 View 到子 View 递归调用 measure 方法， measure 方法又回调 OnMeasure。 </p>
<p>第二步：OnLayout()：确定 View 位置，进行页面布局。从顶层父 View 向子 View 的递归调用 view.layout 方法的过程，即父 View 根据上一步 measure 子 View 所得到的布局大小和布局参 数，将子 View 放在合适的位置上。 </p>
<p>第三步：OnDraw()：绘制视图。ViewRoot 创建一个 Canvas 对象，然后调用 OnDraw()。六个 步骤：</p>
<p>①、绘制视图的背景；</p>
<p>②、保存画布的图层（Layer）；</p>
<p>③、绘制 View 的内容；</p>
<p>④、绘制 View 子视图，如果没有就不用；</p>
<p>⑤、还原图层（Layer）；</p>
<p>⑥、绘制滚动条。</p>
<h4 id="25-View，ViewGroup-事件分发"><a href="#25-View，ViewGroup-事件分发" class="headerlink" title="25.View，ViewGroup 事件分发"></a>25.View，ViewGroup 事件分发</h4><ol>
<li><p>Touch 事件分发中只有两个主角:ViewGroup 和 View。ViewGroup 包含 onInterceptTouchEvent、 dispatchTouchEvent、onTouchEvent 三个相关事件。View 包含 dispatchTouchEvent、onTouchEvent 两个相关事件。其中 ViewGroup 又继承于 View。 </p>
</li>
<li><p>ViewGroup 和 View 组成了一个树状结构，根节点为 Activity 内部包含的一个 ViwGroup。</p>
</li>
<li><p>触摸事件由 Action_Down、Action_Move、Aciton_UP 组成，其中一次完整的触摸事件中， Down 和 Up 都只有一个，Move 有若干个，可以为 0 个。 </p>
</li>
<li><p>当 Acitivty 接收到 Touch 事件时，将遍历子 View 进行 Down 事件的分发。ViewGroup 的遍 历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的 View，这个 View 会在 onTouchuEvent 结果返回 true。 </p>
</li>
<li><p>当某个子 View 返回 true 时，会中止 Down 事件的分发，同时在 ViewGroup 中记录该子 View。 接下去的 Move 和 Up 事件将由该子 View 直接进行处理。由于子 View 是保存在 ViewGroup 中的，多层 ViewGroup 的节点结构时，上级 ViewGroup 保存的会是真实处理事件的 View 所 在的 ViewGroup 对象:如 ViewGroup0-ViewGroup1-TextView 的结构中，TextView 返回了 true，<br>它将被保存在 ViewGroup1 中，而 ViewGroup1 也会返回 true，被保存在 ViewGroup0 中。当 Move 和 UP 事件来时，会先从 ViewGroup0 传递至 ViewGroup1，再由 ViewGroup1 传递至 TextView。 </p>
</li>
<li><p>当 ViewGroup 中所有子 View 都不捕获 Down 事件时，将触发 ViewGroup 自身的 onTouch 事件。触发的方式是调用 super.dispatchTouchEvent 函数，即父类 View 的 dispatchTouchEvent 方法。在所有子 View 都不处理的情况下，触发 Acitivity 的 onTouchEvent 方法。 </p>
</li>
<li><p>onInterceptTouchEvent 有两个作用：1.拦截 Down 事件的分发。2.中止 Up 和 Move 事件向 目标 View 传递，使得目标 View 所在的 ViewGroup 捕获 Up 和 Move 事件。</p>
</li>
</ol>
<h4 id="26-Android-中的几种动画"><a href="#26-Android-中的几种动画" class="headerlink" title="26.Android 中的几种动画"></a>26.Android 中的几种动画</h4><p>帧动画：指通过指定每一帧的图片和播放时间，有序的进行播放而形成动画效果，比如想听 的律动条。 </p>
<p>补间动画：指通过指定 View 的初始状态、变化时间、方式，通过一系列的算法去进行图形 变换，从而形成动画效果，主要有 Alpha、Scale、Translate、Rotate 四种效果。注意：只是 在视图层实现了动画效果，并没有真正改变 View 的属性，比如滑动列表，改变标题栏的透 明度。 </p>
<p>属性动画：在 Android3.0 的时候才支持，通过不断的改变 View 的属性，不断的重绘而形成 动画效果。相比于视图动画，View 的属性是真正改变了。比如 view 的旋转，放大，缩小。</p>
<h4 id="27-Android-中跨进程通讯的几种方式"><a href="#27-Android-中跨进程通讯的几种方式" class="headerlink" title="27.Android 中跨进程通讯的几种方式"></a>27.Android 中跨进程通讯的几种方式</h4><ul>
<li><p>intent：这种跨进程方式并不是访问内存的形式，它需要传递一个 uri,比如说打电话。 </p>
</li>
<li><p>contentProvider：这种形式，是使用数据共享的形式进行数据共享。 </p>
</li>
<li><p>service：远程服务，aidl</p>
</li>
<li><p>广播</p>
</li>
</ul>
<h4 id="28-AIDL-理解"><a href="#28-AIDL-理解" class="headerlink" title="28.AIDL 理解"></a>28.AIDL 理解</h4><p>AIDL: 每一个进程都有自己的 Dalvik VM 实例，都有自己的一块独立的内存，都在自己的内 存上存储自己的数据，执行着自己的操作，都在自己的那片狭小的空间里过完自己的一生。</p>
<p>而 aidl 就类似与两个进程之间的桥梁，使得两个进程之间可以进行数据的传输，跨进程通信 有多种选择，比如 BroadcastReceiver , Messenger 等，但是 BroadcastReceiver 占用的系统 资源比较多，如果是频繁的跨进程通信的话显然是不可取的；Messenger 进行跨进程通信时 请求队列是同步进行的，无法并发执行。</p>
<h4 id="29-Binder-机制简单理解"><a href="#29-Binder-机制简单理解" class="headerlink" title="29.Binder 机制简单理解"></a>29.Binder 机制简单理解</h4><p>在 Android 系统的 Binder 机制中，是有Client,Service,ServiceManager,Binder 驱动程序组成的， 其中 Client，service，Service Manager 运行在用户空间，Binder 驱动程序是运行在内核空间 的。而 Binder 就是把这 4 种组件粘合在一块的粘合剂，其中核心的组件就是 Binder 驱动程 序，Service Manager 提供辅助管理的功能，而 Client 和 Service 正是在 Binder 驱动程序和 Service Manager 提供的基础设施上实现 C/S 之间的通信。其中 Binder 驱动程序提供设备文 件/dev/binder 与用户控件进行交互</p>
<p>Client、Service，Service Manager 通过 open 和 ioctl 文件操作相应的方法与 Binder 驱动程序 进行通信。而Client和Service之间的进程间通信是通过Binder驱动程序间接实现的。而Binder Manager 是一个守护进程，用来管理 Service，并向 Client 提供查询 Service 接口的能力。</p>
<h4 id="30-Handler-的原理"><a href="#30-Handler-的原理" class="headerlink" title="30.Handler 的原理"></a>30.Handler 的原理</h4><p>Android 中主线程是不能进行耗时操作的，子线程是不能进行更新 UI 的。所以就有了 handler， 它的作用就是实现线程之间的通信。</p>
<p>handler 整个流程中，主要有四个对象，handler，Message,MessageQueue,Looper。当应用创 建的时候，就会在主线程中创建 handler 对象， </p>
<p>我们通过要传送的消息保存到 Message 中，handler 通过调用 sendMessage 方法将 Message 发送到 MessageQueue 中，Looper 对象就会不断的调用 loop()方法 </p>
<p>不断的从 MessageQueue 中取出 Message 交给 handler 进行处理。从而实现线程之间的通信。</p>
<h4 id="31-热修复的原理"><a href="#31-热修复的原理" class="headerlink" title="31.热修复的原理"></a>31.热修复的原理</h4><p>我们知道 Java 虚拟机 —— JVM 是加载类的 class 文件的，而 Android 虚拟机——Dalvik/ART VM 是加载类的 dex 文件， 而他们加载类的时候都需要 ClassLoader,ClassLoader 有一个子类 BaseDexClassLoader，而 BaseDexClassLoader 下有一个 数组——DexPathList，是用来存放 dex 文件，当 BaseDexClassLoader 通过调用 findClass 方法 时，实际上就是遍历数组， 找到相应的 dex 文件，找到，则直接将它 return。</p>
<p>而热修复的解决方法就是将新的 dex 添加 到该集合中，并且是在旧的 dex 的前面， 所以就会优先被取出来并且 return 返回。</p>
<h4 id="32-内存泄露原因"><a href="#32-内存泄露原因" class="headerlink" title="32.内存泄露原因"></a>32.内存泄露原因</h4><p>一、Handler 引起的内存泄漏。 </p>
<p>解决：将 Handler 声明为静态内部类，就不会持有外部类 SecondActivity 的引用，其生命周 期就和外部类无关， 如果 Handler 里面需要 context 的话，可以通过弱引用方式引用外部类 </p>
<p>二、单例模式引起的内存泄漏。 </p>
<ul>
<li>解决：Context 是 ApplicationContext，由于 ApplicationContext 的生命周期是和 app 一致的， 不会导致内存泄漏 </li>
</ul>
<p>三、非静态内部类创建静态实例引起的内存泄漏。 </p>
<ul>
<li>解决：把内部类修改为静态的就可以避免内存泄漏了 </li>
</ul>
<p>四、非静态匿名内部类引起的内存泄漏。</p>
<ul>
<li>解决：将匿名内部类设置为静态的。 </li>
</ul>
<p>五、注册/反注册未成对使用引起的内存泄漏。 </p>
<ul>
<li>注册广播接受器、EventBus 等，记得解绑。 </li>
</ul>
<p>六、资源对象没有关闭引起的内存泄漏。 </p>
<ul>
<li>在这些资源不使用的时候，记得调用相应的类似 close（）、destroy（）、recycler（）、release （）等方法释放。 </li>
</ul>
<p>七、集合对象没有及时清理引起的内存泄漏。 </p>
<ul>
<li>通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不 再被引用。</li>
</ul>
<h4 id="33-Android-UI-适配"><a href="#33-Android-UI-适配" class="headerlink" title="33.Android UI 适配"></a>33.Android UI 适配</h4><p>字体使用 sp,使用 dp，多使用 match_parent，wrap_content，weight </p>
<p>图片资源，不同图片的的分辨率，放在相应的文件夹下可使用百分比代替。</p>
<h4 id="34-App-启动优化-针对冷启动-App"><a href="#34-App-启动优化-针对冷启动-App" class="headerlink" title="34.App 启动优化(针对冷启动) App"></a>34.App 启动优化(针对冷启动) App</h4><p>启动的方式有三种： </p>
<ol>
<li>冷启动：App 没有启动过或 App 进程被 killed, 系统中不存在该 App 进程, 此时启动 App 即 为冷启动。 </li>
<li>热启动：热启动意味着你的 App 进程只是处于后台, 系统只是将其从后台带到前台, 展示给 用户。</li>
<li>介于冷启动和热启动之间, 一般来说在以下两种情况下发生: </li>
</ol>
<ul>
<li>(1)用户 back 退出了 App, 然后又启动. App 进程可能还在运行, 但是 activity 需要重建。 </li>
<li>(2)用户退出 App 后, 系统可能由于内存原因将 App 杀死, 进程和 activity 都需要重启, 但是 可以在 onCreate 中将被动杀死锁保存的状态(saved instance state)恢复。</li>
</ul>
<h4 id="35-ANR"><a href="#35-ANR" class="headerlink" title="35.ANR"></a>35.ANR</h4><p>概念 </p>
<ul>
<li>ANR 全名 Application Not Responding, 也就是”应用无响应”. 当操作在一段时间内系统无法 处理时, 系统层面会弹出上图那样的 ANR 对话框.</li>
</ul>
<p>解决方式：</p>
<p>(1)不要在主线程中做耗时的操作，而应放在子线程中来实现。如 onCreate()和 onResume() 里尽可能少的去做创建操作。 </p>
<p>(2)应用程序应该避免在 BroadcastReceiver 里做耗时的操作或计算。</p>
<p>(3)避免在 Intent Receiver 里启动一个 Activity，因为它会创建一个新的画面，并从当前用户正 在运行的程序上抢夺焦点。 </p>
<p>(4)service 是运行在主线程的，所以在 service 中做耗时操作，必须要放在子线程中。</p>
<h4 id="36-MVC，MVP，MVVM"><a href="#36-MVC，MVP，MVVM" class="headerlink" title="36.MVC，MVP，MVVM"></a>36.MVC，MVP，MVVM</h4><p><a href="https://imgchr.com/i/8rgdgK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/19/8rgdgK.md.png" alt="8rgdgK.md.png"></a></p>
<p>MVC：PC时代就有的架构方案，在Android上也是最早的方案，Activity/Fragment这些上帝角色既承担了V的角色，也承担了C的角色，小项目开发起来十分顺手，大项目就会遇到<br>耦合过重，Activity/Fragment类过大等问题。</p>
<p>MVP：为了解决MVC耦合过重的问题，MVP的核心思想就是提供一个Presenter将视图逻辑I和业务逻辑相分离，达到解耦的目的。</p>
<p>MVVM：使用ViewModel代替Presenter，实现数据与View的双向绑定，这套框架最早使用的data-binding将数据绑定到xml里，这么做在大规模应用的时候是不行的，不过数据绑定是一个很有用的概念，后续Google又推出了ViewModel组件与LiveData组件。ViewModel组件规范了ViewModel所处的地位、生命周期、生产方式以及一个Activity下多个Fragment共享ViewModel数据的问题。LiveData组件则提供了在Java层面View订阅ViewModel数据源的实现方案。</p>
<h4 id="37-Glide-的理解"><a href="#37-Glide-的理解" class="headerlink" title="37.Glide 的理解"></a>37.Glide 的理解</h4><ol>
<li><p>不仅仅可以进行图片缓存还可以缓存媒体文件。Glide 不仅是一个图片缓存，它支持 Gif、 WebP、缩略图。甚至是 Video，所以更该当做一个媒体缓存。</p>
</li>
<li><p>支持优先级处理。 </p>
</li>
<li><p>与 Activity/Fragment 生命周期一致，支持 trimMemory。Glide 对每个 context 都保持一 个 RequestManager，通过 FragmentTransaction 保持与 Activity/Fragment 生命周期一致， 并且有对应的 trimMemory 接口实现可供调用。 </p>
</li>
<li><p>支持 okhttp、Volley。Glide 默认通过 UrlConnection 获取数据，可以配合 okhttp 或是 Volley 使用。实际 ImageLoader、Picasso 也都支持 okhttp、Volley。</p>
</li>
</ol>
<h4 id="38-Xutils-OKhttp-Volley-Retrofit-对比"><a href="#38-Xutils-OKhttp-Volley-Retrofit-对比" class="headerlink" title="38.Xutils, OKhttp, Volley, Retrofit 对比"></a>38.Xutils, OKhttp, Volley, Retrofit 对比</h4><p>Xutils 这个框架非常全面，可以进行网络请求，可以进行图片加载处理，可以数据储存，还 可以对 view 进行注解，使用这个框架非常方便，但是缺点也是非常明显的，使用这个项目， 会导致项目对这个框架依赖非常的严重，一旦这个框架出现问题，那么对项目来说影响非常 大的。</p>
<p>OKhttp ： Android 开发中是可以直接使用现成的 api 进 行 网 络请求 的 。 就 是 使 用 HttpClient,HttpUrlConnection 进行操作。okhttp 针对 Java 和 Android 程序，封装的一个高性 能的 http 请求库，支持同步，异步，而且 okhttp 又封装了线程池，封装了数据转换，封装 了参数的使用，错误处理等。API 使用起来更加的方便。但是我们在项目中使用的时候仍然 需要自己在做一层封装，这样才能使用的更加的顺手。 </p>
<p>Volley：Volley 是 Google 官方出的一套小而巧的异步请求库，该框架封装的扩展性很强，支 持 HttpClient、HttpUrlConnection，甚至支持 OkHttp，而且 Volley 里面也封装了 ImageLoader， 所以如果你愿意你甚至不需要使用图片加载框架，不过这块功能没有一些专门的图片加载框 架强大，对于简单的需求可以使用，稍复杂点的需求还是需要用到专门的图片加载框架。 Volley 也有缺陷，比如不支持 post 大数据，所以不适合上传文件。不过 Volley 设计的初衷本 身也就是为频繁的、数据量小的网络请求而生。 </p>
<p>Retrofit：Retrofit 是 Square 公司出品的默认基于 OkHttp 封装的一套 RESTful 网络请求框架， RESTful 是目前流行的一套 api 设计的风格， 并不是标准。Retrofit 的封装可以说是很强大， 里面涉及到一堆的设计模式,可以通过注解直接配置请求，可以使用不同的 http 客户端，虽 然默认是用 http ，可以使用不同 Json Converter 来序列化数据，同时提供对 RxJava 的支持， 使用 Retrofit + OkHttp + RxJava + Dagger2 可以说是目前比较潮的一套框架，但是需要有比较 高的门槛。</p>
<p>Volley VS OkHttp </p>
<p>Volley 的优势在于封装的更好，而使用 OkHttp 你需要有足够的能力再进行一次封装。而 OkHttp 的优势在于性能更高，因为 OkHttp 基于 NIO 和 Okio ，所以性能上要比 Volley 更快。 IO 和 NIO 这两个都是 Java 中的概念，如果我从硬盘读取数据，第一种方式就是程序一直等， 数据读完后才能继续操作这种是最简单的也叫阻塞式 IO,还有一种是你读你的,程序接着往下 执行，等数据处理完你再来通知我，然后再处理回调。而第二种就是 NIO 的方式，非阻塞 式， 所以 NIO 当然要比 IO 的性能要好了,而 Okio 是 Square 公司基于 IO 和 NIO 基础上做 的一个更简单、高效处理数据流的一个库。理论上如果 Volley 和 OkHttp 对比的话，更倾向 于使用 Volley，因为 Volley 内部同样支持使用 OkHttp,这点 OkHttp 的性能优势就没了， 而 且 Volley 本身封装的也更易用，扩展性更好些。</p>
<h4 id="39-Android中的动画有哪些"><a href="#39-Android中的动画有哪些" class="headerlink" title="39.Android中的动画有哪些"></a>39.Android中的动画有哪些</h4><p>逐帧动画(Frame Animation)</p>
<ul>
<li>加载一系列Drawable资源来创建动画，简单来说就是播放一系列的图片来实现动画效果，可以自定义每张图片的持续时间</li>
</ul>
<p>补间动画(Tween Animation)</p>
<ul>
<li>Tween可以对View对象实现一系列动画效果，比如平移，缩放，旋转，透明度等。但是它并不会改变View属性的值，只是改变了View的绘制的位置，比如，一个按钮在动画过后，不在原来的位置，但是触发点击事件的仍然是原来的坐标。</li>
</ul>
<p>属性动画(Property Animation)</p>
<ul>
<li>动画的对象除了传统的View对象，还可以是Object对象，动画结束后，Object对象的属性值被实实在在的改变了</li>
</ul>
<h4 id="40-synchronized和lock的区别？"><a href="#40-synchronized和lock的区别？" class="headerlink" title="40.synchronized和lock的区别？"></a>40.synchronized和lock的区别？</h4><p>synchronized会主动释放锁，而lock需要手动调用unlock释放锁；</p>
<p>synchronized是java内置的关键字，而lock是个java类；</p>
<h4 id="41-开发过程中如果想替换第三方jar中的某个class文件，或者在开发时你的class文件与jar中的重名，但是你想使用自己的应该如何解决？如果你替换掉某个方法又该怎么解决？"><a href="#41-开发过程中如果想替换第三方jar中的某个class文件，或者在开发时你的class文件与jar中的重名，但是你想使用自己的应该如何解决？如果你替换掉某个方法又该怎么解决？" class="headerlink" title="41.开发过程中如果想替换第三方jar中的某个class文件，或者在开发时你的class文件与jar中的重名，但是你想使用自己的应该如何解决？如果你替换掉某个方法又该怎么解决？"></a>41.开发过程中如果想替换第三方jar中的某个class文件，或者在开发时你的class文件与jar中的重名，但是你想使用自己的应该如何解决？如果你替换掉某个方法又该怎么解决？</h4><p>方式一：可以获取到jar的源码或者将jar反编译获取到java项目，然后替换掉自己想要的.java文件或者方法；</p>
<p>方式二：可以通过类加载器将目标class替换成自己的class；</p>
<h4 id="42-IO与NIO的区别？"><a href="#42-IO与NIO的区别？" class="headerlink" title="42.IO与NIO的区别？"></a>42.IO与NIO的区别？</h4><p>第一点：IO是面向流的，NIO是面向缓冲区的。</p>
<p>IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。</p>
<p>NIO是面向缓存的。数据读取到一个缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且要确保当更多的数据读入缓冲区时，不要覆盖缓冲区中未处理的数据。</p>
<p>第二点：IO的各种流是阻塞的。</p>
<p>这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情。NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，在数据可读之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h4 id="43-单例模式有几种写法以及各自的优劣？"><a href="#43-单例模式有几种写法以及各自的优劣？" class="headerlink" title="43.单例模式有几种写法以及各自的优劣？"></a>43.单例模式有几种写法以及各自的优劣？</h4><p>1.饿汉式：</p>
<p>缺点：存在内存损耗问题，如果当前类没有用到也会被实例化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingleInstance &#123;</span><br><span class="line">    </span><br><span class="line">    private static SingleInstance mInstance &#x3D; new SingleInstance();</span><br><span class="line">    </span><br><span class="line">    private SingleInstance()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static SingleInstance getInstance()&#123;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.懒汉式：</p>
<p>缺点：加了synchronized锁会影响性能<br>有次被问到为什么要有两次空判断？</p>
<p>第一次空判断和好理解，可以很大程度上减少锁机制的次数；</p>
<p>第二次判空是因为，如果a，b两个线程都到了synchronized处，而假设a拿到了锁，进入到代码块中创建了对象，然后释放了锁，由于b线程在等待锁，所以a释放后，会被b拿到，因此此时判空就保证了实例的唯一性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingleInstance &#123;</span><br><span class="line"></span><br><span class="line">    private static SingleInstance mInstance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private SingleInstance()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static SingleInstance getInstance()&#123;</span><br><span class="line">        if(mInstance&#x3D;&#x3D;null)&#123;</span><br><span class="line">            synchronized (SingleInstance.class)&#123;</span><br><span class="line">                if(mInstance&#x3D;&#x3D;null)&#123;</span><br><span class="line">                    mInstance &#x3D; new SingleInstance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="44-自定义View的基本流程"><a href="#44-自定义View的基本流程" class="headerlink" title="44.自定义View的基本流程"></a>44.自定义View的基本流程</h4><p>①.自定义View的属性 编写attr.xml文件</p>
<p>②.在layout布局文件中引用，同时引用命名空间</p>
<p>③.在View的构造方法中获得我们自定义的属性 ，在自定义控件中进行读取（构造方法拿到attr.xml文件值）</p>
<p>④.重写onMesure</p>
<p>⑥.重写onDraw</p>
<h4 id="45-三级缓存-这个偶尔会问"><a href="#45-三级缓存-这个偶尔会问" class="headerlink" title="45.三级缓存(这个偶尔会问)"></a>45.三级缓存(这个偶尔会问)</h4><p>网络加载，不优先加载，速度慢，浪费流量</p>
<p>本地缓存，次优先加载，速度快</p>
<p>内存缓存，优先加载，速度最快</p>
<p>首次加载Android App时，肯定要通过网络交互来获取图片，之后我们可以将图片保存至本地SD卡和内存中，之后运行APP时，优先访问内存中的图片缓存，若内存中没有，则加载本地SD卡中图片，最后选择访问网络</p>
<h4 id="46-内存泄露原因以及解决"><a href="#46-内存泄露原因以及解决" class="headerlink" title="46.内存泄露原因以及解决"></a>46.内存泄露原因以及解决</h4><p>一、Handler 引起的内存泄漏。</p>
<p>解决：将Handler声明为静态内部类，就不会持有外部类SecondActivity的引用，其生命周期就和外部类无关，</p>
<p>如果Handler里面需要context的话，可以通过弱引用方式引用外部类</p>
<p>二、单例模式引起的内存泄漏。</p>
<p>解决：Context是ApplicationContext，由于ApplicationContext的生命周期是和app一致的，不会导致内存泄漏</p>
<p>三、非静态内部类创建静态实例引起的内存泄漏。</p>
<p>解决：把内部类修改为静态的就可以避免内存泄漏了</p>
<p>四、非静态匿名内部类引起的内存泄漏。</p>
<p>解决：将匿名内部类设置为静态的。</p>
<p>五、注册/反注册未成对使用引起的内存泄漏。</p>
<p>注册广播接受器、EventBus等，记得解绑。</p>
<p>六、资源对象没有关闭引起的内存泄漏。</p>
<p>在这些资源不使用的时候，记得调用相应的类似close（）、destroy（）、recycler（）、release（）等方法释放。</p>
<p>七、集合对象没有及时清理引起的内存泄漏。</p>
<p>通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不再被引用。</p>
<h4 id="47-图片加载框架有哪些？他们之间的区别是什么？"><a href="#47-图片加载框架有哪些？他们之间的区别是什么？" class="headerlink" title="47.图片加载框架有哪些？他们之间的区别是什么？"></a>47.图片加载框架有哪些？他们之间的区别是什么？</h4><h5 id="ImageLoader-："><a href="#ImageLoader-：" class="headerlink" title="ImageLoader ："></a>ImageLoader ：</h5><p>优点：</p>
<p>①　支持下载进度监听；</p>
<p>②　可以在 View 滚动中暂停图片加载；</p>
<p>③　默认实现多种内存缓存算法这几个图片缓存都可以配置缓存算法，不过 ImageLoader 默认实现了较多缓存算法，如 Size 最大先删除、使用最少先删除、最近最少使用、先进先删除、时间最长先删除等；</p>
<p>④　支持本地缓存文件名规则定义；</p>
<p>缺点:</p>
<p>缺点在于不支持GIF图片加载, 缓存机制没有和http的缓存很好的结合, 完全是自己的一套缓存机制</p>
<h5 id="Picasso："><a href="#Picasso：" class="headerlink" title="Picasso："></a>Picasso：</h5><p>优点：</p>
<p>①　自带统计监控功能，支持图片缓存使用的监控，包括缓存命中率、已使用内存大小、节省的流量等。</p>
<p>②　支持优先级处理</p>
<p>③　支持延迟到图片尺寸计算完成加载</p>
<p>④　支持飞行模式、并发线程数根据网络类型而变，手机切换到飞行模式或网络类型变换时会自动调整线程池最大并发数。</p>
<p>⑤ “无”本地缓存。Picasso 自己没有实现本地缓存，而由okhttp 去实现，这样的好处是可以通过请求 Response Header 中的 Cache-Control 及 Expired 控制图片的过期时间。</p>
<p>缺点：</p>
<p>于不支持GIF，默认使用ARGB_8888格式缓存图片，缓存体积大。</p>
<p>Glide：</p>
<p>优点：</p>
<p>①　图片缓存-&gt;媒体缓存 ，支持 Gif、WebP、缩略图。甚至是 Video。</p>
<p>②　支持优先级处理</p>
<p>③　与 Activity/Fragment 生命周期一致，支持 trimMemory</p>
<p>④　支持 okhttp、Volley。Glide 默认通过 UrlConnection 获取数据，可以配合 okhttp 或是 Volley 使用。实际 ImageLoader、Picasso 也都支持 okhttp、Volley。</p>
<p>⑤　内存友好，内存缓存更小图片，图片默认使用默认 RGB565 而不是 ARGB888</p>
<p>缺点：</p>
<p>清晰度差，但可以设置</p>
<h5 id="Fresco："><a href="#Fresco：" class="headerlink" title="Fresco："></a>Fresco：</h5><p>优点:</p>
<p>①　图片存储在安卓系统的匿名共享内存, 而不是虚拟机的堆内存中,所以不会因为图片加载而导致oom, 同时也减少垃圾回收器频繁调用回收Bitmap导致的界面卡顿,性能更高.</p>
<p>②　渐进式加载JPEG图片, 支持图片从模糊到清晰加载</p>
<p>③　图片可以以任意的中心点显示在ImageView, 而不仅仅是图片的中心.</p>
<p>④ JPEG图片改变大小也是在native进行的, 不是在虚拟机的堆内存, 同样减少OOM</p>
<p>⑤　很好的支持GIF图片的显示</p>
<p>缺点:</p>
<p>框架较大, 影响Apk体积，使用较繁琐</p>
<h4 id="48-ContentProvider、ContentResolver与ContentObserver之间的关系是什么？"><a href="#48-ContentProvider、ContentResolver与ContentObserver之间的关系是什么？" class="headerlink" title="48.ContentProvider、ContentResolver与ContentObserver之间的关系是什么？"></a>48.ContentProvider、ContentResolver与ContentObserver之间的关系是什么？</h4><p>ContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、文件、XML、网络等，ContentProvider为这些数据的访问提供了统一的接口，可以用来做进程间数据共享。</p>
<p>ContentResolver：ContentResolver可以不同URI操作不同的ContentProvider中的数据，外部进程可以通过ContentResolver与ContentProvider进行交互。</p>
<p>ContentObserver：观察ContentProvider中的数据变化，并将变化通知给外界。</p>
<h4 id="49-APK的打包流程"><a href="#49-APK的打包流程" class="headerlink" title="49.APK的打包流程"></a>49.APK的打包流程</h4><ol>
<li><p>通过AAPT工具进行资源文件（包括AndroidManifest.xml、布局文件、各种xml资源等）的打包，生成R.java文件。</p>
</li>
<li><p>通过AIDL工具处理AIDL文件，生成相应的Java文件。</p>
</li>
<li><p>通过Javac工具编译项目源码，生成Class文件。</p>
</li>
<li><p>通过DX工具将所有的Class文件转换成DEX文件，该过程主要完成Java字节码转换成Dalvik字节码，压缩常量池以及清除冗余信息等工作。</p>
</li>
<li><p>通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件。</p>
</li>
<li><p>利用KeyStore对生成的APK文件进行签名。</p>
</li>
<li><p>如果是正式版的APK，还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件<br>的速度会更快</p>
</li>
</ol>
<h4 id="50-Activity的启动流程"><a href="#50-Activity的启动流程" class="headerlink" title="50.Activity的启动流程"></a>50.Activity的启动流程</h4><ol>
<li><p>点击桌面应用图标，Launcher进程将启动Activity（MainActivity）的请求以Binder的方式发送给了AMS。</p>
</li>
<li><p>AMS接收到启动请求后，交付ActivityStarter处理Intent和Flag等信息，然后再交给ActivityStackSupervisior/ActivityStack<br>处理Activity进栈相关流程。同时以Socket方式请求Zygote进程fork新进程。</p>
</li>
<li><p>Zygote接收到新进程创建请求后fork出新进程。</p>
</li>
<li><p>在新进程里创建ActivityThread对象，新创建的进程就是应用的主线程，在主线程里开启Looper消息循环，开始处理创建Activity。</p>
</li>
<li><p>ActivityThread利用ClassLoader去加载Activity、创建Activity实例，并回调Activity的onCreate()方法。这样便完成了Activity的启动。</p>
</li>
</ol>
<h4 id="51-既然有现有的IPC方式，为什么重新设计一套Binder机制呢"><a href="#51-既然有现有的IPC方式，为什么重新设计一套Binder机制呢" class="headerlink" title="51.既然有现有的IPC方式，为什么重新设计一套Binder机制呢?"></a>51.既然有现有的IPC方式，为什么重新设计一套Binder机制呢?</h4><ol>
<li><p>高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。</p>
</li>
<li><p>稳定性：上面说到共享内存的性能优于Binder，那为什么不适用共享内存呢，因为共享内存需要处理并发同步问题，控制负责，容易出现死锁和资源竞争，稳定性较差。而Binder基于C/S架构，客户端与服务端彼此独立，稳定性较好。</p>
</li>
<li><p>安全性：我们知道Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理，包括6.0以前的固定权限和6.0以后的动态权限，传荣IPC只能由用户在数据包里填入UID/PID，这个标记完全是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。</p>
</li>
</ol>
<h4 id="52-Java与C-如何相互调用？"><a href="#52-Java与C-如何相互调用？" class="headerlink" title="52.Java与C++如何相互调用？"></a>52.Java与C++如何相互调用？</h4><p>Java调用C++</p>
<ol>
<li><p>在Java中声明Native方法（即需要调用的本地方法）</p>
</li>
<li><p>编译上述 Java源文件javac（得到 .class文件）</p>
</li>
<li><p>通过 javah 命令导出JNI的头文件（.h文件）</p>
</li>
<li><p>使用 Java需要交互的本地代码 实现在 Java中声明的Native方法</p>
</li>
<li><p>编译.so库文件</p>
</li>
<li><p>通过Java命令执行 Java程序，最终实现Java调用本地代码</p>
</li>
</ol>
<p>C++调用Java</p>
<ol>
<li><p>从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象。</p>
</li>
<li><p>获取类的默认构造方法ID。</p>
</li>
<li><p>查找实例方法的ID。</p>
</li>
<li><p>创建该类的实例。</p>
</li>
<li><p>调用对象的实例方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessMethod_callJavaInstaceMethod  </span><br><span class="line">(JNIEnv *env, jclass cls)  </span><br><span class="line">&#123;  </span><br><span class="line">    jclass clazz &#x3D; NULL;  </span><br><span class="line">    jobject jobj &#x3D; NULL;  </span><br><span class="line">    jmethodID mid_construct &#x3D; NULL;  </span><br><span class="line">    jmethodID mid_instance &#x3D; NULL;  </span><br><span class="line">    jstring str_arg &#x3D; NULL;  </span><br><span class="line">    &#x2F;&#x2F; 1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象  </span><br><span class="line">    clazz &#x3D; (*env)-&gt;FindClass(env, &quot;com&#x2F;study&#x2F;jnilearn&#x2F;ClassMethod&quot;);  </span><br><span class="line">    if (clazz &#x3D;&#x3D; NULL) &#123;  </span><br><span class="line">        printf(&quot;找不到&#39;com.study.jnilearn.ClassMethod&#39;这个类&quot;);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F; 2、获取类的默认构造方法ID  </span><br><span class="line">    mid_construct &#x3D; (*env)-&gt;GetMethodID(env,clazz, &quot;&lt;init&gt;&quot;,&quot;()V&quot;);  </span><br><span class="line">    if (mid_construct &#x3D;&#x3D; NULL) &#123;  </span><br><span class="line">        printf(&quot;找不到默认的构造方法&quot;);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F; 3、查找实例方法的ID  </span><br><span class="line">    mid_instance &#x3D; (*env)-&gt;GetMethodID(env, clazz, &quot;callInstanceMethod&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;I)V&quot;);  </span><br><span class="line">    if (mid_instance &#x3D;&#x3D; NULL) &#123;  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F; 4、创建该类的实例  </span><br><span class="line">    jobj &#x3D; (*env)-&gt;NewObject(env,clazz,mid_construct);  </span><br><span class="line">    if (jobj &#x3D;&#x3D; NULL) &#123;  </span><br><span class="line">        printf(&quot;在com.study.jnilearn.ClassMethod类中找不到callInstanceMethod方法&quot;);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F; 5、调用对象的实例方法  </span><br><span class="line">    str_arg &#x3D; (*env)-&gt;NewStringUTF(env,&quot;我是实例方法&quot;);  </span><br><span class="line">    (*env)-&gt;CallVoidMethod(env,jobj,mid_instance,str_arg,200);  </span><br><span class="line">    &#x2F;&#x2F; 删除局部引用  </span><br><span class="line">    (*env)-&gt;DeleteLocalRef(env,clazz);  </span><br><span class="line">    (*env)-&gt;DeleteLocalRef(env,jobj);  </span><br><span class="line">    (*env)-&gt;DeleteLocalRef(env,str_arg);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="53-了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？"><a href="#53-了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？" class="headerlink" title="53.了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？"></a>53.了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？</h4><p>插件化：插件化是体现在功能拆分方面的，它将某个功能独立提取出来，独立开发，独立测试，再插入到主应用中。依次来较少主应用的规模。</p>
<p>热修复：热修复是体现在bug修复方面的，它实现的是不需要重新发版和重新安装，就可以去修复已知的bug。</p>
<h4 id="54-将apk文件复制到data-app目录"><a href="#54-将apk文件复制到data-app目录" class="headerlink" title="54.将apk文件复制到data/app目录"></a>54.将apk文件复制到data/app目录</h4><p>解析apk信息</p>
<p>dexopt操作</p>
<p>更新权限信息</p>
<p>完成安装,发送Intent.ACTION_PACKAGE_ADDED广播</p>
<h4 id="55-JNI的几种注册方式"><a href="#55-JNI的几种注册方式" class="headerlink" title="55.JNI的几种注册方式"></a>55.JNI的几种注册方式</h4><p>静态注册</p>
<p>1.编写一个java类，在里面加载对应的so库并且通过native关键字定义需要调用的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.wenzhe.myjni;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by wenzhe on 16-1-27.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JniTest &#123;</span><br><span class="line">public native int getRandomNum();</span><br><span class="line">public native String getNativeString();</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    System.loadLibrary(&quot;HelloJni&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.在命令行下输入 javac JniTest.java 生成JniTest.class文件</p>
<p>3.将头文件拷贝到jni目录下(eclipse在src同级目录建立文件夹，Android studio 在java同级目录建立文件夹)</p>
<p>4.编写C/C++源代码 并把刚拷贝的头文件包含进去 ,复制头文件中函数的定义部分，并实现其中的你想要的功能</p>
<p>5.在命令行中进入jni目录，输入ndk-build 即可生产对应so库，会自动放在libs文件夹下 至此就可以运行程序了</p>
<p>动态注册</p>
<p>1.编写Java端的相关native方法</p>
<p>2.编写C/C++代码, 实现JNI_Onload()方法</p>
<p>3.将Java 方法和 C/C++方法通过签名信息一一对应起来</p>
<p>4.通过JavaVM获取JNIEnv, JNIEnv主要用于获取Java类和调用一些JNI提供的方法</p>
<p>5.使用类名和对应起来的方法作为参数, 调用JNI提供的函数RegisterNatives()注册方</p>
<h4 id="56-自定义View-的步骤"><a href="#56-自定义View-的步骤" class="headerlink" title="56.自定义View 的步骤"></a>56.自定义View 的步骤</h4><p>自定义View属性</p>
<p>在View的构造方法中获得自定义的属性</p>
<p>重写onMesure</p>
<p>重写onDraw</p>
<h4 id="57-同步和异步的概念区别："><a href="#57-同步和异步的概念区别：" class="headerlink" title="57.同步和异步的概念区别："></a>57.同步和异步的概念区别：</h4><p>同步，必须执行完成某个问题后才能继续执行其他的。</p>
<p>异步，我会去先执行其他问题，你执行完之后返回给我一个结果就可以。</p>
<hr>
<p>android中为什么要引用异步任务呢？</p>
<p>　android启动的，会启动一个线程也称为主线程，UI线程，但是我们不能把所有耗时的任务交给主线程来完成，这样会影响用户的体验，也就是说我们要另外的开辟新的线程来执行我们的任务，但是在android中，（加载图片，网络编程都属于耗时的操作），在android4.0后规定禁止在主线程中完成网络操作，所以说这些耗时的任务要交给子线程。</p>
<hr>
<p>　<br>Asynctask的基本使用：</p>
<p>首先它是一个抽象类，也就是说我们要重写他的方法然后在new</p>
<p>AsyncTask&lt;Params,progress,result&gt;</p>
<p>parames:启动任务的时候执行的参数，比如传入的url</p>
<p>Progress：后台执行进度的百分比单位</p>
<p>result：执行完异步操作后返回的结果</p>
<h4 id="58-EventBus的原理"><a href="#58-EventBus的原理" class="headerlink" title="58.EventBus的原理"></a>58.EventBus的原理</h4><ol>
<li><p>构造方法: 创建构造方法: 通过双重锁的模式创建对象 ; 通过建造者模式创建对象</p>
</li>
<li><p>注册:这个subscriber就是我们使用EventBus.getDefault().register(this);传入的这个this，比如MainActivity.this。通过反射，查找该Subscriber中，通过@Subscribe注解的方法（消费方法）信息，将这些方法信息封装到SubscriberMethod中，封装的内容包括Method对象、ThreadMode、事件类型、优先级、是否粘性等</p>
</li>
<li><p>发布与消费事件: post进行发布 .然后到线程的队列中,然后进行消费事件,消费的时候通过反射和method 调用,这是回到queue队列当中,循环遍历queue中的event 查找可以消费该事件的类和方法,最终他会将事件交给这个类和方法,完成整个消息的发布与消费;</p>
</li>
</ol>
<hr>
<p>Handler与EventBus区别</p>
<p>EventBus是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息.优点是开销小，代码更优雅。以及将发送者和接收者解耦。</p>
<p>大家可以简单对比下两者的区别，可以发现EventBus进行了完全的解耦。</p>
]]></content>
      <categories>
        <category>面试笔记</category>
      </categories>
      <tags>
        <tag>面试笔记</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>算法面试笔记</title>
    <url>/2020/06/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/dgdvlo.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">一抹光</div>
</center>


<blockquote>
<p>本科面试笔记</p>
</blockquote>
<a id="more"></a>

<h3 id="一、树"><a href="#一、树" class="headerlink" title="一、树"></a>一、树</h3><h4 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1.红黑树"></a>1.红黑树</h4><ul>
<li>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。</li>
<li>通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树</li>
</ul>
<p>性质：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 每个节点非红即黑</span><br><span class="line"></span><br><span class="line">2. 根节点是黑的;</span><br><span class="line"></span><br><span class="line">3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</span><br><span class="line"></span><br><span class="line">4. 如果一个节点是红色的，则它的子节点必须是黑色的。</span><br><span class="line"></span><br><span class="line">5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</span><br></pre></td></tr></table></figure>

<h4 id="2-AVL树"><a href="#2-AVL树" class="headerlink" title="2.AVL树"></a>2.AVL树</h4><p>平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。</p>
<h4 id="3-map底层为什么用红黑树实现"><a href="#3-map底层为什么用红黑树实现" class="headerlink" title="3.map底层为什么用红黑树实现"></a>3.map底层为什么用红黑树实现</h4><p>红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p>
<h4 id="4-Top-K-问题"><a href="#4-Top-K-问题" class="headerlink" title="4.Top(K)问题"></a>4.Top(K)问题</h4><p>1、直接全部排序（只适用于内存够的情况）</p>
<p>当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。</p>
<p>这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。</p>
<p>2、快速排序的变形 （只使用于内存够的情况）</p>
<p>这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。</p>
<p>这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index  &gt; K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index &lt; K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。</p>
<p>3、最小堆法</p>
<p>这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。</p>
<p>4、分治法</p>
<p>将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N<em>K个数据，如果内存不能容纳N</em>K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。</p>
<p>5、Hash法</p>
<p>如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。</p>
<h4 id="5-红黑树较AVL树的优点："><a href="#5-红黑树较AVL树的优点：" class="headerlink" title="5.红黑树较AVL树的优点："></a>5.红黑树较AVL树的优点：</h4><p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p>
<h4 id="6-二叉树的层序遍历并输出（手写代码）"><a href="#6-二叉树的层序遍历并输出（手写代码）" class="headerlink" title="6.二叉树的层序遍历并输出（手写代码）"></a>6.二叉树的层序遍历并输出（手写代码）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line">&#x2F;**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val &#x3D; 0;</span><br><span class="line">    TreeNode left &#x3D; null;</span><br><span class="line">    TreeNode right &#x3D; null;</span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val &#x3D; val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; resultList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode nowNode &#x3D; q.peek();</span><br><span class="line">            q.poll();</span><br><span class="line">            resultList.add(nowNode.val);</span><br><span class="line">            if (nowNode.left !&#x3D; null) &#123;</span><br><span class="line">                q.add(nowNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (nowNode.right !&#x3D; null) &#123;</span><br><span class="line">                q.add(nowNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return resultList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-序列化和反序列化二叉树。（手写代码）"><a href="#7-序列化和反序列化二叉树。（手写代码）" class="headerlink" title="7.序列化和反序列化二叉树。（手写代码）"></a>7.序列化和反序列化二叉树。（手写代码）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;题目：请实现两个函数，分别用来序列化和反序列化二叉树。</span><br><span class="line"> </span><br><span class="line">public class SerializeBinaryTrees &#123;</span><br><span class="line">    public class TreeNode &#123;</span><br><span class="line">        int val &#x3D; 0;</span><br><span class="line">        TreeNode left &#x3D; null;</span><br><span class="line">        TreeNode right &#x3D; null;</span><br><span class="line"> </span><br><span class="line">        public TreeNode(int val) &#123;</span><br><span class="line">            this.val &#x3D; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    String Serialize(TreeNode node) &#123;</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            sb.append(&quot;$,&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sb.append(node.val + &quot;,&quot;);</span><br><span class="line">            sb.append(Serialize(node.left));</span><br><span class="line">            sb.append(Serialize(node.right));</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    int index &#x3D; 0;</span><br><span class="line">    TreeNode Deserialize(String str) &#123;</span><br><span class="line">        TreeNode node &#x3D; null;</span><br><span class="line">        if (str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D; 0)</span><br><span class="line">            return node;</span><br><span class="line">        int start &#x3D; index;</span><br><span class="line">        while (str.charAt(index) !&#x3D; &#39;,&#39;)</span><br><span class="line">            index++;</span><br><span class="line">        if (!str.substring(start, index).equals(&quot;$&quot;)) &#123;</span><br><span class="line">            node &#x3D; new TreeNode(Integer.parseInt(str.substring(start, index)));</span><br><span class="line">            index++; &#x2F;&#x2F; 这条语句位置别放错了</span><br><span class="line">            node.left &#x3D; Deserialize(str);</span><br><span class="line">            node.right &#x3D; Deserialize(str);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-最近公共祖先"><a href="#8-最近公共祖先" class="headerlink" title="8.最近公共祖先"></a>8.最近公共祖先</h4><p>有一棵无穷大的满二叉树，其结点按根结点一层一层地从左往右依次编号，根结点编号为1。现在有两个结点a，b。请设计一个算法，求出a和b点的最近公共祖先的编号。</p>
<p>给定两个int a,b。为给定结点的编号。请返回a和b的最近公共祖先的编号。注意这里结点本身也可认为是其祖先。</p>
<p>测试样例：<br>2，3</p>
<p>返回：<br>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：满二叉树的子节点与父节点之间的关系为root &#x3D; child &#x2F; 2</span><br><span class="line">&#x2F;&#x2F;利用这个关系，如果a ！&#x3D; b，就让其中的较大数除以2， 如此循环知道a &#x3D;&#x3D; b，</span><br><span class="line">&#x2F;&#x2F;即是原来两个数的最近公共祖先</span><br><span class="line">&#x2F;&#x2F;代码如下：</span><br><span class="line"> class LCA &#123;</span><br><span class="line">public:</span><br><span class="line">    int getLCA(int a, int b) &#123;</span><br><span class="line">        &#x2F;&#x2F; write code here</span><br><span class="line">        while(a !&#x3D; b)</span><br><span class="line">            &#123;</span><br><span class="line">            if(a &gt; b)</span><br><span class="line">                a &#x2F;&#x3D; 2;</span><br><span class="line">            else</span><br><span class="line">                b &#x2F;&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、堆和栈"><a href="#二、堆和栈" class="headerlink" title="二、堆和栈"></a>二、堆和栈</h3><h4 id="1-说一说你理解的stack-overflow，并举个简单例子导致栈溢出"><a href="#1-说一说你理解的stack-overflow，并举个简单例子导致栈溢出" class="headerlink" title="1.说一说你理解的stack overflow，并举个简单例子导致栈溢出"></a>1.说一说你理解的stack overflow，并举个简单例子导致栈溢出</h4><p>栈溢出概念：</p>
<p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。</p>
<p>栈溢出的原因：</p>
<ol>
<li><p>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）。</p>
</li>
<li><p>递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</p>
</li>
<li><p>指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</p>
</li>
</ol>
<h4 id="2-堆和栈的区别"><a href="#2-堆和栈的区别" class="headerlink" title="2.堆和栈的区别"></a>2.堆和栈的区别</h4><p>1）申请方式：<br>栈由系统自动分配和管理，堆由程序员手动分配和管理。</p>
<p>2）效率：</p>
<p>栈由系统分配，速度快，不会有内存碎片。</p>
<p>堆由程序员分配，速度较慢，可能由于操作不当产生内存碎片。</p>
<p>3）扩展方向</p>
<p>栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展。</p>
<p>4）程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间。</p>
<h4 id="3-大小根堆特点"><a href="#3-大小根堆特点" class="headerlink" title="3.大小根堆特点"></a>3.大小根堆特点</h4><p>堆是一棵完全二叉树（如果一共有h层，那么1~h-1层均满，在h层可能会连续缺失若干个右叶子）。</p>
<p>1）小根堆</p>
<p>若根节点存在左子女则根节点的值小于左子女的值；若根节点存在右子女则根节点的值小于右子女的值。</p>
<p>2）大根堆</p>
<p>若根节点存在左子女则根节点的值大于左子女的值；若根节点存在右子女则根节点的值大于右子女的值。</p>
<hr>
<p>堆和普通树的区别</p>
<p>堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。我们来看一下两者的主要差别：</p>
<p>节点的顺序。在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。</p>
<p>内存占用。普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额为是我内存。堆仅仅使用一个数据来存储数组，且不使用指针。</p>
<p>平衡。二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。</p>
<p>搜索。在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</p>
<h4 id="4-两个栈实现一个队列-和-用队列实现栈（手写代码）"><a href="#4-两个栈实现一个队列-和-用队列实现栈（手写代码）" class="headerlink" title="4.两个栈实现一个队列 和 用队列实现栈（手写代码）"></a>4.两个栈实现一个队列 和 用队列实现栈（手写代码）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"> </span><br><span class="line">	Stack&lt;Integer&gt; stack1 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">	Stack&lt;Integer&gt; stack2 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;进栈操作呢</span><br><span class="line">	public void appendTail(int item)&#123;</span><br><span class="line">		stack1.push(item);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;出栈操作</span><br><span class="line">	public int deleteHead()&#123;</span><br><span class="line">		while(!stack2.isEmpty())&#123;</span><br><span class="line">			return stack2.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		while(!stack1.isEmpty())&#123;</span><br><span class="line">			stack2.push(stack1.pop());</span><br><span class="line">		&#125;</span><br><span class="line">		return stack2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用队列实现栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">    Queue&lt;Integer&gt; que;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;** Initialize your data structure here. *&#x2F;</span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        que &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Push element x onto stack. *&#x2F;</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        que.add(x);</span><br><span class="line">        int num&#x3D;que.size();</span><br><span class="line">        while(num&gt;1)&#123;</span><br><span class="line">            que.add(que.poll());</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;</span><br><span class="line">    public int pop() &#123;       </span><br><span class="line">       return que.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Get the top element. *&#x2F;</span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return que.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Returns whether the stack is empty. *&#x2F;</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return que.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h3><h4 id="1-数组与链表的区别"><a href="#1-数组与链表的区别" class="headerlink" title="1.数组与链表的区别"></a>1.数组与链表的区别</h4><p>数组的优点：</p>
<ol>
<li><p>随机访问性强</p>
</li>
<li><p>查找速度快</p>
</li>
</ol>
<p>数组的缺点:</p>
<ol>
<li><p>插入和删除效率低</p>
</li>
<li><p>可能浪费内存</p>
</li>
<li><p>内存空间要求高，必须有足够的连续内存空间。</p>
</li>
<li><p>数组大小固定，不能动态拓展</p>
</li>
</ol>
<p>链表的优点:</p>
<ol>
<li><p>插入删除速度快</p>
</li>
<li><p>内存利用率高，不会浪费内存</p>
</li>
<li><p>大小没有固定，拓展很灵活。</p>
</li>
</ol>
<p>链表的缺点:</p>
<ol>
<li>不能随机查找，必须从第一个开始遍历，查找效率低</li>
</ol>
<h4 id="2-二分法"><a href="#2-二分法" class="headerlink" title="2.二分法"></a>2.二分法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int binary_search(T arr[], int n, T target) &#123;</span><br><span class="line">    int l &#x3D; 0, r &#x3D; n - 1;</span><br><span class="line">    while (l &lt;&#x3D; r) &#123;</span><br><span class="line">        int mid &#x3D; (r + l) &#x2F; 2; &#x2F;&#x2F; ☆</span><br><span class="line">        if (arr[mid] &#x3D; target) return mid;</span><br><span class="line">        if (target &gt; arr[mid]) l &#x3D; mid + 1;</span><br><span class="line">        else r &#x3D; mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、排序"><a href="#四、排序" class="headerlink" title="四、排序"></a>四、排序</h3><h4 id="1-各种排序算法及时间复杂度"><a href="#1-各种排序算法及时间复杂度" class="headerlink" title="1.各种排序算法及时间复杂度"></a>1.各种排序算法及时间复杂度</h4><p>插入排序：对于一个带排序数组来说，其初始有序数组元素个数为1，然后从第二个元素，插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插入的元素，则后移一位；如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前元素的下一位中。</p>
<p>希尔排序：先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关，其最后一个值必须为1.</p>
<p>归并排序：该算法采用分治法；对于包含m个元素的待排序序列，将其看成m个长度为1的子序列。然后两两合归并，得到n/2个长度为2或者1的有序子序列；然后再两两归并，直到得到1个长度为m的有序序列。</p>
<p>冒泡排序：对于包含n个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，若为逆序，则交换元素位置；然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前前n-i个元素中的最大的元素移到n-i位置。遍历n次，完成排序。</p>
<p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>选择排序：每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个元素交换位置，从而使有序数组元素加1，无序数组元素减1.初始时无序数组为空。</p>
<p>堆排序：堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数据构造一个最大堆（升序）/最小堆（降序），然后将堆顶元素与待排序数组的最后一个元素交换位置，此时末尾元素就是最大/最小的值。然后将剩余n-1个元素重新构造成最大堆/最小堆。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552474444160_93CF294B0FB45C83DC616C5700184F2E" alt></p>
<h4 id="2-稳定排序哪几种？"><a href="#2-稳定排序哪几种？" class="headerlink" title="2.稳定排序哪几种？"></a>2.稳定排序哪几种？</h4><p>基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序</p>
<h4 id="3-请问求第k大的数的方法以及各自的复杂度是怎样的？"><a href="#3-请问求第k大的数的方法以及各自的复杂度是怎样的？" class="headerlink" title="3.请问求第k大的数的方法以及各自的复杂度是怎样的？"></a>3.请问求第k大的数的方法以及各自的复杂度是怎样的？</h4><p>解法1： 我们可以对这个乱序数组按照从大到小先行排序，然后取出前k大，总的时间复杂度为O(n*logn + k)。</p>
<p>解法2： 利用快速排序的思想，从数组S中随机找出一个元素X，把数组分为两部分Sa和Sb。Sa中的元素大于等于X，Sb中元素小于X。这时有两种情况：</p>
<ol>
<li>Sa中元素的个数小于k，则Sb中的第k-|Sa|个元素即为第k大数；</li>
<li>Sa中元素的个数大于等于k，则返回Sa中的第k大数。时间复杂度近似为O(n)</li>
</ol>
<p>解法3：维护一个k大小的最小堆，对于数组中的每一个元素判断与堆顶的大小，若堆顶较大，则不管，否则，弹出堆顶，将当前值插入到堆中。时间复杂度O(n * logk)</p>
<p>解法4：利用hash保存数组中元素Si出现的次数，利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大数，平均情况下时间复杂度O(n)</p>
<h4 id="4-冒泡排序-手写代码-O-n-2"><a href="#4-冒泡排序-手写代码-O-n-2" class="headerlink" title="4.冒泡排序(手写代码) O(n^2)"></a>4.冒泡排序(手写代码) O(n^2)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void BubbleSort1(int [] arr)&#123;</span><br><span class="line"></span><br><span class="line">   int temp;&#x2F;&#x2F;临时变量</span><br><span class="line">   boolean flag;&#x2F;&#x2F;是否交换的标志</span><br><span class="line">   for(int i&#x3D;0; i&lt;arr.length-1; i++)&#123;   &#x2F;&#x2F;表示趟数，一共 arr.length-1 次</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 每次遍历标志位都要先置为false，才能判断后面的元素是否发生了交换</span><br><span class="line">       flag &#x3D; false;</span><br><span class="line">       </span><br><span class="line">       for(int j&#x3D;arr.length-1; j&gt;i; j--)&#123; &#x2F;&#x2F;选出该趟排序的最大值往后移动</span><br><span class="line"></span><br><span class="line">           if(arr[j] &lt; arr[j-1])&#123;</span><br><span class="line">               temp &#x3D; arr[j];</span><br><span class="line">               arr[j] &#x3D; arr[j-1];</span><br><span class="line">               arr[j-1] &#x3D; temp;</span><br><span class="line">               flag &#x3D; true;    &#x2F;&#x2F;只要有发生了交换，flag就置为true</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 判断标志位是否为false，如果为false，说明后面的元素已经有序，就直接return</span><br><span class="line">       if(!flag) break;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-选择排序-O-n-2"><a href="#5-选择排序-O-n-2" class="headerlink" title="5.选择排序 O(n^2)"></a>5.选择排序 O(n^2)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void select_sort(int array[],int lenth)&#123;</span><br><span class="line"></span><br><span class="line">   for(int i&#x3D;0;i&lt;lenth-1;i++)&#123;</span><br><span class="line"></span><br><span class="line">       int minIndex &#x3D; i;</span><br><span class="line">       for(int j&#x3D;i+1;j&lt;lenth;j++)&#123;</span><br><span class="line">          if(array[j]&lt;array[minIndex])&#123;</span><br><span class="line">              minIndex &#x3D; j;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if(minIndex !&#x3D; i)&#123;</span><br><span class="line">           int temp &#x3D; array[i];</span><br><span class="line">           array[i] &#x3D; array[minIndex];</span><br><span class="line">           array[minIndex] &#x3D; temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-快速排序（手写代码）O-Nlog2N"><a href="#6-快速排序（手写代码）O-Nlog2N" class="headerlink" title="6.快速排序（手写代码）O(Nlog2N)"></a>6.快速排序（手写代码）O(Nlog2N)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void quickSort(int a[],int l,int r)&#123;</span><br><span class="line">     if(l&gt;&#x3D;r)</span><br><span class="line">       return;</span><br><span class="line"></span><br><span class="line">     int i &#x3D; l; int j &#x3D; r; int key &#x3D; a[l];&#x2F;&#x2F;选择第一个数为key</span><br><span class="line"></span><br><span class="line">     while(i&lt;j)&#123;</span><br><span class="line"></span><br><span class="line">         while(i&lt;j &amp;&amp; a[j]&gt;&#x3D;key)&#x2F;&#x2F;从右向左找第一个小于key的值</span><br><span class="line">             j--;</span><br><span class="line">         if(i&lt;j)&#123;</span><br><span class="line">             a[i] &#x3D; a[j];</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         while(i&lt;j &amp;&amp; a[i]&lt;key)&#x2F;&#x2F;从左向右找第一个大于key的值</span><br><span class="line">             i++;</span><br><span class="line"></span><br><span class="line">         if(i&lt;j)&#123;</span><br><span class="line">             a[j] &#x3D; a[i];</span><br><span class="line">             j--;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;i &#x3D;&#x3D; j</span><br><span class="line">     a[i] &#x3D; key;</span><br><span class="line">     quickSort(a, l, i-1);&#x2F;&#x2F;递归调用</span><br><span class="line">     quickSort(a, i+1, r);&#x2F;&#x2F;递归调用</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-归并排序（手写代码）O-Nlog2N"><a href="#7-归并排序（手写代码）O-Nlog2N" class="headerlink" title="7.归并排序（手写代码）O(Nlog2N)"></a>7.归并排序（手写代码）O(Nlog2N)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void merge_sort(int a[],int first,int last,int temp[])&#123;</span><br><span class="line"></span><br><span class="line">  if(first &lt; last)&#123;</span><br><span class="line">      int middle &#x3D; (first + last)&#x2F;2;</span><br><span class="line">      merge_sort(a,first,middle,temp);&#x2F;&#x2F;左半部分排好序</span><br><span class="line">      merge_sort(a,middle+1,last,temp);&#x2F;&#x2F;右半部分排好序</span><br><span class="line">      mergeArray(a,first,middle,last,temp); &#x2F;&#x2F;合并左右部分</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;合并 ：将两个序列a[first-middle],a[middle+1-end]合并</span><br><span class="line">public static void mergeArray(int a[],int first,int middle,int end,int temp[])&#123;    </span><br><span class="line">  int i &#x3D; first;</span><br><span class="line">  int m &#x3D; middle;</span><br><span class="line">  int j &#x3D; middle+1;</span><br><span class="line">  int n &#x3D; end;</span><br><span class="line">  int k &#x3D; 0;</span><br><span class="line">  while(i&lt;&#x3D;m &amp;&amp; j&lt;&#x3D;n)&#123;</span><br><span class="line">      if(a[i] &lt;&#x3D; a[j])&#123;</span><br><span class="line">          temp[k] &#x3D; a[i];</span><br><span class="line">          k++;</span><br><span class="line">          i++;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">          temp[k] &#x3D; a[j];</span><br><span class="line">          k++;</span><br><span class="line">          j++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">  while(i&lt;&#x3D;m)&#123;</span><br><span class="line">      temp[k] &#x3D; a[i];</span><br><span class="line">      k++;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;    </span><br><span class="line">  while(j&lt;&#x3D;n)&#123;</span><br><span class="line">      temp[k] &#x3D; a[j];</span><br><span class="line">      k++;</span><br><span class="line">      j++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for(int ii&#x3D;0;ii&lt;k;ii++)&#123;</span><br><span class="line">      a[first + ii] &#x3D; temp[ii];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-堆排序O-Nlog2N"><a href="#8-堆排序O-Nlog2N" class="headerlink" title="8.堆排序O(Nlog2N)"></a>8.堆排序O(Nlog2N)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构建最小堆</span><br><span class="line">public static void MakeMinHeap(int a[], int n)&#123;</span><br><span class="line"> for(int i&#x3D;(n-1)&#x2F;2 ; i&gt;&#x3D;0 ; i--)&#123;</span><br><span class="line">     MinHeapFixdown(a,i,n);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2  </span><br><span class="line">public static void MinHeapFixdown(int a[],int i,int n)&#123;</span><br><span class="line"></span><br><span class="line">   int j &#x3D; 2*i+1; &#x2F;&#x2F;子节点</span><br><span class="line">   int temp &#x3D; 0;</span><br><span class="line"></span><br><span class="line">   while(j&lt;n)&#123;</span><br><span class="line">       &#x2F;&#x2F;在左右子节点中寻找最小的</span><br><span class="line">       if(j+1&lt;n &amp;&amp; a[j+1]&lt;a[j])&#123;  </span><br><span class="line">           j++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if(a[i] &lt;&#x3D; a[j])</span><br><span class="line">           break;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;较大节点下移</span><br><span class="line">       temp &#x3D; a[i];</span><br><span class="line">       a[i] &#x3D; a[j];</span><br><span class="line">       a[j] &#x3D; temp;</span><br><span class="line"></span><br><span class="line">       i &#x3D; j;</span><br><span class="line">       j &#x3D; 2*i+1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void MinHeap_Sort(int a[],int n)&#123;</span><br><span class="line">  int temp &#x3D; 0;</span><br><span class="line">  MakeMinHeap(a,n);</span><br><span class="line"></span><br><span class="line">  for(int i&#x3D;n-1;i&gt;0;i--)&#123;</span><br><span class="line">      temp &#x3D; a[0];</span><br><span class="line">      a[0] &#x3D; a[i];</span><br><span class="line">      a[i] &#x3D; temp;</span><br><span class="line">      MinHeapFixdown(a,0,i);</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、哈希"><a href="#五、哈希" class="headerlink" title="五、哈希"></a>五、哈希</h3><h4 id="1-hash表的实现"><a href="#1-hash表的实现" class="headerlink" title="1.hash表的实现"></a>1.hash表的实现</h4><p>（1）构造哈希</p>
<p>主要包括直接地址法、平方取中法、除留余数法等。</p>
<p>（2）处理哈希冲突</p>
<p>最常用的处理冲突的方法有开放定址法、再哈希法、链地址法、建立公共溢出区等方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开放定址法: 当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</span><br><span class="line"></span><br><span class="line">再哈希法：当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数。</span><br><span class="line"></span><br><span class="line">链地址法：将所有哈希值相同的Key通过链表存储。key按顺序插入到链表中</span><br><span class="line"></span><br><span class="line">建立公共溢出区：采用一个溢出表存储产生冲突的关键字。如果公共溢出区还产生冲突，再采用处理冲突方法处理。</span><br></pre></td></tr></table></figure>

<h4 id="2-哈希表的桶个数为什么是质数，合数有何不妥？"><a href="#2-哈希表的桶个数为什么是质数，合数有何不妥？" class="headerlink" title="2.哈希表的桶个数为什么是质数，合数有何不妥？"></a>2.哈希表的桶个数为什么是质数，合数有何不妥？</h4><p>哈希表的桶个数使用质数，可以最大程度减少冲突概率，使哈希后的数据分布的更加均匀。如果使用合数，可能会造成很多数据分布会集中在某些点上，从而影响哈希表效率。</p>
<h3 id="六、动态规划"><a href="#六、动态规划" class="headerlink" title="六、动态规划"></a>六、动态规划</h3><p>动态规划，利用问题的最优子结构性质，以自底向上的方式递归的从子问题的最优解逐步构造出整个问题的最优解。<br>对于重叠子问题，一个典型的问题是求斐波那契数列的第N项，如果用递归的方法做会存在大量的重叠子问题，而利用动态规划的方法就是解决了重叠子问题。<br>建立表格不断填表，相当于备忘录，也就是解决重叠子问题的技巧，典型的问题是斐波那契数列、背包问题等，许多动态规划问题都是定义数组，进行递推过程填充数组（模拟备忘录）。<br>马尔科夫性，是随机过程中某事件的发生只取决于它的上一事件、是“无记忆”过程。而动态规划具有“记忆性”。</p>
<h4 id="1-最长公共子序列（手写代码）"><a href="#1-最长公共子序列（手写代码）" class="headerlink" title="1.最长公共子序列（手写代码）"></a>1.最长公共子序列（手写代码）</h4><p>最长公共子序列问题： </p>
<p>给定两个字符串A、B，求A与B的最长公共子序列（子序列不要求是连续的）</p>
<p>举例：</p>
<p>字符串A： abcdef</p>
<p>字符串B：baaecd</p>
<p>输出：acd</p>
<p><img src="http://img.51nod.com/upload/000FBEAF/08D25D565D85EFF40000000000000002.jpeg" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class 最长公共子序列  &#123;</span><br><span class="line">    public  static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">        String str1&#x3D;input.next();</span><br><span class="line">        String str2&#x3D;input.next();</span><br><span class="line">        int m&#x3D;son(str1,str2);&#x2F;&#x2F;传两个字符串</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">    public  static  int  son(String str1,String str2)</span><br><span class="line">    &#123;</span><br><span class="line">    &#x2F;&#x2F;因为要形成上图的表格，所以给两个字符串头多添了一个字符</span><br><span class="line">    &#x2F;&#x2F;使第一行和第一列都变为0</span><br><span class="line">        String s1&#x3D;&quot;2&quot;+str1;</span><br><span class="line">        String s2&#x3D;&quot;1&quot;+str2;</span><br><span class="line">        int [][]check&#x3D;new int[str1.length()+1][str2.length()+1];</span><br><span class="line">        for(int i&#x3D;0;i&lt;s1.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;s2.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i&#x3D;&#x3D;0||j&#x3D;&#x3D;0)&#x2F;&#x2F;定义第一个格子为0</span><br><span class="line">                &#123;</span><br><span class="line">                    check[i][j]&#x3D;0;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(s1.charAt(i)&#x3D;&#x3D;s2.charAt(j))</span><br><span class="line">                &#123;</span><br><span class="line">                    check[i][j]&#x3D;(check[i-1][j-1]+1);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;  &#x2F;&#x2F;取上一个数和左边的数中大的数</span><br><span class="line">                    if(check[i-1][j]&gt;check[i][j-1])</span><br><span class="line">                        check[i][j]&#x3D;check[i-1][j];</span><br><span class="line">                    else</span><br><span class="line">                        check[i][j]&#x3D;check[i][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回数组的最后一位</span><br><span class="line">        return  check[s1.length()-1][s2.length()-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-最长公共子串"><a href="#2-最长公共子串" class="headerlink" title="2.最长公共子串"></a>2.最长公共子串</h4><p>对于两个字符串，请设计一个时间复杂度为O(m*n)的算法(这里的m和n为两串的长度)，求出两串的最长公共子串的长度。这里的最长公共子串的定义为两个序列U1,U2,..Un和V1,V2,…Vn，其中Ui + 1 == Ui+1,Vi + 1 == Vi+1，同时Ui == Vi。</p>
<p>给定两个字符串A和B，同时给定两串的长度n和m。</p>
<p>测试样例：<br>“1AB2345CD”,9,”12345EF”,7</p>
<p>返回：4</p>
<p><img src="https://img-blog.csdn.net/20140901134800948?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM5NzM2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string getLCS(string str1, string str2) &#123;</span><br><span class="line">	vector&lt;vector&lt;int&gt; &gt; record(str1.length(), vector&lt;int&gt;(str2.length()));</span><br><span class="line">	int maxLen &#x3D; 0, maxEnd &#x3D; 0;</span><br><span class="line">	for(int i&#x3D;0; i&lt;static_cast&lt;int&gt;(str1.length()); ++i)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; static_cast&lt;int&gt;(str2.length()); ++j) &#123;</span><br><span class="line">			if (str1[i] &#x3D;&#x3D; str2[j]) &#123;</span><br><span class="line">				if (i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0) &#123;</span><br><span class="line">					record[i][j] &#x3D; 1;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					record[i][j] &#x3D; record[i - 1][j - 1] + 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				record[i][j] &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">			if (record[i][j] &gt; maxLen) &#123;</span><br><span class="line">				maxLen &#x3D; record[i][j];</span><br><span class="line">				maxEnd &#x3D; i; &#x2F;&#x2F;若记录i,则最后获取LCS时是取str1的子串</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	return str1.substr(maxEnd - maxLen + 1, maxLen);</span><br></pre></td></tr></table></figure>
<h4 id="3-求一个字符串最长回文子串-手写代码"><a href="#3-求一个字符串最长回文子串-手写代码" class="headerlink" title="3.求一个字符串最长回文子串(手写代码)"></a>3.求一个字符串最长回文子串(手写代码)</h4><p>子串：小于等于原字符串长度由原字符串中任意个连续字符组成的子序列</p>
<p>回文：关于中间字符对称的文法，即“aba”(单核)、“cabbac”(双核)等</p>
<p>最长回文子串：1.寻找回文子串；2.该子串是回文子串中长度最长的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 求最长回文子串</span><br><span class="line"> * @author autumn_leaf</span><br><span class="line"> * @Date 2019&#x2F;03&#x2F;23</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PalindSubstring &#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">		while(sc.hasNext()) &#123;</span><br><span class="line">			String s &#x3D; sc.nextLine();</span><br><span class="line">			&#x2F;&#x2F;将一串字符转化为字符数组</span><br><span class="line">			char[] str &#x3D; s.toCharArray();</span><br><span class="line">			int len &#x3D; str.length;</span><br><span class="line">			int[][] dp &#x3D; new int[len+10][len+10];</span><br><span class="line">			&#x2F;&#x2F;dp数组初始化</span><br><span class="line">			for(int i&#x3D;0; i&lt;len; i++) &#123;</span><br><span class="line">				dp[i][i] &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;dp中相邻元素</span><br><span class="line">			for(int i&#x3D;0; i&lt;len-1; i++) &#123;</span><br><span class="line">				if(str[i] &#x3D;&#x3D; str[i+1]) &#123;</span><br><span class="line">					dp[i][i+1] &#x3D; 2;</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					dp[i][i+1] &#x3D; 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;**dp中至少相隔一个元素*&#x2F;</span><br><span class="line">			&#x2F;**k代表相隔的区间长度*&#x2F;</span><br><span class="line">			for(int k&#x3D;2; k&lt;len; k++) &#123;</span><br><span class="line">				&#x2F;&#x2F;i代表区间起始位置</span><br><span class="line">				for(int i&#x3D;0; i+k&lt;len; i++) &#123;</span><br><span class="line">					&#x2F;&#x2F;j代表区间末尾位置</span><br><span class="line">					int j &#x3D; i+k;</span><br><span class="line">					if(str[i] &#x3D;&#x3D; str[j]) &#123;</span><br><span class="line">						dp[i][j] &#x3D; dp[i+1][j-1] + 2;</span><br><span class="line">					&#125;else &#123;</span><br><span class="line">						dp[i][j] &#x3D;Math.max(dp[i+1][j], dp[i][j-1]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(dp[0][len-1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Manacher算法用一个辅助数组Len[i]表示以字符T[i]为中心的最长回文字串的最右字符到T[i]的长度，比如以T[i]为中心的最长回文字串是T[l,r],那么Len[i]=r-i+1。</p>
<p>对于上面的例子，可以得出Len[i]数组为:</p>
<p><img src="http://img.blog.csdn.net/20141221160159348" alt></p>
<p>Len数组有一个性质，那就是Len[i]-1就是该回文子串在原字符串S中的长度，至于证明，首先在转换得到的字符串T中，所有的回文字串的长度都为奇数，那么对于以T[i]为中心的最长回文字串，其长度就为2*Len[i]-1,经过观察可知，T中所有的回文子串，其中分隔符的数量一定比其他字符的数量多1，也就是有Len[i]个分隔符，剩下Len[i]-1个字符来自原字符串，所以该回文串在原字符串中的长度就为Len[i]-1。</p>
<p>有了这个性质，那么原问题就转化为求所有的Len[i]。下面介绍如何在线性时间复杂度内求出所有的Len。</p>
<h4 id="4-硬币表示"><a href="#4-硬币表示" class="headerlink" title="4.硬币表示"></a>4.硬币表示</h4><p>有数量不限的硬币，币值为25分、10分、5分和1分，请编写代码计算n分有几种表示法。</p>
<p>给定一个int n，请返回n分有几种表示法。保证n小于等于100000，为了防止溢出，请将答案Mod 1000000007。</p>
<p>测试样例：<br>6</p>
<p>返回：2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fun(int n, int coin)</span><br><span class="line">    &#123;</span><br><span class="line">        int nextcoin&#x3D;0;</span><br><span class="line">        switch(coin)</span><br><span class="line">        &#123;</span><br><span class="line">        case 25:</span><br><span class="line">            nextcoin&#x3D;10; break;</span><br><span class="line">        case 10:</span><br><span class="line">            nextcoin&#x3D;5; break;</span><br><span class="line">        case 5:</span><br><span class="line">            nextcoin&#x3D;1; break;</span><br><span class="line">        case 1:</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        int res&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i*coin&lt;&#x3D;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+&#x3D;fun(n-i*coin, nextcoin)%1000000007;</span><br><span class="line">        &#125;</span><br><span class="line">        return res%1000000007;&#x2F;&#x2F;%1000000007</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-字符混编"><a href="#5-字符混编" class="headerlink" title="5.字符混编"></a>5.字符混编</h4><p>A、B和C。如果C包含且仅包含来自A和B的所有字符，而且在C中属于A的字符之间保持原来在A中的顺序，属于B的字符之间保持原来在B中的顺序，那么称C是A和B的混编。实现一个函数，判断C是否是A和B的混编。</p>
<p>给定三个字符串A,B和C，及他们的长度。请返回一个bool值，代表C是否是A和B的混编。保证三个串的长度均小于等于100。</p>
<p>测试样例：<br>“ABC”,3,”12C”,3,”A12BCC”,6</p>
<p>返回：true</p>
<p><img src="http://uploadfiles.nowcoder.com/images/20150807/277064_1438943576180_1.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Mixture &#123;</span><br><span class="line">    public boolean chkMixture(String A, int n, String B, int m, String C, int v) &#123;</span><br><span class="line">        &#x2F;&#x2F; 边界情况处理</span><br><span class="line">        if (m + n !&#x3D; v)</span><br><span class="line">            return false;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F; 默认初始化为false</span><br><span class="line">        boolean[][] dp &#x3D; new boolean[101][101];</span><br><span class="line"> </span><br><span class="line">        dp[0][0] &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 初始化第0行</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;</span><br><span class="line">            if (B.charAt(i - 1) &#x3D;&#x3D; C.charAt(i - 1))</span><br><span class="line">                dp[0][i] &#x3D; true;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 初始化第0列</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">            if (A.charAt(i - 1) &#x3D;&#x3D; C.charAt(i - 1))</span><br><span class="line">                dp[i][0] &#x3D; true;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 状态转移方程</span><br><span class="line">         *  dp[i][j] &#x3D;</span><br><span class="line">         *</span><br><span class="line">         *  case 1: dp[i][j-1] &#x3D;&#x3D; true &amp;&amp; B[j-1] &#x3D;&#x3D; C[i+j-1]</span><br><span class="line">         * </span><br><span class="line">         *  case 2: dp[i-1][j] &#x3D;&#x3D; true &amp;&amp; A[i-1] &#x3D;&#x3D; C[i+j-1]</span><br><span class="line">         *</span><br><span class="line">         *&#x2F;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; m; ++j) &#123;</span><br><span class="line">                if (!dp[i][j]) &#123;</span><br><span class="line">                    &#x2F;&#x2F; dp[i-1][j] &#x3D; true &amp;&amp; A[i-1] &#x3D;&#x3D; C[i+j-1]</span><br><span class="line">                    if (dp[i - 1][j] &amp;&amp; A.charAt(i - 1) &#x3D;&#x3D; C.charAt(i + j - 1))</span><br><span class="line">                        dp[i][j] &#x3D; true;</span><br><span class="line"> </span><br><span class="line">                    &#x2F;&#x2F; dp[i][j-1] &#x3D;&#x3D; true &amp;&amp; B[j-1] &#x3D;&#x3D; C[i+j-1]</span><br><span class="line">                    if (dp[i][j - 1] &amp;&amp; B.charAt(j - 1) &#x3D;&#x3D; C.charAt(i + j - 1))</span><br><span class="line">                        dp[i][j] &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、链表"><a href="#七、链表" class="headerlink" title="七、链表"></a>七、链表</h3><h4 id="1-如何合并两个有序链表-手写代码"><a href="#1-如何合并两个有序链表-手写代码" class="headerlink" title="1.如何合并两个有序链表(手写代码)"></a>1.如何合并两个有序链表(手写代码)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*Definition for singly-linked list</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;递归</span><br><span class="line"></span><br><span class="line">class ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line"> </span><br><span class="line">    ListNode(int x)&#123;</span><br><span class="line">        val &#x3D; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        if (l1 &#x3D;&#x3D; null) return l2;</span><br><span class="line">        if (l2 &#x3D;&#x3D; null) return l1;</span><br><span class="line"> </span><br><span class="line">        ListNode head &#x3D; null;</span><br><span class="line">        if (l1.val &lt;&#x3D; l2.val)&#123;</span><br><span class="line">            head &#x3D; l1;</span><br><span class="line">            head.next &#x3D; mergeTwoLists(l1.next, l2);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head &#x3D; l2;</span><br><span class="line">            head.next &#x3D; mergeTwoLists(l1, l2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-反转链表（手写代码）"><a href="#2-反转链表（手写代码）" class="headerlink" title="2.反转链表（手写代码）"></a>2.反转链表（手写代码）</h4><p>递归</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Node reverse(Node head) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null)</span><br><span class="line">        return head;</span><br><span class="line">    Node temp &#x3D; head.next;</span><br><span class="line">    Node newHead &#x3D; reverse(head.next);</span><br><span class="line">    temp.next &#x3D; head;</span><br><span class="line">    head.next &#x3D; null;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Node reverseList(Node node) &#123;</span><br><span class="line">    Node pre &#x3D; null;</span><br><span class="line">    Node next &#x3D; null;</span><br><span class="line">    while (node !&#x3D; null) &#123;</span><br><span class="line">        next &#x3D; node.next;</span><br><span class="line">        node.next &#x3D; pre;</span><br><span class="line">        pre &#x3D; node;</span><br><span class="line">        node &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-判断一个链表是否为回文链表，说出你的思路并手写代码"><a href="#3-判断一个链表是否为回文链表，说出你的思路并手写代码" class="headerlink" title="3.判断一个链表是否为回文链表，说出你的思路并手写代码"></a>3.判断一个链表是否为回文链表，说出你的思路并手写代码</h4><ol>
<li>简单粗暴的做法就是：将链表反转生成一个新的链表，然后依次比较两个链表的每一个元素，如果均相等则是回文结构。这里我们可以不用反转链表，而是借助一个栈，将链表的数据全部压入栈中，然后从栈顶依次取出元素和原链表头部取出元素比较。栈的特点是先进后出，正好可以构成一个反转的链表。<br><img src="https://img-blog.csdnimg.cn/20190702222955833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlaW5pZmk=,size_16,color_FFFFFF,t_70" alt></li>
<li>根据回文结构的特点，链表前半部分和后半部分反转之后顺序是一致的，所以可以考虑不用反转整个链表，而是后半部分。要找到后半部分，需要两个指针，他们都从头部开始遍历，一个指针遍历的速度是另一个指针的两倍，这样，当快的指针遍历完成的时候，慢的指针位置就正好是中间位置。再把中间位置到链表尾部的所有节点放入一个堆栈，构成一个反转的链表，后面的判断就回到第一个办法的判断了。<br><img src="https://img-blog.csdnimg.cn/20190702223336946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlaW5pZmk=,size_16,color_FFFFFF,t_70" alt></li>
</ol>
<h4 id="4-如何判断两个单向链表是否相交"><a href="#4-如何判断两个单向链表是否相交" class="headerlink" title="4.如何判断两个单向链表是否相交"></a>4.如何判断两个单向链表是否相交</h4><p>判断两个链表是否相交</p>
<p>1）方法1：</p>
<p>链表相交之后，后面的部分节点全部共用，可以用2个指针分别从这两个链表头部走到尾部，最后判断尾部指针的地址信息是否一样，若一样则代表链表相交！</p>
<p>2）方法2：</p>
<p>可以把其中一个链表的所有节点地址信息存到数组中，然后把另一个链表的每一个节点地址信息遍历数组，若相等，则跳出循环，说明链表相交。进一步优化则是进行hash排序，建立hash表。</p>
<h3 id="八、高级算法"><a href="#八、高级算法" class="headerlink" title="八、高级算法"></a>八、高级算法</h3><h4 id="1-单向加密"><a href="#1-单向加密" class="headerlink" title="1.单向加密"></a>1.单向加密</h4><p>1）定义</p>
<p>单向加密又称为不可逆加密算法，其密钥是由加密散列函数生成的。</p>
<p>2）例子</p>
<ul>
<li><p>MD5（Message Digest Algorithm 5）：是RSA数据安全公司开发的一种单向散列算法，非可逆，相同的明文产生相同的密文；</p>
</li>
<li><p>SHA（Secure Hash Algorithm）：可以对任意长度的数据运算生成一个160位的数值。其变种由SHA192，SHA256，SHA384等；</p>
</li>
</ul>
<p>3）算法特征：</p>
<p>输入一样，输出必然相同；</p>
<p>雪崩效应，输入的微小改变，将会引起结果的巨大变化；</p>
<p>定长输出，无论原始数据多大，结果大小都是相同的；</p>
<p>不可逆，无法根据特征码还原原来的数据；</p>
<h4 id="2-对称加密"><a href="#2-对称加密" class="headerlink" title="2.对称加密"></a>2.对称加密</h4><p>采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。</p>
<p>特点：</p>
<p>1、加密方和解密方使用同一个密钥；</p>
<p>2、加密解密的速度比较快，适合数据比较长时的使用；</p>
<p>3、密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦；</p>
<p>优点：对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。</p>
<p>缺点：对称加密算法的缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p>
<h4 id="3-非对称加密"><a href="#3-非对称加密" class="headerlink" title="3.非对称加密"></a>3.非对称加密</h4><p>非对称密钥加密也称为公钥加密，由一对公钥和私钥组成。公钥是从私钥提取出来的。可以用公钥加密，再用私钥解密，这种情形一般用于公钥加密，当然也可以用私钥加密，用公钥解密。常用于数字签名，因此非对称加密的主要功能就是加密和数字签名。</p>
<p>特征：</p>
<p>1）秘钥对，公钥(public key)和私钥(secret key)</p>
<p>2）主要功能：加密和签名</p>
<p>发送方用对方的公钥加密，可以保证数据的机密性（公钥加密）。</p>
<p>发送方用自己的私钥加密，可以实现身份验证（数字签名）。</p>
<p>3）公钥加密算法很少用来加密数据，速度太慢，通常用来实现身份验证。</p>
<p>常用的非对称加密算法</p>
<p>RSA：由 RSA公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；既可以实现加密，又可以实现签名。</p>
<p>DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准）。</p>
<p>ECC（Elliptic Curves Cryptography）：椭圆曲线密码编码。</p>
<h4 id="4-LRU缓存"><a href="#4-LRU缓存" class="headerlink" title="4.LRU缓存"></a>4.LRU缓存</h4><p>LRU(最近最少使用)算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高</p>
<p>实现：使用一个链表保存缓存数据，将新数据插入到头部，每当缓存命中时，则将命中的数据移动到链表头部，当链表满的时候，将链表尾部的数据丢弃。</p>
<h3 id="九、字符串处理"><a href="#九、字符串处理" class="headerlink" title="九、字符串处理"></a>九、字符串处理</h3><h4 id="1-给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c"><a href="#1-给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c" class="headerlink" title="1.给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c"></a>1.给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c</h4><p>使用哈希的思想，建立256个bool数组array，初始都为false,从头开始扫描字符串，扫到一个，将以其ascii码为下标的元素置true。例如扫描到A的时候，执行：array[‘A’]=true。第二边扫描，扫到一个字母就以其ascii码为下标，去array数组中看其值，如果是true,返回改字母，如果是false，继续扫描下一个字母。</p>
<h3 id="十、贪心算法"><a href="#十、贪心算法" class="headerlink" title="十、贪心算法"></a>十、贪心算法</h3><h4 id="1-安置路灯"><a href="#1-安置路灯" class="headerlink" title="1.安置路灯"></a>1.安置路灯</h4><p>小Q正在给一条长度为n的道路设计路灯安置方案。</p>
<p>为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用’.’表示, 不需要照亮的障碍物格子用’X’表示。</p>
<p>小Q现在要在道路上设置一些路灯, 对于安置在pos位置的路灯, 这盏路灯可以照亮pos - 1, pos, pos + 1这三个位置。</p>
<p>小Q希望能安置尽量少的路灯照亮所有’.’区域, 希望你能帮他计算一下最少需要多少盏路灯。</p>
<p>输入描述:<br>输入的第一行包含一个正整数t(1 &lt;= t &lt;= 1000), 表示测试用例数<br>接下来每两行一个测试数据, 第一行一个正整数n(1 &lt;= n &lt;= 1000),表示道路的长度。<br>第二行一个字符串s表示道路的构造,只包含’.’和’X’。</p>
<p>输出描述:<br>对于每个测试用例, 输出一个正整数表示最少需要多少盏路灯。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        String string &#x3D; scanner.nextLine();</span><br><span class="line">        int caseNumber &#x3D; Integer.parseInt(string);</span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String nString &#x3D; scanner.nextLine();</span><br><span class="line">            int n &#x3D; Integer.parseInt(nString);</span><br><span class="line"></span><br><span class="line">            String road &#x3D; scanner.nextLine();</span><br><span class="line"></span><br><span class="line">            int result &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">                if (road.substring(i,i+1).equals(&quot;.&quot;))&#123;</span><br><span class="line">                    result++;</span><br><span class="line">                    i+&#x3D;2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(result);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="十一、实战题目"><a href="#十一、实战题目" class="headerlink" title="十一、实战题目"></a>十一、实战题目</h3><h4 id="1-九宫格解锁方案（Vivo）"><a href="#1-九宫格解锁方案（Vivo）" class="headerlink" title="1.九宫格解锁方案（Vivo）"></a>1.九宫格解锁方案（Vivo）</h4><p>1、问题定义</p>
<p>问题很简单：安卓的手势解锁是3*3的点阵，在这个点阵上的解锁手势一共有多少种情况？这里一个合格的解锁手势轨迹必须满足以下两个条件：</p>
<ul>
<li>至少连接点阵中的四个点。</li>
<li>手势的轨迹不能跨过一个还没有经过的节点。</li>
<li>不允许重复经过某个定点两次。</li>
</ul>
<p>2、问题转化</p>
<p>为了方便，这里将点阵中的每个点用一个数字代替，1到9九个数字分别代表点阵中的一个点。这样，一个解锁手势可以对应到一个由1到9数字组成的字符串(该字符串中没有重复)。</p>
<p>去掉第二个限制条件，一种解锁手势正好对应一种1到9的排列。连接四个点的解锁手势的所有情况就是9选4的全排列，连接5个点的就是9选5的全排列，以此类推。</p>
<p>计算全排列的比较容易，接下来要解决的就是如何剔除那些不符合限制条件(手势的轨迹不能跨过一个还没有经过的节点)的手势。在3*3的点阵中，不符合条件的情况(也就是两个点的连接过程中跨过点的情况)比较有限，这里我们将其全部列出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from itertools import chain, permutations</span><br><span class="line"></span><br><span class="line">impossible &#x3D; &#123;&#39;13&#39;: &#39;2&#39;, &#39;46&#39;: &#39;5&#39;, &#39;79&#39;: &#39;8&#39;, &#39;17&#39;: &#39;4&#39;, &#39;28&#39;: &#39;5&#39;, &#39;39&#39;: &#39;6&#39;, &#39;19&#39;: &#39;5&#39;, &#39;37&#39;: &#39;5&#39;, &#39;31&#39;: &#39;2&#39;, &#39;64&#39;: &#39;5&#39;, &#39;97&#39;: &#39;8&#39;, &#39;71&#39;: &#39;4&#39;, &#39;82&#39;: &#39;5&#39;, &#39;93&#39;: &#39;6&#39;, &#39;91&#39;: &#39;5&#39;, &#39;73&#39;: &#39;5&#39;&#125;</span><br><span class="line"></span><br><span class="line">def counts_n(n):</span><br><span class="line">        iterlst &#x3D; permutations(&#39;123456789&#39;, n)</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        for i in iterlst:</span><br><span class="line">                stri &#x3D; &#39;&#39;.join(i)</span><br><span class="line">                for k, v in impossible.items():</span><br><span class="line">                        if k in stri and v not in stri[:stri.find(k)]:</span><br><span class="line">                                break</span><br><span class="line">                else: </span><br><span class="line">                        count +&#x3D; 1</span><br><span class="line">        return count</span><br><span class="line">   </span><br><span class="line">sum &#x3D; 0  </span><br><span class="line">print(&quot;len  num  sum&quot;)</span><br><span class="line">for i in range(4,10):</span><br><span class="line">        temp &#x3D; counts_n(i)</span><br><span class="line">        sum &#x3D; sum + temp</span><br><span class="line">        print(str(i)+&quot;  &quot;+str(temp)+&quot;  &quot;+str(sum))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len  num  sum</span><br><span class="line">4  1624  1624</span><br><span class="line">5  7152  8776</span><br><span class="line">6  26016  34792</span><br><span class="line">7  72912  107704</span><br><span class="line">8  140704  248408</span><br><span class="line">9  140704  389112</span><br></pre></td></tr></table></figure>

<h4 id="2-爬楼梯算法"><a href="#2-爬楼梯算法" class="headerlink" title="2.爬楼梯算法"></a>2.爬楼梯算法</h4><p>第一种题目（递归实现）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设一个楼梯有 N 阶台阶，人每次最多可以跨 M 阶，求总共的爬楼梯方案数。</span><br><span class="line"></span><br><span class="line">例如楼梯总共有3个台阶，人每次最多跨2个台阶，也就是说人每次可以走1个，也可以走2个，但最多不会超过2个，那么楼梯总共有这么几种走法：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int calculateCount(int ladder, int maxJump) &#123;</span><br><span class="line">    int jump &#x3D; 0;</span><br><span class="line">    if (ladder &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ladder &gt;&#x3D; maxJump) &#123;</span><br><span class="line">        &#x2F;&#x2F; 剩下的楼梯大于最大可跳跃数</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; maxJump; i++) &#123;</span><br><span class="line">            jump +&#x3D; calculateCount(ladder - i, maxJump);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 剩下的楼梯不足最大可跳跃数</span><br><span class="line">        jump &#x3D; calculateCount(ladder, ladder);</span><br><span class="line">    &#125;</span><br><span class="line">    return jump;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题有一道变体（非递归方式实现）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设一个楼梯有 N 阶台阶，人每次最多可以跨 2 阶，求总共的爬楼梯方案数，要求不用递归实现</span><br></pre></td></tr></table></figure>

<p>随着楼梯数n的增加，爬法总数呈现斐波那契数列规律增加，即f（n） = f（n-1） + f（n-2）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param ladder 台阶数量</span><br><span class="line"> * @return 总的爬法</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int count(int ladder) &#123;</span><br><span class="line">    if (ladder &#x3D;&#x3D; 1 || ladder &#x3D;&#x3D; 2) &#123;</span><br><span class="line">        return ladder;</span><br><span class="line">    &#125;</span><br><span class="line">    int n1 &#x3D; 1;</span><br><span class="line">    int n2 &#x3D; 2;</span><br><span class="line">    for (int i &#x3D; 3; i &lt;&#x3D; ladder; i++) &#123;</span><br><span class="line">        int tmp &#x3D; n2;</span><br><span class="line">        n2 &#x3D; n1 + n2;</span><br><span class="line">        n1 &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-两数之和"><a href="#3-两数之和" class="headerlink" title="3.两数之和"></a>3.两数之和</h4><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>1.解法一：使用for循环遍历</p>
<p>2.解法二：使用HashMap的性质</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if (map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                return new int[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三数之和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     *      时间复杂度：n2</span><br><span class="line">     *      空间复杂度：1</span><br><span class="line">     * 代码执行过程：</span><br><span class="line">     *</span><br><span class="line">     * 总结：</span><br><span class="line">     *</span><br><span class="line">     * ***********************************&#x2F;</span><br><span class="line">public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line"></span><br><span class="line">    if (nums &#x3D;&#x3D; null || nums.length &lt; 3) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">    int comp &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    int result &#x3D; Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果和之前那个数据相同，则会是重复事件</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int leftIndex &#x3D; i + 1;</span><br><span class="line">        int rightIndex &#x3D; nums.length - 1;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 滑动列表</span><br><span class="line">        while (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">            int tmp &#x3D; nums[leftIndex] + nums[rightIndex] + nums[i];</span><br><span class="line">            if (comp &gt; Math.abs(tmp - target)) &#123;</span><br><span class="line">                comp &#x3D; Math.abs(tmp - target);</span><br><span class="line">                result &#x3D; tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (tmp &gt; target) &#123;</span><br><span class="line">                rightIndex--;</span><br><span class="line">            &#125; else if (tmp &lt; target) &#123;</span><br><span class="line">                leftIndex++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 差值为0，最爽了，直接返回</span><br><span class="line">                return tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-最大回撤"><a href="#4-最大回撤" class="headerlink" title="4.最大回撤"></a>4.最大回撤</h4><p>题目形式：有一个数组，求其中两个数x,y，满足x的索引小于y的索引，使得 x-y 最大。例如 arr = [3,7,2,6,4,1,9,8,5]， 最大回撤是6，对应的x=7,y=1。</p>
<p>解法一</p>
<p>算法实现有很多，简单粗暴的方法比如把每一天的值和其他天作差值计算，找到差值最大的那一天，但这个方法并不好。从时间复杂度上看是O(n!)，差不多算是最差的了。</p>
<p>解法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 计算最大回撤</span><br><span class="line"> * </span><br><span class="line"> * @author qcy</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">class FundTools &#123;</span><br><span class="line"> </span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 由净值序列x，直接计算最大回撤</span><br><span class="line">	 * </span><br><span class="line">	 * @param x</span><br><span class="line">	 *            累计份额净值序列</span><br><span class="line">	 * @return 最大回撤</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public double calc_max_dd(double[] x) &#123;</span><br><span class="line">		double max_unit_value &#x3D; x[0];</span><br><span class="line">		double max_dd &#x3D; 0;</span><br><span class="line">		double dd &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">		for (int i &#x3D; 1; i &lt; x.length; i++) &#123;</span><br><span class="line">			max_unit_value &#x3D; Math.max(x[i], max_unit_value);</span><br><span class="line">			dd &#x3D; x[i] &#x2F; max_unit_value - 1;</span><br><span class="line">			max_dd &#x3D; Math.min(dd, max_dd);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		return max_dd;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 根据每日收盘后份额净值和截止前一日的最大回撤、最高水位，计算今日的最大回撤</span><br><span class="line">	 * </span><br><span class="line">	 * @param max_dd</span><br><span class="line">	 *            截止到i-1日的最大回撤</span><br><span class="line">	 * @param max_unit_value</span><br><span class="line">	 *            截止到i-1日的最高累计份额净值</span><br><span class="line">	 * @param today_unit_value</span><br><span class="line">	 *            i日的累计份额净值</span><br><span class="line">	 * @return 第i日的最大回撤</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public double calc_max_dd(double max_dd, double max_unit_value,</span><br><span class="line">			double today_unit_value) &#123;</span><br><span class="line">		max_unit_value &#x3D; Math.max(max_unit_value, today_unit_value);</span><br><span class="line">		double dd &#x3D; today_unit_value &#x2F; max_unit_value - 1;</span><br><span class="line">		return Math.min(dd, max_dd);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-合并两个有序数组"><a href="#5-合并两个有序数组" class="headerlink" title="5.合并两个有序数组"></a>5.合并两个有序数组</h4><p>题目形式：</p>
<p>给定两个按升序排列的有序数组，将它们合并成一个新的有序数组。例如：a = [1,2,6,8], b = [2,4,7,10]，输出为 arr = [1,2,2,4,6,7,8,10]</p>
<p>解法一：开个新的数组，填充上去</p>
<p>解法二：因原数组都是有序数组，只需要从两个数组的最后一个元素开始对比，寻找最大值赋值给最终数组。</p>
<p>如果数组二元素耗尽，则得到最终数组。<br>如果数组一元素耗尽，则需要将原数组二剩余元素赋值给最终数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        if(m &#x3D;&#x3D;0 ) &#123;</span><br><span class="line">            System.arraycopy(nums2,0,nums1,0, n);</span><br><span class="line">        &#125;</span><br><span class="line">        int i1 &#x3D; m -1;</span><br><span class="line">        int i2 &#x3D; n -1;</span><br><span class="line">        while(i2&gt;&#x3D;0)&#123;</span><br><span class="line">            if(i1 &lt; 0)&#123;</span><br><span class="line">                System.arraycopy(nums2,0,nums1,0,i2+1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums1[i1] &gt;&#x3D; nums2[i2]) &#123;</span><br><span class="line">                nums1[i1 + i2 +1]&#x3D;nums1[i1--];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                nums1[i1 + i2 +1]&#x3D;nums2[i2--];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-最大连续子数组和"><a href="#6-最大连续子数组和" class="headerlink" title="6.最大连续子数组和"></a>6.最大连续子数组和</h4><p>题目形式：</p>
<p>给定一个数组，求其最大连续子数组的和。例如：arr = [1,5,-10,2,5,-3,2,6,-3,1]. 输出为：12。对应的连续子数组为 [2,5,-3,2,6]。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int maxSunArray(int[] array) &#123;</span><br><span class="line">       if (array.length&#x3D;&#x3D;0 || array&#x3D;&#x3D;null) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">      int Sum &#x3D; 0;     </span><br><span class="line">      int max &#x3D; 0;            </span><br><span class="line">      for (int i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">          </span><br><span class="line">          if(Sum&lt;&#x3D;0)&#123;      &#x2F;&#x2F;如果当前连续n项的和小于等于0,则没必要与后面的元素相加</span><br><span class="line">              Sum &#x3D; array[i];      &#x2F;&#x2F;Sum重新赋值</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">              Sum +&#x3D; array[i];     &#x2F;&#x2F;如果Sum的值大于0,则继续与后面的元素相加,</span><br><span class="line">          &#125;</span><br><span class="line">          if(Sum&gt;max)&#123;         &#x2F;&#x2F;每次改变Sum的值都有与max进行比较</span><br><span class="line">              max &#x3D; Sum;       &#x2F;&#x2F;如果Sum的值大于max,则将Sum的值赋值给max</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>动态规划</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;解法二：使用动态规划:</span><br><span class="line">&#x2F;&#x2F;F（i）：以array[i]为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变</span><br><span class="line">&#x2F;&#x2F;F（i）&#x3D;max（F（i-1）+array[i] ， array[i]）</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public  int FindGreatestSumOfSubArray(int[] array) &#123;</span><br><span class="line">            int res &#x3D; array[0]; &#x2F;&#x2F;记录当前所有子数组的和的最大值</span><br><span class="line">            int max &#x3D; array[0]; &#x2F;&#x2F;包含array[i]的连续数组最大值</span><br><span class="line">            for (int i &#x3D; 1; i &lt; array.length; i++) &#123;</span><br><span class="line">                 max&#x3D;Math.max(max+array[i], array[i]);</span><br><span class="line">                 res&#x3D;Math.max(max, res);</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-最长不重复子串"><a href="#7-最长不重复子串" class="headerlink" title="7.最长不重复子串"></a>7.最长不重复子串</h4><p>题目形式：</p>
<p>给定一个字符串，找出没有重复字符的最长的子串。例如输入“abcbefgf”，答案是 “cbefg”。</p>
<p>我的方法：（时间复杂度较大）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int start, end;</span><br><span class="line">        String count &#x3D; &quot;&quot;;</span><br><span class="line">        String str &#x3D; &quot;&quot;;</span><br><span class="line">        for(start&#x3D;0; start&lt;s.length(); start++)&#123;</span><br><span class="line">            for(end&#x3D;start+1; end&lt;&#x3D;s.length(); end++)&#123;</span><br><span class="line">                str &#x3D; s.substring(start, end);</span><br><span class="line">                if(end &#x3D;&#x3D; s.length())&#123;</span><br><span class="line">                    if(count.length() &lt; str.length())&#123;&#x2F;&#x2F;对比长度</span><br><span class="line">                        count &#x3D; str;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(str.contains(s.substring(end, end+1)))&#123;&#x2F;&#x2F;当有重复时候，处理，跳出循环让start++</span><br><span class="line">                        if(count.length() &lt; str.length())&#123;&#x2F;&#x2F;对比长度</span><br><span class="line">                            count &#x3D; str;</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2、滑动窗口思想：如果确定子串s[i,j]（假设表示字符串的第i个字符到第j-1个字符表示的子串），那么只需要比较s[j]是否与子串s[i,j]重复即可</p>
<p>若重复：记录此时滑动窗口大小，并与最大滑动窗口比较，赋值。然后滑动窗口大小重定义为1，头位置不变，并右移一个单位。</p>
<p>若不重复：滑动窗口头不变，结尾+1，整个窗口加大1个单位。继续比较下一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int n &#x3D; s.length();</span><br><span class="line">        Set&lt;Character&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        int ans &#x3D; 0, i &#x3D; 0, j &#x3D; 0;</span><br><span class="line">        while (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            &#x2F;&#x2F; try to extend the range [i, j]</span><br><span class="line">            if (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans &#x3D; Math.max(ans, j - i);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                set.remove(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用HashMap(这是一道动态规划+哈希查找的综合应用题)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int n &#x3D; s.length(), ans &#x3D; 0;</span><br><span class="line">        Map&lt;Character, Integer&gt; map &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F; current index of character</span><br><span class="line">        &#x2F;&#x2F; try to extend the range [i, j]</span><br><span class="line">        for (int j &#x3D; 0, i &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i &#x3D; Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            ans &#x3D; Math.max(ans, j - i + 1);</span><br><span class="line">            map.put(s.charAt(j), j + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-全排列-这是一道动态规划-排列组合的综合应用题"><a href="#8-全排列-这是一道动态规划-排列组合的综合应用题" class="headerlink" title="8.全排列(这是一道动态规划+排列组合的综合应用题)"></a>8.全排列(这是一道动态规划+排列组合的综合应用题)</h4><p>题目形式：</p>
<p>给定一个数组，找出其所有可能的排列。例如: arr = [1,1,3]，输出为 [[1,1,3],[1,3,1],[3,1,1]]。</p>
<p>（1）确定第一位的字符<br>数组arr从start到end的所有记录都可以出现在第一个位置，所以直接一个for循环，考虑了这所有的情况。在for循环中，swap方法就是交换i和start位置的数，保证当前i指向的记录出现在第一个位置，也就是start指向的位置</p>
<p>（2）剩下的记录继续做全排列<br>这个就是一个递归函数的调用，只需要修改起始位置，也就是start+1，因为start的位置已经放了记录，所以只需要继续做从start+1到end的全排列即可<br>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123; 1, 2, 3, 4 &#125;;</span><br><span class="line">        fullSort(arr, 0, arr.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void fullSort(int[] arr, int start, int end) &#123;</span><br><span class="line">        &#x2F;&#x2F; 递归终止条件</span><br><span class="line">        if (start &#x3D;&#x3D; end) &#123;</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; start; i &lt;&#x3D; end; i++) &#123;</span><br><span class="line">            swap(arr, i, start);</span><br><span class="line">            fullSort(arr, start + 1, end);</span><br><span class="line">            swap(arr, i, start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int tmp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展应用：图书排列</p>
<p>题目描述：将编号为1~10的10本书排放在书架上，要求编号相邻的书不能放在相邻的位置。<br>请计算一共有多少种不同的排列方案。</p>
<p>注意，需要提交的是一个整数，不要填写任何多余的内容。</p>
<p>解题思路：这个题目有很多解法，这里只说明用全排列怎么解决，先求出全排列，也就是所有的排列方案，然后去掉不满足条件的情况，也就是编号相邻的书不能相邻这一条件。</p>
<p>完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BookSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] &#x3D; &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;</span><br><span class="line">        fullSort(arr, 0, arr.length - 1);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int res &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    static void fullSort(int[] arr, int start, int end) &#123;</span><br><span class="line">        &#x2F;&#x2F; 递归终止条件</span><br><span class="line">        if (start &#x3D;&#x3D; end) &#123;</span><br><span class="line">            &#x2F;&#x2F; 求出了全排列的一种情况，然后检查是否满足条件</span><br><span class="line">            if (check(arr))</span><br><span class="line">                res++;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; start; i &lt;&#x3D; end; i++) &#123;</span><br><span class="line">            swap(arr, start, i);</span><br><span class="line">            fullSort(arr, start + 1, end);</span><br><span class="line">            swap(arr, start, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int tmp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static boolean check(int[] arr) &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (Math.abs(arr[i] - arr[i - 1]) &#x3D;&#x3D; 1)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-穷举法"><a href="#9-穷举法" class="headerlink" title="9.穷举法"></a>9.穷举法</h4><p>平面内有n个矩形, 第i个矩形的左下角坐标为(x1[i], y1[i]), 右上角坐标为(x2[i], y2[i])。<br>如果两个或者多个矩形有公共区域则认为它们是相互重叠的(不考虑边界和角落)。<br>请你计算出平面内重叠矩形数量最多的地方,有多少个矩形相互重叠。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args) throws IOException&#123;</span><br><span class="line">        BufferedReader bf &#x3D; new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        int num &#x3D; Integer.parseInt(bf.readLine());</span><br><span class="line">        int [] x1 &#x3D; new int[num];</span><br><span class="line">        int [] y1 &#x3D; new int[num];</span><br><span class="line">        int [] x2 &#x3D; new int[num];</span><br><span class="line">        int [] y2 &#x3D; new int[num];</span><br><span class="line">        if(num &lt; 2 || num &gt; 50)</span><br><span class="line">            return;</span><br><span class="line">        else&#123;</span><br><span class="line">            String [] str &#x3D; bf.readLine().split(&quot; +&quot;);</span><br><span class="line">            for(int i &#x3D; 0;i&lt;num;i++)&#123;</span><br><span class="line">                x1[i] &#x3D; Integer.parseInt(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            str &#x3D; bf.readLine().split(&quot; +&quot;);</span><br><span class="line">            for(int i &#x3D; 0;i&lt;num;i++)&#123;</span><br><span class="line">                y1[i] &#x3D; Integer.parseInt(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            str &#x3D; bf.readLine().split(&quot; +&quot;);</span><br><span class="line">            for(int i &#x3D; 0;i&lt;num;i++)&#123;</span><br><span class="line">                x2[i] &#x3D; Integer.parseInt(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            str &#x3D; bf.readLine().split(&quot; +&quot;);</span><br><span class="line">            for(int i &#x3D; 0;i&lt;num;i++)&#123;</span><br><span class="line">                y2[i] &#x3D; Integer.parseInt(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(solution(num,x1,y1,x2,y2));</span><br><span class="line">    &#125;</span><br><span class="line">    public static int solution(int num,int[]x1,int[]y1,int[]x2,int[]y2)&#123;</span><br><span class="line">        int temp&#x3D;0,max&#x3D;0;</span><br><span class="line">        for(int x:x1)</span><br><span class="line">            for(int y:y1)&#123;</span><br><span class="line">                for(int i &#x3D; 0; i&lt;num ; i++)&#123;</span><br><span class="line">                    if(x&gt;&#x3D;x1[i] &amp;&amp; x&lt;x2[i]&amp;&amp; y&gt;&#x3D;y1[i]&amp;&amp;y&lt;y2[i])</span><br><span class="line">                        temp++;</span><br><span class="line">                &#125;</span><br><span class="line">                if(max &lt; temp)</span><br><span class="line">                    max &#x3D; temp;</span><br><span class="line">                temp &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        return max;</span><br><span class="line">                 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目描述</p>
<p>牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为w。<br>牛牛家里一共有n袋零食, 第i袋零食体积为v[i]。<br>牛牛想知道在总体积不超过背包容量的情况下,他一共有多少种零食放法(总体积为0也算一种放法)。</p>
<p>输入描述:</p>
<p>输入包括两行<br>第一行为两个正整数n和w(1 &lt;= n &lt;= 30, 1 &lt;= w &lt;= 2 * 10^9),表示零食的数量和背包的容量。<br>第二行n个正整数v[i](0 &lt;= v[i] &lt;= 10^9),表示每袋零食的体积。</p>
<p>输出描述:<br>输出一个正整数, 表示牛牛一共有多少种零食放法。</p>
<p>注意：总数sum要表示成long型，不然会越界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    private static int result &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String strTemp &#x3D; scanner.nextLine();</span><br><span class="line">            if (strTemp.isEmpty())&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] str &#x3D; strTemp.split(&quot; &quot;);</span><br><span class="line">            int n &#x3D; Integer.parseInt(str[0]);</span><br><span class="line">            int m &#x3D;Integer.parseInt(str[1]);</span><br><span class="line"></span><br><span class="line">            String [] size &#x3D; scanner.nextLine().split(&quot; &quot;);</span><br><span class="line">            int [] sizeArray &#x3D; new int[size.length];</span><br><span class="line">            long sum &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size.length; i++) &#123;</span><br><span class="line">                sizeArray[i] &#x3D; Integer.parseInt(size[i]);</span><br><span class="line">                sum +&#x3D; sizeArray[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (sum&lt;&#x3D;m)&#123;</span><br><span class="line">                System.out.println((int)Math.pow(2,n));</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                sum &#x3D; 0;</span><br><span class="line">                result +&#x3D;1;</span><br><span class="line">                dfs(sizeArray, sum, m, 0);</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void dfs(int[] arraySize, long sum, int m, int position)&#123;</span><br><span class="line">        if (position&lt;arraySize.length)&#123;</span><br><span class="line">            if (sum&gt;&#x3D;m)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(arraySize, sum, m, position+1);</span><br><span class="line"></span><br><span class="line">            if (sum+arraySize[position]&lt;m)&#123;</span><br><span class="line">                result +&#x3D;1;</span><br><span class="line">                sum +&#x3D; arraySize[position];</span><br><span class="line">                dfs(arraySize, sum,m,position+1);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目描述</p>
<p>小易有一些立方体，每个立方体的边长为1，他用这些立方体搭了一些塔。<br>现在小易定义：这些塔的不稳定值为它们之中最高的塔与最低的塔的高度差。<br>小易想让这些塔尽量稳定，所以他进行了如下操作：每次从某座塔上取下一块立方体，并把它放到另一座塔上。</p>
<p>注意，小易不会把立方体放到它原本的那座塔上，因为他认为这样毫无意义。<br>现在小易想要知道，他进行了不超过k次操作之后，不稳定值最小是多少。</p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行两个数n,k (1 &lt;&#x3D; n &lt;&#x3D; 100, 0 &lt;&#x3D; k &lt;&#x3D; 1000)表示塔的数量以及最多操作的次数。</span><br><span class="line">第二行n个数，ai(1 &lt;&#x3D; ai &lt;&#x3D; 104)表示第i座塔的初始高度。</span><br></pre></td></tr></table></figure>
<p>输出描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行两个数s, m，表示最小的不稳定值和操作次数(m &lt;&#x3D; k)</span><br><span class="line">接下来m行，每行两个数x,y表示从第x座塔上取下一块立方体放到第y座塔上。</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">5 8 5</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 2</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<p>每次都把数组进行排序，然后最大值-1，最小值+1，用ArrayList记录这一操作的痕迹。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String strTemp &#x3D; scanner.nextLine();</span><br><span class="line"></span><br><span class="line">            String[] str &#x3D; strTemp.split(&quot; &quot;);</span><br><span class="line">            int n &#x3D; Integer.parseInt(str[0]);</span><br><span class="line">            int k &#x3D;Integer.parseInt(str[1]);</span><br><span class="line"></span><br><span class="line">            String [] size &#x3D; scanner.nextLine().split(&quot; &quot;);</span><br><span class="line">            int[] sizeArray &#x3D; new int[n];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size.length; i++) &#123;</span><br><span class="line">                sizeArray[i] &#x3D; Integer.parseInt(size[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            int count &#x3D; 0;</span><br><span class="line">            ArrayList&lt;Integer&gt; list1 &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            ArrayList&lt;Integer&gt; list2 &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">                int max &#x3D; findMaxPosition(sizeArray);</span><br><span class="line">                int min &#x3D; findMinPosition(sizeArray);</span><br><span class="line"></span><br><span class="line">                if (sizeArray[max]-sizeArray[min]&lt;&#x3D;1)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                count++;</span><br><span class="line">                sizeArray[max]--;</span><br><span class="line">                sizeArray[min]++;</span><br><span class="line">                list1.add(max+1);</span><br><span class="line">                list2.add(min+1);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sizeArray[findMaxPosition(sizeArray)] - sizeArray[findMinPosition(sizeArray)] +&quot; &quot;+count);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; list1.size(); i++) &#123;</span><br><span class="line">                System.out.println(list1.get(i) + &quot; &quot; + list2.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int findMaxPosition(int[] arraySize)&#123;</span><br><span class="line">        int[] temp &#x3D; Arrays.copyOfRange(arraySize, 0,arraySize.length);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(temp);</span><br><span class="line">        int max &#x3D; temp[temp.length-1];</span><br><span class="line">        int position &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arraySize.length; i++) &#123;</span><br><span class="line">            if (max &#x3D;&#x3D; arraySize[i])&#123;</span><br><span class="line">                position &#x3D; i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int findMinPosition(int[] arraySize)&#123;</span><br><span class="line">        int[] temp &#x3D; Arrays.copyOfRange(arraySize, 0,arraySize.length);</span><br><span class="line">        Arrays.sort(temp);</span><br><span class="line">        int min &#x3D; temp[0];</span><br><span class="line">        int position &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arraySize.length; i++) &#123;</span><br><span class="line">            if (min &#x3D;&#x3D; arraySize[i])&#123;</span><br><span class="line">                position &#x3D; i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-数学"><a href="#10-数学" class="headerlink" title="10.数学"></a>10.数学</h4><p>今天上课，老师教了小易怎么计算加法和乘法，乘法的优先级大于加法，但是如果一个运算加了括号，那么它的优先级是最高的。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1+2*3&#x3D;7</span><br><span class="line">1*(2+3)&#x3D;5</span><br><span class="line">1*2*3&#x3D;6</span><br><span class="line">(1+2)*3&#x3D;9</span><br></pre></td></tr></table></figure>
<p>现在小易希望你帮他计算给定3个数a，b，c，在它们中间添加”+”， “*”， “(“， “)”符号，能够获得的最大值。</p>
<p>输入描述:<br>一行三个数a，b，c (1 &lt;= a, b, c &lt;= 10)</p>
<p>输出描述:<br>能够获得的最大值</p>
<p>规律：<br>最小的数小于等于1时，那么最大的结果便是a+b的和再乘以c<br>若最小数大于1，则最大结果必然是三数的积</p>
<h4 id="11-动态规划"><a href="#11-动态规划" class="headerlink" title="11.动态规划"></a>11.动态规划</h4><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;String&gt; Permutation(String str) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        if (str !&#x3D; null &amp;&amp; str.length() &gt; 0) &#123;</span><br><span class="line">            PermutationHelper(str.toCharArray(), 0, res);</span><br><span class="line">            Collections.sort(res);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void PermutationHelper(char[] cs, int i, ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">        if(i &#x3D;&#x3D; cs.length - 1) &#123; &#x2F;&#x2F;解空间的一个叶节点</span><br><span class="line">            list.add(String.valueOf(cs)); &#x2F;&#x2F;找到一个解</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for(int j &#x3D; i; j &lt; cs.length; ++j) &#123;</span><br><span class="line">                if(j &#x3D;&#x3D; i || cs[j] !&#x3D; cs[i]) &#123;</span><br><span class="line">                    SwapUtil.swap(cs, i, j);</span><br><span class="line">                    PermutationHelper(cs, i + 1, list);</span><br><span class="line">                    SwapUtil.swap(cs, i, j); &#x2F;&#x2F;复位</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-不用动态规划简单些"><a href="#12-不用动态规划简单些" class="headerlink" title="12.不用动态规划简单些"></a>12.不用动态规划简单些</h4><p>给出2n(n≤100)个自然数(小于等于30000)。将这2n个自然数排成一列，游戏双方A和B从中取数，只允许从两端取数。A先取，然后双方轮流取数。取完时，谁取得数字总和最大为取胜方；若双方和相等，属B胜。试问A方是否有必胜策略？</p>
<p>输入</p>
<p>共2行，第1行一个整数n；第2行有2*n个自然数。</p>
<p>输出</p>
<p>只有1行，若A有必胜策略，则输出“YES”，否则输出“NO”。</p>
<p>样例输入</p>
<p>4<br>7 9 3 6 4 2 5 3</p>
<p>样例输出</p>
<p>YES</p>
<p>思路</p>
<p>因为第一手先走的人有，可以全奇数项或者全拿偶数项，<br>所以只需要判断一下奇数项的和和偶数项的和是不是相等就可以了。</p>
<h4 id="13-拼多多笔试题"><a href="#13-拼多多笔试题" class="headerlink" title="13.拼多多笔试题"></a>13.拼多多笔试题</h4><p>高程图</p>
<p><a href="https://imgchr.com/i/82I09f" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/20/82I09f.png" alt="82I09f.png"></a></p>
<p>思路：使用机器人邹迷宫寻找递归的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Mian1 &#123;</span><br><span class="line">    private static int[][] array;</span><br><span class="line">    private static int N;</span><br><span class="line">    private static int M;</span><br><span class="line">    private static int first &#x3D; 0;</span><br><span class="line">    private static int left &#x3D; 1;</span><br><span class="line">    private static int right &#x3D; 2;</span><br><span class="line">    private static int up &#x3D; 3;</span><br><span class="line">    private static int down &#x3D; 4;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(&quot;5 5\n1 3 1 2 1\n2 1 3 1 1\n1 4 2 6 1\n1 3 1 3 1\n1 1 5 1 1\n&quot;);</span><br><span class="line">        while(scanner.hasNextLine())&#123;</span><br><span class="line">            String [] strings &#x3D; scanner.nextLine().split(&quot; &quot;);</span><br><span class="line">            N &#x3D; Integer.parseInt(strings[0]);</span><br><span class="line">            M &#x3D; Integer.parseInt(strings[1]);</span><br><span class="line">            array &#x3D; new int[N][M];</span><br><span class="line">            int sumStart &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">                String [] str &#x3D; scanner.nextLine().split(&quot; &quot;);</span><br><span class="line">                for (int j &#x3D; 0; j &lt; M; j++) &#123;</span><br><span class="line">                    array[i][j] &#x3D; Integer.parseInt(str[j]);</span><br><span class="line">                    sumStart +&#x3D; array[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 1; i &lt; N-1; i++) &#123;</span><br><span class="line">                for (int j &#x3D; 1; j &lt; M-1; j++) &#123;</span><br><span class="line">                    array[i][j] &#x3D; findMin(array, i, j,first);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int sumEnd &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; M; j++) &#123;</span><br><span class="line">                    sumEnd +&#x3D; array[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(sumEnd-sumStart);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int findMin(int[][] array, int X, int Y,int direction)&#123;</span><br><span class="line">        int nextX &#x3D; X;</span><br><span class="line">        int nextY &#x3D; Y;</span><br><span class="line">        if (nextX &#x3D;&#x3D;0 || nextX &#x3D;&#x3D;N-1 || nextY&#x3D;&#x3D;0 || nextY&#x3D;&#x3D;M-1)&#123;</span><br><span class="line">            return array[X][Y];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (array[X][Y]&gt;array[X][Y-1] &amp;&amp; array[X][Y]&gt;array[X][Y+1] &amp;&amp; array[X][Y]&gt;array[X-1][Y] &amp;&amp; array[X][Y]&gt;array[X+1][Y])</span><br><span class="line">            return array[X][Y];</span><br><span class="line"></span><br><span class="line">        int nextLeft;</span><br><span class="line">        int nextRight;</span><br><span class="line">        int nextUp;</span><br><span class="line">        int nextDown;</span><br><span class="line">        switch (direction)&#123;</span><br><span class="line">            case 0:</span><br><span class="line">                nextLeft &#x3D; findMin(array,X,Y-1,right);</span><br><span class="line">                nextRight &#x3D; findMin(array,X,Y+1, left);</span><br><span class="line">                nextUp &#x3D; findMin(array,X-1,Y, down);</span><br><span class="line">                nextDown &#x3D; findMin(array,X+1,Y, up);</span><br><span class="line">                return Math.max(Math.min(Math.min(nextRight,nextLeft), Math.min(nextDown, nextUp)),array[X][Y]);</span><br><span class="line">            case 1:</span><br><span class="line">                nextRight &#x3D; findMin(array,X,Y+1, left);</span><br><span class="line">                nextUp &#x3D; findMin(array,X-1,Y, down);</span><br><span class="line">                nextDown &#x3D; findMin(array,X+1,Y, up);</span><br><span class="line">                return Math.max(Math.min(nextRight, Math.min(nextDown, nextUp)),array[X][Y]);</span><br><span class="line">            case 2:</span><br><span class="line">                nextLeft &#x3D; findMin(array,X,Y-1,right);</span><br><span class="line">                nextUp &#x3D; findMin(array,X-1,Y, down);</span><br><span class="line">                nextDown &#x3D; findMin(array,X+1,Y, up);</span><br><span class="line">                return Math.max(Math.min(nextLeft, Math.min(nextDown, nextUp)),array[X][Y]);</span><br><span class="line">            case 3:</span><br><span class="line">                nextLeft &#x3D; findMin(array,X,Y-1,right);</span><br><span class="line">                nextRight &#x3D; findMin(array,X,Y+1, left);</span><br><span class="line">                nextDown &#x3D; findMin(array,X+1,Y, up);</span><br><span class="line">                return Math.max(Math.min(Math.min(nextRight,nextLeft), nextDown),array[X][Y]);</span><br><span class="line">            case 4:</span><br><span class="line">                nextLeft &#x3D; findMin(array,X,Y-1,right);</span><br><span class="line">                nextRight &#x3D; findMin(array,X,Y+1, left);</span><br><span class="line">                nextUp &#x3D; findMin(array,X-1,Y, up);</span><br><span class="line">                return Math.max(Math.min(Math.min(nextRight,nextLeft), nextUp),array[X][Y]);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-利用一个数组实现两个栈"><a href="#14-利用一个数组实现两个栈" class="headerlink" title="14.利用一个数组实现两个栈"></a>14.利用一个数组实现两个栈</h4><p>方法1：利用奇偶位，分别存储栈1和栈2的数据；</p>
<p>方法2：从中间开始将数组一分为二，左边为栈1，右边为栈2；</p>
<p>方法3：栈1从头开始增长，栈2从尾向头进行增长，相遇后，增容；</p>
<p><a href="https://imgchr.com/i/8WS2Rg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/21/8WS2Rg.png" alt="8WS2Rg.png"></a></p>
<h4 id="15-装满箱子"><a href="#15-装满箱子" class="headerlink" title="15.装满箱子"></a>15.装满箱子</h4><p>题目描述</p>
<p>有重量分别为3，5，7公斤的三种货物，和一个载重量为X公斤的箱子（不考虑体积等其它因素，只计算重量）需要向箱子内装满X公斤的货物，要求使用的货物个数尽可能少（三种货物数量无限）</p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入箱子载重量X(1 &lt;&#x3D; X &lt;&#x3D; 10000)，一个整数。</span><br></pre></td></tr></table></figure>
<p>输出描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果无法装满，输出 -1。</span><br><span class="line">如果可以装满，输出使用货物的总个数。</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure>
<p>说明:无法装满</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    static int temp &#x3D; 0;</span><br><span class="line">    public static void dfs(int count, int rest) &#123;</span><br><span class="line">        if (rest &lt; 0) &#123;&#x2F;&#x2F;如果-3，-5或者-7小于0了，说明凑不齐，赶紧溜了</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (rest &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            System.out.println(temp*15+count);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(count + 1, rest - 7);</span><br><span class="line">        dfs(count + 1, rest - 5);</span><br><span class="line">        dfs(count + 1, rest - 3);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; sc.nextInt();</span><br><span class="line">        temp &#x3D; n &#x2F; 105;</span><br><span class="line">        dfs(0, n % 105);</span><br><span class="line">        System.out.println(-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-回文子串"><a href="#16-回文子串" class="headerlink" title="16.回文子串"></a>16.回文子串</h4><p>回文子串的个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">链接：https:&#x2F;&#x2F;www.nowcoder.com&#x2F;questionTerminal&#x2F;003482c395bd41c68082f6adc545a600</span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line">public class Solution14_回文子串 &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 方法一：中心扩散法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static int ans &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf &#x3D; new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        String s &#x3D; bf.readLine();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;考虑两种情况：aba 和 abba</span><br><span class="line">            centerSpread(s, i, i);</span><br><span class="line">            centerSpread(s, i, i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;判断回文串的中心扩散法</span><br><span class="line">    private static void centerSpread(String s, int left, int right) &#123;</span><br><span class="line">        while (left &gt;&#x3D; 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) &#x3D;&#x3D; s.charAt(right)) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;方法二：动态规划</span><br><span class="line">    private static int dp(String s) &#123;</span><br><span class="line">        int n &#x3D; s.length(), ans &#x3D; 0;</span><br><span class="line">        boolean[][] dp &#x3D; new boolean[n][n];</span><br><span class="line">        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            for (int j &#x3D; i; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] &#x3D; (s.charAt(i) &#x3D;&#x3D; s.charAt(j)) &amp;&amp; (j - i &lt;&#x3D; 2 || dp[i + 1][j - 1]);</span><br><span class="line">                if (dp[i][j]) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最长回文子串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">链接：https:&#x2F;&#x2F;www.nowcoder.com&#x2F;questionTerminal&#x2F;003482c395bd41c68082f6adc545a600</span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;1.动态规划</span><br><span class="line">    public static String longestPalindrome(String s) &#123;</span><br><span class="line">        int n &#x3D; s.length();</span><br><span class="line">        if (n &lt; 2) return s;</span><br><span class="line">        int maxLen &#x3D; 1;</span><br><span class="line">        String res &#x3D; s.substring(0, 1);</span><br><span class="line">        boolean[][] dp &#x3D; new boolean[n][n];</span><br><span class="line">        &#x2F;&#x2F;左边界一定小于右边界，因此从右边界开始</span><br><span class="line">        for (int r &#x3D; 1; r &lt; n; r++) &#123; &#x2F;&#x2F;表示右边界</span><br><span class="line">            for (int l &#x3D; 0; l &lt; r; l++) &#123; &#x2F;&#x2F;表示左边界</span><br><span class="line">                &#x2F;&#x2F; 区间应该慢慢放大</span><br><span class="line">                &#x2F;&#x2F; 状态转移方程：如果头尾字符相等并且中间也是回文</span><br><span class="line">                &#x2F;&#x2F; 在头尾字符相等的前提下，如果收缩以后不构成区间（最多只有 1 个元素），直接返回 True 即可</span><br><span class="line">                &#x2F;&#x2F; 否则要继续看收缩以后的区间的回文性</span><br><span class="line">                if (s.charAt(l) &#x3D;&#x3D; s.charAt(r) &amp;&amp; ((r - l) &lt;&#x3D; 2 || dp[l + 1][r - 1])) &#123;</span><br><span class="line">                    dp[l][r] &#x3D; true;</span><br><span class="line">                    if (r - l + 1 &gt; maxLen) &#123;</span><br><span class="line">                        maxLen &#x3D; r - l + 1;</span><br><span class="line">                        res &#x3D; s.substring(l, r + 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最长不连续回文子串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">链接：https:&#x2F;&#x2F;www.nowcoder.com&#x2F;questionTerminal&#x2F;003482c395bd41c68082f6adc545a600</span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line">public int longestPalindrome(String s) &#123;</span><br><span class="line">    int n &#x3D; s.length();</span><br><span class="line">    int[][] dp &#x3D; new int[n][n];&#x2F;&#x2F;dp[l][r]表示l-r中的最长回文串</span><br><span class="line">    for (int r &#x3D; 0; r &lt; n; r++) &#123;</span><br><span class="line">        dp[r][r] &#x3D; 1;</span><br><span class="line">        for (int l &#x3D; r - 1; l &gt;&#x3D; 0; l--) &#123;</span><br><span class="line">            if (s.charAt(l) &#x3D;&#x3D; s.charAt(r)) &#123;</span><br><span class="line">                dp[l][r] &#x3D; dp[l + 1][r - 1] + 2;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[l][r] &#x3D; Math.max(dp[l + 1][r], dp[l][r - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试笔记</category>
      </categories>
      <tags>
        <tag>面试笔记</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>面试基础笔记</title>
    <url>/2020/06/22/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/ox1jqm.png">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">一抹光</div>
</center>


<blockquote>
<p>本科面试笔记</p>
</blockquote>
<a id="more"></a>

<h2 id="一、Java面试笔记"><a href="#一、Java面试笔记" class="headerlink" title="一、Java面试笔记"></a>一、Java面试笔记</h2><h3 id="Java知识点"><a href="#Java知识点" class="headerlink" title="Java知识点"></a>Java知识点</h3><h4 id="1-onCreate和onStart的区别？"><a href="#1-onCreate和onStart的区别？" class="headerlink" title="1.onCreate和onStart的区别？"></a>1.onCreate和onStart的区别？</h4><ul>
<li>onCreate创建与onDestroy销毁；</li>
<li>onStart可见与onStop不可见；</li>
<li>onResume可编辑（即焦点）与onPause；</li>
<li>onCreate只会被调用一次，onStart可以调用多次</li>
</ul>
<h4 id="2-looper-prepare做了什么事情？"><a href="#2-looper-prepare做了什么事情？" class="headerlink" title="2.looper prepare做了什么事情？"></a>2.looper prepare做了什么事情？</h4><ul>
<li>默认情况下一个线程是不存在消息循环（message loop）的</li>
<li>需要调用Looper.prepare()来给线程创建一个消息循环，调用Looper.loop()来使消息循环起作用</li>
</ul>
<h4 id="3-Https原理及流程"><a href="#3-Https原理及流程" class="headerlink" title="3.Https原理及流程"></a>3.Https原理及流程</h4><p>1.客户端向服务器发起HTTPS请求，连接到服务器的443端口</p>
<p>2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</p>
<p>3.服务器将自己的公钥发送给客户端。</p>
<p>4.客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</p>
<p>5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</p>
<p>6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</p>
<p>7.然后服务器将加密后的密文发送给客户端。</p>
<p>8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</p>
<hr>
<p>证书：直观的看，证书包括以下这些内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 证书序列号</span><br><span class="line"></span><br><span class="line">2. 证书过期时间</span><br><span class="line"></span><br><span class="line">3. 站点组织名</span><br><span class="line"></span><br><span class="line">4. 站点DNS主机名</span><br><span class="line"></span><br><span class="line">5. 站点公钥</span><br><span class="line"></span><br><span class="line">6. 证书颁发者名</span><br><span class="line"></span><br><span class="line">7. 证书签名</span><br></pre></td></tr></table></figure>

<p>证书链：证书链的出现，其本质是因为如果证书颁发机构过多的话，不容易识别，防伪和管理，于是形成了少数几家国际权威的证书颁发机构，这些机构非常权威，默认是所有人都可信的，它们成为根证书。但是除了这些机构外，其他的机构也需要被信任，因而，需要这些权威的机构去授信颁发证书，于是就形成了一级证书机构，一级证书机构又可以继续授信下级机构，于是成为树状结构，对于任何一个组织到根证书就是链状结构。</p>
<p>假设你想要成为一个受信任的网站或机构，只需要找你的上级机构去颁发证书给你，颁发时你将自己的公钥，host等信息发送到颁发机构，该机构会将自己的证书附上你的信息，并用自己的私钥签名，做成一张新的证书发给你；而这个上级机构他的证书又是同样的方法由CA颁发的。</p>
<p>  那么，其他人怎么确认你的证书是合法的呢。首先你的证书会在https握手过程中被传递到浏览器，浏览器从你的证书中找到了颁发者，从颁发者的证书（如果你电脑上有的话）又找到了CA的证书（CA证书会在操作系统安装时就安装好，所以每个人电脑上都有根证书），使用CA证书中带的公钥来对颁发者证书做验签，一旦匹配，说明你电脑上的颁发者证书不是伪造的，同理，再用颁发者证书中的公钥去验证你的证书，以此证明你的证书不是伪造的。这样整个链状的验证，从而确保你的证书一定是直接或间接从CA签发的，这样浏览器地址栏会显示一个绿色的盾牌，表示你的网站能通过证书验证</p>
<p>  如果你的电脑上没有颁发者证书（断链）或者你自己本身就是自签名证书（自己做CA，但是要记得，人家电脑上并没有装你的自签名根证书），那么浏览器会报警提示不能验证证书，问你是否还需要继续。</p>
<p>  <a href="https://imgchr.com/i/8WPGOH" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/21/8WPGOH.png" alt="8WPGOH.png"></a></p>
<hr>
<ol>
<li>什么是TCP粘包背景</li>
</ol>
<p>在socket网络编程中，都是端到端通信，由客户端端口+服务端端口+客户端IP+服务端IP+传输协议组成的五元组可以明确的标识一条连接。在TCP的socket编程中，发送端和接收端都有成对的socket。发送端为了将多个发往接收端的包，更加高效的的发给接收端，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。那么这样一来，接收端就必须使用高效科学的拆包机制来分辨这些数据。</p>
<ol start="2">
<li>什么是TCP粘包问题？</li>
</ol>
<p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。</p>
<ol start="3">
<li>造成TCP粘包的原因</li>
</ol>
<p>（1）发送方原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：</span><br><span class="line"></span><br><span class="line">1.只有上一个分组得到确认，才会发送下一个分组收集多个小分组，在一个确认到来时一起发送</span><br><span class="line"></span><br><span class="line">2.agle算法造成了发送方可能会出现粘包问题</span><br></pre></td></tr></table></figure>
<p>（2）接收方原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如</span><br><span class="line">果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>什么时候需要处理粘包现象？</li>
</ol>
<ul>
<li><p>如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象</p>
</li>
<li><p>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了</p>
</li>
</ul>
<ol start="5">
<li>如何处理粘包现象？<br>（1）发送方</li>
</ol>
<p>对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</p>
<p>（2）接收方</p>
<p>接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。</p>
<p>（3）应用层</p>
<p>应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。</p>
<p>解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？</p>
<p>格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。<br>发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。</p>
<ol start="6">
<li>DP会不会产生粘包问题呢？</li>
</ol>
<p>TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。</p>
<p>UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<p>举个例子：有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕。</p>
<hr>
<p>慢启动（Slow Start）</p>
<p>是传输控制协议（TCP）使用的一种阻塞控制机制。慢启动也叫做指数增长期。慢启动是指每次TCP接收窗口收到确认时都会增长。增加的大小就是已确认段的数目。这种情况一直保持到要么没有收到一些段，要么窗口大小到达预先定义的阈值。如果发生丢失事件，TCP就认为这是网络阻塞，就会采取措施减轻网络拥挤。一旦发生丢失事件或者到达阈值，TCP就会进入线性增长阶段。这时，每经过一个RTT窗口增长一个段</p>
<h4 id="4-HashMap原理"><a href="#4-HashMap原理" class="headerlink" title="4.HashMap原理"></a>4.HashMap原理</h4><p>哈希概念</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。</span><br></pre></td></tr></table></figure>
<p>哈希存储中的碰撞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对不同的关键字可能得到同一哈希值，即key1≠key2，而f(key1)&#x3D;f(key2)，这种现象称碰撞</span><br></pre></td></tr></table></figure>
<p>碰撞解决方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开放定址法：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</span><br><span class="line"></span><br><span class="line">链地址:HashMap中同样哈希值的位置以一串链表存储起来数据</span><br></pre></td></tr></table></figure>

<p>HashMap的存储结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组、链表、红黑树</span><br></pre></td></tr></table></figure>

<p>HashMap原理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基于hashing原理，通过put()和get()方法储存和获取对象。put()方法: 它调用键对象的hashCode()方法来计算hashcode值，</span><br><span class="line">系统根据hashcode值决定该元素在bucket位置。如果两个对象key的hashcode返回值相同，那他们的存储位置相同，如果这两个Entry的key通过equals比较返回t</span><br><span class="line">rue，新添加Entry的value将覆盖集合中原有Entry的value，但key不会覆盖；如果这两个Entry的key通过equals比较返回false，新添加的Entry将与集合中原有Entry形成Entry链，而且新添加Entry位于Entry链的头部。put源码如下:</span><br></pre></td></tr></table></figure>
<p>HashMap和Hashtable的区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap和Hashtable都实现了Map接口，主要的区别有：线程安全性，同步(synchronization)，以及速度。HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)</span><br></pre></td></tr></table></figure>
<p>HashMap和HashSet的区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashSet实现了Set接口，它不允许集合中有重复的值，HashMap实现了Map接口，Map接口对键值对进行映射。</span><br><span class="line">HashSet扩展了HashMap,所以底层还是用到map存储，存储实现同map一致，HashMap储存键值，HashSet存储对象。</span><br></pre></td></tr></table></figure>

<p>重写equals不重写hashcode会出现什么问题</p>
<p>在存储散列集合时(如Set类)，如果原对象.equals(新对象)，但没有对hashCode重写，即两个对象拥有不同的hashcode，则在集合中将会存储两个值相同的对象，从而导致混淆。因此在重写equals方法时，必须重写hashcode方法。</p>
<h4 id="5-gc的几种算法"><a href="#5-gc的几种算法" class="headerlink" title="5.gc的几种算法"></a>5.gc的几种算法</h4><p>引用计数法、标记-清除法、复制算法、标记-清除算法</p>
<h4 id="6-ArrayList-和-LinkedList-区别"><a href="#6-ArrayList-和-LinkedList-区别" class="headerlink" title="6.ArrayList 和 LinkedList 区别"></a>6.ArrayList 和 LinkedList 区别</h4><p>ArrayList是基于数组实现的，LinkedList是基于双链表实现的</p>
<h4 id="7-gc-root-的对象有哪些？"><a href="#7-gc-root-的对象有哪些？" class="headerlink" title="7.gc root 的对象有哪些？"></a>7.gc root 的对象有哪些？</h4><p>1 、 虚拟机栈（栈帧中的本地变量表）中引用的对象。</p>
<p>2、 本地方法栈中JNI（即一般说的native方法）引用的对象。</p>
<p>3、 方法区中的静态变量和常量引用的对象。</p>
<h4 id="8-java-为什么采用可达性分析不用引用计数器"><a href="#8-java-为什么采用可达性分析不用引用计数器" class="headerlink" title="8.java 为什么采用可达性分析不用引用计数器"></a>8.java 为什么采用可达性分析不用引用计数器</h4><p>1 jdk从1.2开始增加了多种引用方式：软引用、弱引用、虚引用，且在不同引用情况下程序应进行不同的操作。如果我们只采用一个引用计数法来计数无法准确的区分这么多种引用的情况。</p>
<p>2 如果一个对象A持有对象B，而对象B也持有一个对象A，那发生了类似操作系统中死锁的循环持有，这种情况下A与B的counter恒大于1，会使得GC永远无法回收这两个对象。</p>
<h4 id="9-线程间通信的几种实现方式"><a href="#9-线程间通信的几种实现方式" class="headerlink" title="9.线程间通信的几种实现方式"></a>9.线程间通信的几种实现方式</h4><p>1.使用 volatile 关键字。<br>基于 volatile 关键字来实现线程间相互通信是使用共享内存的思想，大致意思就是多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。这也是最简单的一种实现方式</p>
<p>2.使用Object类的wait() 和 notify() 方法。<br>众所周知，Object类提供了线程间通信的方法：wait()、notify()、notifyaAl()，它们是多线程通信的基础，而这种实现方式的思想自然是线程间通信。</p>
<p>3.使用JUC工具类 CountDownLatch。<br>jdk1.5之后在java.util.concurrent包下提供了很多并发编程相关的工具类，简化了我们的并发编程代码的书写，<strong><em>CountDownLatch</em></strong>基于AQS框架，相当于也是维护了一个线程间共享变量state</p>
<h4 id="10-synchronized和volatile的区别"><a href="#10-synchronized和volatile的区别" class="headerlink" title="10.synchronized和volatile的区别"></a>10.synchronized和volatile的区别</h4><p>1.volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；</p>
<p>2.从内存可见性角度，volatile读相当于加锁，volatile写相当于解锁；</p>
<p>3.synchronized既能够保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。</p>
<h4 id="11-Java对象的4种引用方式"><a href="#11-Java对象的4种引用方式" class="headerlink" title="11.Java对象的4种引用方式"></a>11.Java对象的4种引用方式</h4><p>1.强引用。<br>我们平日里面的用到的new了一个对象就是强引用，例如 Object obj = new Object();当JVM的内存空间不足时，宁愿抛出OutOfMemoryError使得程序异常终止也不愿意回收具有强引用的存活着的对象！</p>
<p>2.软引用。<br>当JVM认为内存空间不足时，就回去试图回收软引用指向的对象，也就是说在JVM抛出OutOfMemoryError之前，会去清理软引用对象。软引用可以与引用队列(ReferenceQueue)联合使用。</p>
<p>3.弱引用。在GC的时候，不管内存空间足不足都会回收这个对象，同样也可以配合ReferenceQueue 使用，也同样适用于内存敏感的缓存。ThreadLocal中的key就用到了弱引用。</p>
<p>4.幻象引用。虚引用仅仅只是提供了一种确保对象被finalize以后来做某些事情的机制。比如说这个对象被回收之后发一个系统通知啊啥的。虚引用是必须配合ReferenceQueue 使用的，具体使用方法和上面提到软引用的一样。主要用来跟踪对象被垃圾回收的活动。</p>
<h4 id="12-final、finally、finalize的区别"><a href="#12-final、finally、finalize的区别" class="headerlink" title="12.final、finally、finalize的区别"></a>12.final、finally、finalize的区别</h4><p>final用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。</p>
<p>finally是异常处理语句结构的一部分，表示总是执行。</p>
<p>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。</p>
<h4 id="13-finally什么时候使用"><a href="#13-finally什么时候使用" class="headerlink" title="13.finally什么时候使用"></a>13.finally什么时候使用</h4><p>finally可以没有，也可以只有一个。无论有没有发生异常，它总会在这个异常处理结构的最后运行。即使你在try块内用return返回了，在返回前，finally总是要执行，这以便让你有机会能够在异常处理最后做一些清理工作。如关闭数据库连接等等。 </p>
<h4 id="14-UDP如何实现可靠传输"><a href="#14-UDP如何实现可靠传输" class="headerlink" title="14.UDP如何实现可靠传输"></a>14.UDP如何实现可靠传输</h4><p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<p>1、添加seq/ack机制，确保数据发送到对端</p>
<p>2、添加发送和接收缓冲区，主要是用户超时重传。</p>
<p>3、添加超时重传机制。</p>
<p>详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>
<h4 id="15-怎么监控卡顿"><a href="#15-怎么监控卡顿" class="headerlink" title="15.怎么监控卡顿?"></a>15.怎么监控卡顿?</h4><p>ANR-WatchDog是参考Android WatchDog机制（com.android.server.WatchDog.java）起个单独线程向主线程发送一个变量+1操作，自我休眠自定义ANR的阈值，休眠过后判断变量是否+1完成，如果未完成则告警。</p>
<p>FileObserve<br>有ANR的流程就可以知道/data/anr文件夹的变化代表着ANR的发生，AMS在dumpStackTrace方法中给了我们一些提示。</p>
<h4 id="16-java单例模式大全"><a href="#16-java单例模式大全" class="headerlink" title="16.java单例模式大全"></a>16.java单例模式大全</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Writer &#123;</span><br><span class="line"></span><br><span class="line">        private Writer()&#123;&#125;</span><br><span class="line">        private static volatile Writer writer;</span><br><span class="line">        public static Writer getInstance()&#123;</span><br><span class="line">            if(wrter &#x3D;&#x3D; null)&#123;</span><br><span class="line">                synchronized(Writer.class)&#123;</span><br><span class="line">                    if(wrter &#x3D;&#x3D; null)&#123;</span><br><span class="line">                        writer &#x3D; new Writer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return writer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-Java内存泄漏"><a href="#17-Java内存泄漏" class="headerlink" title="17.Java内存泄漏"></a>17.Java内存泄漏</h4><p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p>
<p>在C ++ 中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。</p>
<h4 id="18-JVM中的内存是怎么划分的？"><a href="#18-JVM中的内存是怎么划分的？" class="headerlink" title="18.JVM中的内存是怎么划分的？"></a>18.JVM中的内存是怎么划分的？</h4><p>答：JVM中的内存主要划分为5个区域，即方法区，堆内存，程序计数器，虚拟机栈以及本地方法栈。下边是Java虚拟机运行时数据区示意图</p>
<p>方法区：方法区是一个线程之间共享的区域。常量，静态变量以及JIT编译后的代码都在方法区。主要用于存储已被虚拟机加载的类信息，也可以称为“永久代”，垃圾回收效果一般，通过-XX：MaxPermSize控制上限。</p>
<p>堆内存：堆内存是垃圾回收的主要场所，也是线程之间共享的区域，主要用来存储创建的对象实例，通过-Xmx 和-Xms 可以控制大小。</p>
<p>虚拟机栈（栈内存）：栈内存中主要保存局部变量、基本数据类型变量以及堆内存中某个对象的引用变量。每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表，操作数栈，动态链接，方法出口等信息。栈中的栈帧随着方法的进入和退出有条不紊的执行着出栈和入栈的操作。</p>
<p>程序计数器： 程序计数器是当前线程执行的字节码的位置指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，是内存区域中唯一一个在虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<p>本地方法栈： 主要是为JVM提供使用native 方法的服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">栈就像装数据的桶或箱子</span><br><span class="line"> </span><br><span class="line"> 我们先从大家比较熟悉的栈说起吧，它是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。这就如同我们要取出放在箱子里面底下的东西（放入的比较早的物体），我</span><br><span class="line"> 们首先要移开压在它上面的物体（放入的比较晚的物体）。</span><br><span class="line"></span><br><span class="line">堆像一棵倒过来的树</span><br><span class="line"></span><br><span class="line">而堆就不同了，堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。</span><br><span class="line">由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</span><br></pre></td></tr></table></figure>
<h4 id="19-对象创建过程中的内存分配吗？"><a href="#19-对象创建过程中的内存分配吗？" class="headerlink" title="19.对象创建过程中的内存分配吗？"></a>19.对象创建过程中的内存分配吗？</h4><p>1.1new指令</p>
<p>虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那么须先执行相应的类加载过程。</p>
<p>1.2分配内存</p>
<p>接下来虚拟机将为新生代对象分配内存。对象所需的内存的大小在类加载完成后便可完全确定。分配方式有“指针碰撞（Bump the Pointer）”和“空闲列表（Free List）”两种方式，具体由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p>1.3初始化</p>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>1.4对象的初始设置</p>
<p>接下来虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如对否启用偏向锁等，对象头会有不同的设置方式。</p>
<p>1.5<init>方法</init></p>
<p>在上面的工作都完成了之后，从虚拟机的角度看，一个新的对象已经产生了，但是从Java程序的角度看，对象创建才刚刚开始—<init>方法还没有执行，所有的字段都还为零。所以，一般来说，执行new指令后悔接着执行init方法，把对象按照程序员的意愿进行初始化（应该是将构造函数中的参数赋值给对象的字段），这样一个真正可用的对象才算完全产生出来。</init></p>
<p>2.1对象头</p>
<p>HotSpot虚拟机的对象头包含两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p>
<p>对象的另一部分类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例（并不是所有的虚拟机实现都必须在对象数据上保留类型指针，也就是说，查找对象的元数据信息并不一定要经过对象本身）。</p>
<p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。</p>
<p>元数据：描述数据的数据。对数据及信息资源的描述信息。在Java中，元数据大多表示为注解。</p>
<p>2.2实例数据</p>
<p>实例数据部分是对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容，无论从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会虚拟机默认的分配策略参数和字段在Java源码中定义的顺序影响（相同宽度的字段总是被分配到一起）。</p>
<p>2.3对齐填充</p>
<p>对齐填充部分并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，也就是说，对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h4 id="20-JVM如何判定一个对象是否应该被回收？"><a href="#20-JVM如何判定一个对象是否应该被回收？" class="headerlink" title="20.JVM如何判定一个对象是否应该被回收？"></a>20.JVM如何判定一个对象是否应该被回收？</h4><p>答： 判断一个对象是否应该被回收，主要是看其是否还有引用。判断对象是否存在引用关系的方法包括引用计数法以及root根搜索方法。</p>
<p>引用计数法：<br>是一种比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只需要收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</p>
<p>root根搜索方法：<br>root搜索方法的基本思路就是通过一系列可以做为root的对象作为起始点，从这些节点开始向下搜索。当一个对象到root节点没有任何引用链接时，则证明此对象是可以被回收的。以下对象会被认为是root对象：</p>
<p>栈内存中引用的对象方法区中静态引用和常量引用指向的对象<br>被启动类（bootstrap加载器）加载的类和创建的对象<br>Native方法中JNI引用的对象。</p>
<h4 id="21-JVM垃圾回收算法有哪些？"><a href="#21-JVM垃圾回收算法有哪些？" class="headerlink" title="21.JVM垃圾回收算法有哪些？"></a>21.JVM垃圾回收算法有哪些？</h4><p>答：HotSpot 虚拟机采用了root根搜索方法来进行内存回收，常见的回收算法有标记-清除算法，复制算法和标记整理算法。</p>
<p>标记-清除算法（Mark-Sweep）：</p>
<p>标记-清除算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，并且会产生内存碎片。</p>
<p>复制算法：</p>
<p>复制算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。复制算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</p>
<p>标记-整理算法：</p>
<p>标记-整理算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p>
<h4 id="22-JVM中的垃圾收集器CMS收集器"><a href="#22-JVM中的垃圾收集器CMS收集器" class="headerlink" title="22.JVM中的垃圾收集器CMS收集器"></a>22.JVM中的垃圾收集器CMS收集器</h4><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于标记-清除算法实现的，是一种老年代收集器，通常与ParNew一起使用。</p>
<p>CMS的垃圾收集过程分为4步：</p>
<ul>
<li>初始标记：需要“Stop the World”，初始标记仅仅只是标记一下GC Root能直接关联到的对象，速度很快。</li>
<li>并发标记：是主要标记过程，这个标记过程是和用户线程并发执行的。</li>
<li>重新标记：需要“Stop the World”，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（停顿时间比初始标记长，但比并发标记短得多）。</li>
<li>并发清除：和用户线程并发执行的，基于标记结果来清理对象。</li>
</ul>
<h4 id="23-覆盖（-Override）代码"><a href="#23-覆盖（-Override）代码" class="headerlink" title="23.覆盖（@Override）代码"></a>23.覆盖（@Override）代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OverrideTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Son().say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Parent &#123;</span><br><span class="line">    public void say()&#123;</span><br><span class="line">        System.out.println(&quot;我是父类中的say方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son extends Parent &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void say()&#123;</span><br><span class="line">        System.out.println(&quot;我是子类中的say方法，我覆盖了父类的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="24-重载代码"><a href="#24-重载代码" class="headerlink" title="24.重载代码"></a>24.重载代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OverLoadTest &#123;</span><br><span class="line"> </span><br><span class="line">    public void method1(String name, int age)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 两个方法的参数顺序不同，可以构成方法的重载</span><br><span class="line">    public void method1(int age, String name)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------</span><br><span class="line">    public void method2(String name)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 两个方法的参数类型不同，可以构成方法的重载</span><br><span class="line">    public void method2(int age)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------</span><br><span class="line">    public void method3(String name)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 两个方法的参数个数不同，可以构成方法的重载</span><br><span class="line">    public void method3(int age, int num)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-Java中的值传递和引用传递可以解释下吗？"><a href="#25-Java中的值传递和引用传递可以解释下吗？" class="headerlink" title="25.Java中的值传递和引用传递可以解释下吗？"></a>25.Java中的值传递和引用传递可以解释下吗？</h4><p>答：值传递和引用传递的解释可以概括如下。</p>
<p>值传递，意味着传递了对象的一个副本，即使副本被改变，也不会影响源对象。</p>
<p>引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象的改变会反映到所有的对象上。</p>
<h4 id="26-哪些对象可以被看做是-GC-Roots-呢？"><a href="#26-哪些对象可以被看做是-GC-Roots-呢？" class="headerlink" title="26.哪些对象可以被看做是 GC Roots 呢？"></a>26.哪些对象可以被看做是 GC Roots 呢？</h4><p>1）虚拟机栈（栈帧中的本地变量表）中引用的对象；</p>
<p>2）方法区中的类静态属性引用的对象，常量引用的对象； </p>
<p>3）本地方法栈中 JNI(Native 方法）引用的对象</p>
<h4 id="27-说下-java-中的线程创建方式，线程池的工作原理。"><a href="#27-说下-java-中的线程创建方式，线程池的工作原理。" class="headerlink" title="27.说下 java 中的线程创建方式，线程池的工作原理。"></a>27.说下 java 中的线程创建方式，线程池的工作原理。</h4><p>java 中有三种创建线程的方式，或者说四种 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.继承 Thread 类实现多线程 </span><br><span class="line">2.实现 Runnable 接口 </span><br><span class="line">3.实现 Callable 接口 </span><br><span class="line">4.通过线程池</span><br></pre></td></tr></table></figure>
<p>线程池的工作原理：</p>
<p>1）当提交一个新任务到线程池时，线程池判断corePoolSize线程池是否都在执行任务，如果有空闲线程，则创建一个新的工作线程来执行任务，直到当前线程数等于corePoolSize；</p>
<p>2）如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；</p>
<p>3）如果阻塞队列满了，那就创建新的线程执行当前任务，直到线程池中的线程数达到maxPoolSize，这时再有任务来，由饱和策略来处理提交的任务</p>
<h4 id="28-java中存在三种调用机制"><a href="#28-java中存在三种调用机制" class="headerlink" title="28.java中存在三种调用机制"></a>28.java中存在三种调用机制</h4><p>1：同步调用：一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用</p>
<p>2：回调：一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；</p>
<p>3：异步调用：一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）</p>
<p>具体说来：就是A类中调用B类中的某个方法C，然后B类中反过来调用A类中的方法D，D这个方法就叫回调方法，</p>
<p>举例：老师平时学生布置任务后不可能一直等待和监督学生完成，老师通常会告诉学生，任务完成后给他打个电话或者发个信息，那么学生给老师返回结果的过程需要老师信息，这就是一个回调的过程。</p>
<h4 id="29-新生代和老年代"><a href="#29-新生代和老年代" class="headerlink" title="29.新生代和老年代"></a>29.新生代和老年代</h4><p>新生代</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java新生代垃圾回收运用的是复制算法。</span><br><span class="line"></span><br><span class="line">java新生代分为两部分：Eden区和两个Survivor区，它们的比例是8:1:1，两个Survivor区又分为 fromSurvivor区和to Survivor区，其中新生代每次进行Minor GC（新生代的GC）之前，to Survivor区一定是空的。</span><br><span class="line"></span><br><span class="line">每当新创建一个对象而此时Eden区内存不足的时候，就会进行Minor GC，然后Eden区仍然活着的对象会复制到to Survivor区，而from Survivor区中年龄超过阀值的对象会保存到老年代中，没有超过阀值的对象会保存到to Survivor区中，然后to Survivor区和from Survivor区互换位置，保证每次都有一块Survivor区是空闲的。</span><br><span class="line"></span><br><span class="line">在Survivor区中的对象每经过一次Minor GC年龄就会加1，默认年龄阀值为15，这个阀值可自行设置，设置方法请自行百度。</span><br><span class="line"></span><br><span class="line">当Survivor区中年龄相同的对象加起来超过Survivor区一半内存大小的时候，Survivor区就会提前把大于等于此年龄的对象复制到老年代中。</span><br><span class="line"></span><br><span class="line">某些大对象（内存大）创建的时候不经过新生代，而是直接放在老年代中，原因是减少每次复制大对象时浪费是时间，所以尽可能减少大对象的创建。</span><br><span class="line"></span><br><span class="line">超大的对象直接不经过新生代就进入老年代</span><br></pre></td></tr></table></figure>
<p>老年代</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在进行Minor GC之前，JVM会先检查老年代最大可用连续空间是否大于新生代历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，否则就进行Full GC（全局GC）。</span><br><span class="line">老年代运用标记-整理算法回收垃圾，将存活的对象向一端移动，清楚边界以外的部分。</span><br></pre></td></tr></table></figure>

<p>永久代</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你可以认为是存放一些类的信息，在上一个章节我们知道我们生成的.class就是存放在这个区域的。一般情况下，我们对于jvm调优都是对新生代和老年代进行调优。一般而言永久代保持默认配置就可以了。</span><br></pre></td></tr></table></figure>

<h4 id="30-线程死锁：（重点掌握）"><a href="#30-线程死锁：（重点掌握）" class="headerlink" title="30.线程死锁：（重点掌握）"></a>30.线程死锁：（重点掌握）</h4><p>死锁是最常见的一种线程活性故障。死锁的起因是多个线程之间相互等待对方而被永远暂停（处于非Runnable）。死锁的产生必须满足如下四个必要条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">资源互斥：一个资源每次只能被一个线程使用</span><br><span class="line"></span><br><span class="line">请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放</span><br><span class="line"></span><br><span class="line">不剥夺条件：线程已经获得的资源，在未使用完之前，不能强行剥夺</span><br><span class="line"></span><br><span class="line">循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系</span><br></pre></td></tr></table></figure>
<p>如何避免死锁的发生？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">粗锁法：使用一个粒度粗的锁来消除“请求与保持条件”，缺点是会明显降低程序的并发性能并且会导致资源的浪费。</span><br><span class="line"></span><br><span class="line">锁排序法：（必须回答出来的点）</span><br><span class="line">指定获取锁的顺序，比如某个线程只有获得A锁和B锁，才能对某资源进行操作，在多线程条件下，如何避免死锁？</span><br><span class="line"></span><br><span class="line">通过指定锁的获取顺序，比如规定，只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可以避免死锁。这通常被认为是解决死锁很好的一种方法。</span><br><span class="line"></span><br><span class="line">使用显式锁中的ReentrantLock.try(long,TimeUnit)来申请锁</span><br></pre></td></tr></table></figure>
<h4 id="31-Java单例写法"><a href="#31-Java单例写法" class="headerlink" title="31.Java单例写法"></a>31.Java单例写法</h4><p>单线程环境懒汉式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *懒汉式的单例模式   </span><br><span class="line"> * @author ywq</span><br><span class="line">*&#x2F;</span><br><span class="line">class Single&#123; </span><br><span class="line">    private static Single s &#x3D; null; </span><br><span class="line">    private Single()&#123;&#125; </span><br><span class="line">    public static  Single getInstance()&#123; </span><br><span class="line">        if(null&#x3D;&#x3D;s) </span><br><span class="line">           s &#x3D; new Single(); </span><br><span class="line">        return s; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized内部锁来解决多线程环境下的线程安全问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 多线程环境下的懒汉式单例模式(DCL，双检锁实现)</span><br><span class="line"> * @author ywq</span><br><span class="line">*&#x2F;</span><br><span class="line">class Single&#123; </span><br><span class="line">    private static Single s &#x3D; null; </span><br><span class="line">    private Single()&#123;&#125; </span><br><span class="line"> </span><br><span class="line">    public static  Single getInstance()&#123;</span><br><span class="line">        if(null&#x3D;&#x3D;s)&#123;</span><br><span class="line">            synchronized(Single.class)&#123;</span><br><span class="line">                if(null&#x3D;&#x3D;s) </span><br><span class="line">                    s &#x3D; new Single(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Instance instance = new Instance()都发生了啥？</p>
<p>具体步骤如下三步所示：</p>
<p>在堆内存上分配对象的内存空间</p>
<p>在堆内存上初始化对象</p>
<p>设置instance指向刚分配的内存地址</p>
<p>第二步和第三步可能会发生重排序，导致引用型变量指向了一个不为null但是也不完整的对象。所以，在多线程下上述的代码会返回一个不完整的对象。根据前面章节所学的内容，我们需要加入一个volatile关键字来禁止指令重排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 多线程环境下的懒汉式单例模式(DCL，双检锁+volatile实现)</span><br><span class="line"> * 加入了volatile变量来禁止指令重排序  </span><br><span class="line"> * @author ywq</span><br><span class="line">*&#x2F;</span><br><span class="line">class Single&#123; </span><br><span class="line">    private static volatile Single s &#x3D; null; </span><br><span class="line">    private Single()&#123;&#125; </span><br><span class="line"> </span><br><span class="line">    public static  Single getInstance()&#123;</span><br><span class="line">        if(null&#x3D;&#x3D;s)&#123;</span><br><span class="line">            synchronized(Single.class)&#123;</span><br><span class="line">                if(null&#x3D;&#x3D;s) </span><br><span class="line">                    s &#x3D; new Single(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>单例模式的优点：单例模式保证了一个类在一个系统中有且只有一个对象实例，减少了系统内存和性能的开销。</p>
<h4 id="32-Thread类的常用方法"><a href="#32-Thread类的常用方法" class="headerlink" title="32.Thread类的常用方法"></a>32.Thread类的常用方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String getName()　　返回该线程的名称。</span><br><span class="line"></span><br><span class="line">void setName(String name)　　改变线程名称，使之与参数 name 相同。</span><br><span class="line"></span><br><span class="line">int getPriority() 　　返回线程的优先级。</span><br><span class="line"></span><br><span class="line">void setPriority(int newPriority) 　　更改线程的优先级。</span><br><span class="line"></span><br><span class="line">boolean isDaemon() 　　测试该线程是否为守护线程。</span><br><span class="line"></span><br><span class="line">void setDaemon(boolean on)　　将该线程标记为守护线程或用户线程。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">static void sleep(long millis)</span><br><span class="line"></span><br><span class="line">void interrupt()　　中断线程。</span><br><span class="line"></span><br><span class="line">static void yield()　　暂停当前正在执行的线程对象，并执行其他线程。</span><br><span class="line"></span><br><span class="line">void join()　　等待该线程终止。</span><br><span class="line"></span><br><span class="line">void run()</span><br><span class="line"></span><br><span class="line">void start()  </span><br><span class="line"></span><br><span class="line">从Object类继承来的方法　　void notify()         void wait()</span><br></pre></td></tr></table></figure>

<h4 id="33-线程交互：互斥与同步"><a href="#33-线程交互：互斥与同步" class="headerlink" title="33. 线程交互：互斥与同步"></a>33. 线程交互：互斥与同步</h4><p>互斥：同一时间只能有一个线程去对临界区进行操作，通过synchronized（intrinsic lock）实现，只有获得lock的线程才能进入synchronized声明的代码块；</p>
<p>同步：线程之间的通信机制；当某些条件不具备时线程处于等待状态，条件满足，需要发出消息来唤醒所有线程；通过wait（）/notify（）/notifyAll（）实现。</p>
<p>Wait Set：可以理解为线程休息室；</p>
<p>　　共享资源/数据又被称为临界区（Critical Section），当有一个线程想要访问共享资源的时候，首先，他需要获得锁，获得锁后进入我们的临界区进行操作，操作过程中，如果发现某些情况不被满足，将调用锁对象上的wait()方法，此时，该线程释放掉锁资源，然后进入到锁对象上的Wait Set，由于这个线程释放掉了我们的锁资源，使得其他线程可以来竞争多资源，所以其他线程获得锁并进入临界区，同时在锁对象上的wait set中有多条线程在等待条件的满足，当我们的当前运行线程执行完某些操作需要通知等待的线程时，调用notify方法将会唤醒所资源所持有的等待区域中的一条线程，是这条线程有机会去进行竞争CPU资源；或者调用notifyAll方法，这时会使wait set中的所有线程被唤醒，从而使得它们有机会在当前线程离开临界资源释放锁之后去竞争临界资源的锁对象。</p>
<h4 id="34-守护线程"><a href="#34-守护线程" class="headerlink" title="34.守护线程"></a>34.守护线程</h4><p>Java线程有两类：</p>
<p>用户线程：运行在前台，执行具体的任务；程序的主线程，连接网络的子线程等都是用户线程；</p>
<p>守护线程：运行在后台，为其他前台线程服务；　</p>
<p>守护线程的特点：一旦所有用户线程都结束运行，守护线程会随JVm一起结束工作；</p>
<p>守护线程的应用：数据库连接池中的监测线程；JVM虚拟机启动后的监测线程，最常见的是垃圾回收线程；<br>　　守护线程的设置：通过调用Thread类的setDaemon(true)方法来设置当前的线程为守护线程；</p>
<p>注意：setDaemon（true）必须在start（）方法之前调用，否则会抛出IllegalThreadStateException异常；守护线程中产生的新线程也是守护线程；不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑；</p>
<h4 id="35-synchronized的使用"><a href="#35-synchronized的使用" class="headerlink" title="35.synchronized的使用"></a>35.synchronized的使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class T &#123;</span><br><span class="line">    private static int count &#x3D; 10;</span><br><span class="line">    public synchronized static void m()&#123; &#x2F;&#x2F;这里等同于synchronized(packagename.T.class)</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;count&#x3D;&quot;+count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void nm()&#123;</span><br><span class="line">        synchronized (T.class)&#123; &#x2F;&#x2F;是class类的对象</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的运行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread0count&#x3D;9</span><br><span class="line">Thread2count&#x3D;8</span><br><span class="line">Thread1count&#x3D;7</span><br><span class="line">Thread3count&#x3D;6</span><br><span class="line">Thread4count&#x3D;5</span><br></pre></td></tr></table></figure>
<p>不加synchronized的运行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread0count&#x3D;9</span><br><span class="line">Thread2count&#x3D;7</span><br><span class="line">Thread1count&#x3D;8</span><br><span class="line">Thread3count&#x3D;6</span><br><span class="line">Thread4count&#x3D;5</span><br></pre></td></tr></table></figure>

<h4 id="36-同步方法和非同步方法是否可以同时调用？–-gt-可以"><a href="#36-同步方法和非同步方法是否可以同时调用？–-gt-可以" class="headerlink" title="36.同步方法和非同步方法是否可以同时调用？–&gt;可以"></a>36.同步方法和非同步方法是否可以同时调用？–&gt;可以</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class T &#123;</span><br><span class="line">    public synchronized void m1()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;m1 start...&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;m1 end...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void m2()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;m2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        T t &#x3D; new T();</span><br><span class="line">        new Thread(t::m1,&quot;t1&quot;).start();</span><br><span class="line">        new Thread(t::m2,&quot;t2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1m1 start...</span><br><span class="line">t2m2</span><br><span class="line">t1m1 end...</span><br></pre></td></tr></table></figure>
<p>　原子变量最主要的一个特点是所有的操作都是原子的，synchronized关键字也能做到对变量的原子操作，但是成本相对较高，需要获取锁对象，释放锁对象，如果不能获取到锁，还需要阻塞在阻塞队列上进行等待</p>
<h4 id="37-对业务写方法加锁，对业务读方法不加锁，容易产生脏读"><a href="#37-对业务写方法加锁，对业务读方法不加锁，容易产生脏读" class="headerlink" title="37.对业务写方法加锁，对业务读方法不加锁，容易产生脏读"></a>37.对业务写方法加锁，对业务读方法不加锁，容易产生脏读</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">    String name;</span><br><span class="line">    double balance;</span><br><span class="line">    public synchronized void set(String name,double balance)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        try&#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        this.balance &#x3D; balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getBalance(String name)&#123;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Account a &#x3D; new Account();</span><br><span class="line">        new Thread(()-&gt;a.set(&quot;zhangsan&quot;,100.0)).start();</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(a.getBalance(&quot;zhangsan&quot;));&#x2F;&#x2F;0.0</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(a.getBalance(&quot;zhangsan&quot;));&#x2F;&#x2F;100.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="38-在继承中，子类重写的同步方法可以调用父类的同步方法"><a href="#38-在继承中，子类重写的同步方法可以调用父类的同步方法" class="headerlink" title="38.在继承中，子类重写的同步方法可以调用父类的同步方法"></a>38.在继承中，子类重写的同步方法可以调用父类的同步方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class T &#123;</span><br><span class="line">    synchronized void m()&#123;</span><br><span class="line">        System.out.println(&quot;m start&quot;);</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;m end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new TT().m();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class TT extends T&#123;</span><br><span class="line">    synchronized void m()&#123;</span><br><span class="line">        System.out.println(&quot;child m start&quot;);</span><br><span class="line">        super.m();&#x2F;&#x2F;可以调用父类的同步方法</span><br><span class="line">        System.out.println(&quot;child m end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="39-出现异常，默认情况下锁会被释放"><a href="#39-出现异常，默认情况下锁会被释放" class="headerlink" title="39.出现异常，默认情况下锁会被释放"></a>39.出现异常，默认情况下锁会被释放</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 程序在执行过程中如果出现异常，默认情况下锁会被释放</span><br><span class="line"> * 所以在执行并发处理的过程中，有异常要小心，不然可能会发生不一致的情况；</span><br><span class="line"> * 比如，在一个web app处理过程中，多个servlet线程共同访问一个资源</span><br><span class="line"> * 这是如果异常处理不合适，在第一个线程中抛出异常，其他线程就会进入同步代码区，</span><br><span class="line"> * 有可能会访问到异常产生时的数据（处理了一半的数据），</span><br><span class="line"> * 因此要非常小心处理同步业务逻辑中的异常</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">public class T &#123;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    synchronized void m()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;start&quot;);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;count&quot;+count);</span><br><span class="line">            try&#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if(count&#x3D;&#x3D;5)&#123;</span><br><span class="line">                int i&#x3D;1&#x2F;0;&#x2F;&#x2F;此处抛出异常，锁被释放，要想不被释放，可以在这里进行catch，然后让循环继续</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        T t &#x3D; new T();</span><br><span class="line">        Runnable r &#x3D; new Runnable()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r,&quot;t1&quot;).start();</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread(r,&quot;t2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="40-volatile的可见性"><a href="#40-volatile的可见性" class="headerlink" title="40.volatile的可见性"></a>40.volatile的可见性</h4><p> volatile 关键字，使一个变量在多个线程间可见，A B 线程都用到一个变量，java默认是A线程中保存一份copy，这样如果B线程修改了该变量，则A未必知道，使用volatile关键字，会让所有线程都会读到变量的修改值；</p>
<p>原理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一：使用volatile关键字会强制将修改的值立即写入主存；</span><br><span class="line">第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</span><br><span class="line">第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</span><br></pre></td></tr></table></figure>

<p>volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说 volatile不能代替synchronized；</p>
<p>volatile 只保证了原子性，而synchronized既保证可见性有保证原子性，但是synchronized太重了；</p>
<h4 id="41-面试题：实现一个容器，提供两个方法add，size，线程1添加10个元素到容器，线程2监控元素的个数，当个数为5时，线程2提示并结束"><a href="#41-面试题：实现一个容器，提供两个方法add，size，线程1添加10个元素到容器，线程2监控元素的个数，当个数为5时，线程2提示并结束" class="headerlink" title="41.面试题：实现一个容器，提供两个方法add，size，线程1添加10个元素到容器，线程2监控元素的个数，当个数为5时，线程2提示并结束"></a>41.面试题：实现一个容器，提供两个方法add，size，线程1添加10个元素到容器，线程2监控元素的个数，当个数为5时，线程2提示并结束</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyContainerVolatile &#123;</span><br><span class="line">    volatile List list &#x3D; new ArrayList();</span><br><span class="line">    public void add(Object o) &#123;  &#x2F;&#x2F;add</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    public int size() &#123;   &#x2F;&#x2F;size</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyContainerVolatile mcv &#x3D; new MyContainerVolatile();</span><br><span class="line">        new Thread( () -&gt; &#123;  &#x2F;&#x2F;该线程负责往list里添加</span><br><span class="line">           for (int i&#x3D;0; i&lt;10; i++) &#123;</span><br><span class="line">               mcv.add(new Object());</span><br><span class="line">               System.out.print(&quot; add-&quot; + i);</span><br><span class="line">               try &#123;</span><br><span class="line">                   Thread.sleep(500);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,&quot;t1&quot;).start();</span><br><span class="line">        new Thread( () -&gt; &#123; &#x2F;&#x2F;该线程一直监测list的size，直到size&#x3D;5</span><br><span class="line">            while(true) &#123;  &#x2F;&#x2F;一直监测着，很浪费CPU</span><br><span class="line">                if(mcv.size() &#x3D;&#x3D; 5) &#123;  &#x2F;&#x2F;此处未加同步，仍然可能会出现t1中又一次++为6了，才break</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot; t2结束 &quot;);</span><br><span class="line">        &#125;,&quot;t2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码能解决问题，但t2线程的死循环很浪费CPU，影响性能！更优方法是使用wait和notify，请参看下例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyContainerWaitNotify &#123;</span><br><span class="line">    volatile List list &#x3D; new ArrayList();</span><br><span class="line">    public void add(Object o) &#123;</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyContainerWaitNotify mcwn &#x3D; new MyContainerWaitNotify();</span><br><span class="line">        final Object lock &#x3D; new Object();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.print(&quot; ***线程t2启动*** &quot;);</span><br><span class="line">                if (mcwn.size() !&#x3D; 5) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        lock.wait();  &#x2F;&#x2F;size不等于5时，就一直在那等着，直到被t1叫醒</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(&quot; ***线程t2结束*** &quot;);</span><br><span class="line">                lock.notify();  &#x2F;&#x2F;通知t1继续执行</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t2&quot;).start();</span><br><span class="line"> </span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                for(int i&#x3D;0; i&lt;10; i++) &#123;</span><br><span class="line">                    mcwn.add(new Object());</span><br><span class="line">                    System.out.print(&quot; add-&quot;  + i);</span><br><span class="line">                    if (mcwn.size() &#x3D;&#x3D; 5) &#123;</span><br><span class="line">                        lock.notify();  &#x2F;&#x2F;唤醒另一个线程t2，本线程继续执行，直至synchronized包裹的代码块结束或者调用了wait</span><br><span class="line">                        try &#123;</span><br><span class="line">                            lock.wait(); &#x2F;&#x2F;释放锁，让t2得以执行</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;t1&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：wait会释放锁，但notify不会，本代码会执行到wait或synchronized块结束才释放锁；</p>
<p>但是，上述的方法还是过于繁琐，Java提供了门闩；</p>
<p>使用CountDownLatch（门闩）的await和countdown方法替代wait和notify方法来进行通知：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyContainerLatch &#123;</span><br><span class="line">    volatile List list &#x3D; new ArrayList(); &#x2F;&#x2F;添加volatile，使t2能够得到通知</span><br><span class="line">    public void add(Object o) &#123;</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyContainerLatch mcl &#x3D; new MyContainerLatch();</span><br><span class="line">        CountDownLatch latch &#x3D; new CountDownLatch(1);  &#x2F;&#x2F;当1变成0时，门就开了</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.print(&quot; *t2启动* &quot;);</span><br><span class="line">            if (mcl.size() !&#x3D; 5) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    latch.await();  &#x2F;&#x2F;等待不需要锁定一个对象</span><br><span class="line">                    &#x2F;&#x2F;latch.await(5000,TimeUnit.MILLISECONDS); &#x2F;&#x2F;也可以指定等待时间</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot; *t2结束* &quot;);</span><br><span class="line">        &#125;,&quot;t2&quot;).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            System.out.print(&quot; *t1启动* &quot;);</span><br><span class="line">            for (int i&#x3D;0; i&lt;10; i++) &#123;</span><br><span class="line">                mcl.add(new Object());</span><br><span class="line">                System.out.print(&quot; add-&quot; + i);</span><br><span class="line">                if (mcl.size() &#x3D;&#x3D; 5) &#123;</span><br><span class="line">                    latch.countDown(); &#x2F;&#x2F;打开门闩，让t2得以执行。调用一次countDown，就减1</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot; *t1结束* &quot;);</span><br><span class="line"> </span><br><span class="line">        &#125;,&quot;t1&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当不涉及同步，只涉及锁定，用synchronized+wait/notify就显得太重了。这时应该考虑CountDownLatch/cyclicbarrier/semephore</p>
<h4 id="42-ReentrantLock-重入锁"><a href="#42-ReentrantLock-重入锁" class="headerlink" title="42.ReentrantLock-重入锁"></a>42.ReentrantLock-重入锁</h4><p>Java中实现锁通常有两种方式，一种是使用synchronized关键字，另一种是Lock：</p>
<p><a href="https://img2018.cnblogs.com/blog/636698/201905/636698-20190527070802872-536965764.png" target="_blank" rel="noopener">synchronized和Lock的区别</a></p>
<p> ReentrantLock替代synchronized</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReentrantLockTest1 &#123;</span><br><span class="line">    Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">    void m1() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();  &#x2F;&#x2F;加锁  &#x2F;&#x2F;相当于synchronized(this)</span><br><span class="line">            for (int i&#x3D;0; i&lt;10; i++) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                System.out.print(&quot; &quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();  &#x2F;&#x2F;释放锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void m2() &#123;</span><br><span class="line">        lock.lock();  &#x2F;&#x2F;加锁</span><br><span class="line">        System.out.print(&quot; m2()... &quot;);</span><br><span class="line">        lock.unlock();  &#x2F;&#x2F;释放锁</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLockTest1 r1 &#x3D; new ReentrantLockTest1();</span><br><span class="line">        new Thread(r1::m1).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread(r1::m2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="43-写一个固定容量的同步容器，有put和get方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用"><a href="#43-写一个固定容量的同步容器，有put和get方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用" class="headerlink" title="43.写一个固定容量的同步容器，有put和get方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用"></a>43.写一个固定容量的同步容器，有put和get方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用</h4><p>使用wait和notify/notifyAll来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyContainer1&lt;T&gt; &#123;</span><br><span class="line">    final private LinkedList&lt;T&gt; lists &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    final private int MAX &#x3D;10;</span><br><span class="line">    private int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void put(T t)&#123;</span><br><span class="line">        while(lists.size()&#x3D;&#x3D;MAX)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lists.add(t);</span><br><span class="line">        ++count;</span><br><span class="line">        this.notifyAll();&#x2F;&#x2F;通知消费者线程进行消费</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized T get()&#123;</span><br><span class="line">        T t &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;为什么用while? wait 99.9%情况下都是和while一起用的</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        while(lists.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t &#x3D; lists.removeFirst();</span><br><span class="line">        count--;</span><br><span class="line">        this.notifyAll();</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        MyContainer1&lt;String&gt; c &#x3D; new MyContainer1&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;启动消费者线程</span><br><span class="line">        for(int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                for(int j&#x3D;0; j&lt;5; j++)&#123;</span><br><span class="line">                    System.out.println(c.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;c&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;启动生产者线程</span><br><span class="line">        for(int i&#x3D;0;i&lt;2;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                for(int j &#x3D;0;j&lt;25;j++)&#123;</span><br><span class="line">                    c.put(Thread.currentThread().getName()+&quot; &quot;+j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;p&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Lock和Condition的方式可以更加精确地指定哪些线程被唤醒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyContainer2&lt;T&gt; &#123;</span><br><span class="line">    final private LinkedList&lt;T&gt; lists&#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    final private int MAX &#x3D;20;</span><br><span class="line">    private int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">    private Condition producer &#x3D; lock.newCondition();</span><br><span class="line">    private Condition consumer &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void put(T t)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            while(lists.size()&#x3D;&#x3D;MAX)&#123;</span><br><span class="line">                producer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            lists.add(t);</span><br><span class="line">            ++count;</span><br><span class="line">            consumer.signalAll();</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T get()&#123;</span><br><span class="line">        T t &#x3D; null;</span><br><span class="line">        try&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            while(lists.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            t&#x3D;lists.removeFirst();</span><br><span class="line">            count--;</span><br><span class="line">            producer.signalAll();</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        MyContainer2&lt;String&gt; c &#x3D; new MyContainer2();</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                for(int j&#x3D;0; j&lt;5; j++)&#123;</span><br><span class="line">                    System.out.println(c.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;c&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;启动生产者线程</span><br><span class="line">        for(int i&#x3D;0;i&lt;2;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                for(int j &#x3D;0;j&lt;25;j++)&#123;</span><br><span class="line">                    c.put(Thread.currentThread().getName()+&quot; &quot;+j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;p&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="44-有N张火车票，每张票都有一个编号，同时有10个窗口对外售票"><a href="#44-有N张火车票，每张票都有一个编号，同时有10个窗口对外售票" class="headerlink" title="44.有N张火车票，每张票都有一个编号，同时有10个窗口对外售票"></a>44.有N张火车票，每张票都有一个编号，同时有10个窗口对外售票</h4><p>以下程勋存在重复销售，超量销售问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TicketSeller1 &#123;</span><br><span class="line">    static List&lt;String&gt; tickets &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F;初始化，放票</span><br><span class="line">    static&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;10000; i++)</span><br><span class="line">            tickets.add(&quot;票编号：&quot;+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        &#x2F;&#x2F;启动10个线程不断往外卖票</span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                while(tickets.size()&gt;0)&#123;</span><br><span class="line">                    System.out.println(&quot;销售了--&quot;+tickets.remove(0));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进人存在判断与操作分离了（虽然在vector中size和remove方法都是原子的）问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TicketSeller2 &#123;</span><br><span class="line">    &#x2F;&#x2F;vector本身就是一个同步容器，它所有的方法都是加锁的</span><br><span class="line">    static Vector&lt;String&gt; tickets &#x3D; new Vector&lt;&gt;();</span><br><span class="line">    static&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;10000; i++)</span><br><span class="line">            tickets.add(&quot;票编号：&quot;+i);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                while(tickets.size()&gt;0)&#123;</span><br><span class="line">                    &#x2F;*</span><br><span class="line">                    try&#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(10);</span><br><span class="line">                    &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;*&#x2F;</span><br><span class="line">                    System.out.println(&quot;销售了--&quot;+tickets.remove(0));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再改进仍存在加锁效率不高，尤其是每销售一张票都要把整个队列给锁定；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TicketSeller3 &#123;</span><br><span class="line">    static List&lt;String&gt; tickets &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    static&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;10000; i++)</span><br><span class="line">            tickets.add(&quot;票编号：&quot;+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        &#x2F;&#x2F;启动10个线程不断往外卖票</span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    synchronized (tickets)&#123;</span><br><span class="line">                        if(tickets.size()&lt;&#x3D;0) break;</span><br><span class="line">                        try&#123;</span><br><span class="line">                            TimeUnit.SECONDS.sleep(10);</span><br><span class="line">                        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.out.println(&quot;销售了--&quot;+tickets.remove(0));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入并发容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TicketSeller4 &#123;</span><br><span class="line">    &#x2F;&#x2F;并发容器</span><br><span class="line">    static Queue&lt;String&gt; tickets &#x3D; new ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">    static&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;1000; i++)&#123;</span><br><span class="line">            tickets.add(&quot;票编号：&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    &#x2F;&#x2F;poll从头往外拿一个数据，是同步的</span><br><span class="line">                    String s &#x3D; tickets.poll();</span><br><span class="line">                    if(s&#x3D;&#x3D;null) break;</span><br><span class="line">                    else System.out.println(&quot;销售了--&quot;+s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if(s==null) break;虽然不是原子性的，但是我们判断以后没有对队列作修改操作，所以这里不会出错。</p>
<h4 id="45-类的加载机制"><a href="#45-类的加载机制" class="headerlink" title="45.类的加载机制"></a>45.类的加载机制</h4><p>类的生命周期一共分为5个阶段，加载、连接、初始化、使用、卸载。</p>
<p><a href="https://imgchr.com/i/8wNbWt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/18/8wNbWt.md.png" alt="8wNbWt.md.png"></a></p>
<p>加载：类的加载过程主要完成3件事件，1.通过类的全限定名来获取定义此类的二进制字节流，2.将这个类字节流代表的静态存储结构转为方法区的运行时数据结构，3.在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。这个过程主要是类加载器完成的。</p>
<p>连接：这个过程分3个阶段(校验，准备，解析)完成。首先是校验，此阶段主要校验class文件包含的信息是否符合jvm的规范。具体的校验通过对文件格式，元数据，字节码，符号引用验证来完成。然后是准备，此阶段为类变量分配内存，并将其初始化为默认值。最后是解析，即把类型中的符号引用转换成为直接引用。具体的解析有4种，1.类或接口的解析，2.字段解析，3.类方法解析，4.接口方法解析。完成这3个阶段就完成了类的连接。</p>
<p>初始化：即执行类的构造器方法的过程。有5种方法可以完成初始化：1.调用new方法，2.使用Class类的newInstance方法(反射机制)，3.使用Constructor类的newInstance方法(反射机制)，4.使用Clone方法创建对象，5.使用(反)序列化机制创建对象</p>
<p>使用：完成类的初始化后，就可以对类进行实例化，在程序中进行使用了</p>
<p>卸载：当类被加载，连接和初始化后，它的生命周期就始了，当代表类的class对象不在被引用时，class对象就会结束生命周期，类在方法区内的数据就会被卸载。因此一个类何时结束生命，取决于代表它的class对象何时结束生命。</p>
<h4 id="46-JVM调优"><a href="#46-JVM调优" class="headerlink" title="46.JVM调优"></a>46.JVM调优</h4><p>jvm调优没有一个固定模板配置说必须如何操作，它需要根据系统的情况不同对待。</p>
<p>但是可以有如下建议：</p>
<p>1、初始化内存和最大内存尽量保持一致，避免内存不够用继续扩充内存。最大内存不要超过物理内存，例如内存8g，你可以设置最大内存4g/6g但是不能超过8g否则加载类的时候没有空间会报错。</p>
<p>2、gc/full gc频率不要太高、每次gc时间不要太长、根据系统应用来定。</p>
<h4 id="47-对象的内存布局"><a href="#47-对象的内存布局" class="headerlink" title="47.对象的内存布局"></a>47.对象的内存布局</h4><p>对象头(Header)：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p>
<p>实例数据(Instance Data)：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p>
<p>对齐填充(Padding)：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</p>
<h4 id="48-对象的访问定位"><a href="#48-对象的访问定位" class="headerlink" title="48.对象的访问定位"></a>48.对象的访问定位</h4><p>通过句柄访问</p>
<p>Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。详情见图</p>
<p><a href="https://imgchr.com/i/8wYPW6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/18/8wYPW6.png" alt="8wYPW6.png"></a></p>
<p>使用直接指针访问</p>
<p>reference 中直接存储对象地址</p>
<p><a href="https://imgchr.com/i/8wYKYt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/18/8wYKYt.md.png" alt="8wYKYt.md.png"></a></p>
<p>比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p>
<h4 id="49-Thread-类中的start-和-run-方法有什么区别？"><a href="#49-Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="49.Thread 类中的start() 和 run() 方法有什么区别？"></a>49.Thread 类中的start() 和 run() 方法有什么区别？</h4><p>这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部 调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启 动，start()方法才会启动新线程。</p>
<h4 id="50-Java中Runnable和Callable有什么不同？"><a href="#50-Java中Runnable和Callable有什么不同？" class="headerlink" title="50. Java中Runnable和Callable有什么不同？"></a>50. Java中Runnable和Callable有什么不同？</h4><p>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在 JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。</p>
<h4 id="51-Java中CyclicBarrier-和-CountDownLatch有什么不同？"><a href="#51-Java中CyclicBarrier-和-CountDownLatch有什么不同？" class="headerlink" title="51.Java中CyclicBarrier 和 CountDownLatch有什么不同？"></a>51.Java中CyclicBarrier 和 CountDownLatch有什么不同？</h4><p>CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。</p>
<h4 id="52-如何在两个线程间共享数据？"><a href="#52-如何在两个线程间共享数据？" class="headerlink" title="52.如何在两个线程间共享数据？"></a>52.如何在两个线程间共享数据？</h4><p>你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。</p>
<h4 id="53-为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#53-为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="53.为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>53.为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h4><p>这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在 Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通 过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁 就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象</p>
<h4 id="52-什么是线程安全？Vector是一个线程安全类吗？"><a href="#52-什么是线程安全？Vector是一个线程安全类吗？" class="headerlink" title="52. 什么是线程安全？Vector是一个线程安全类吗？"></a>52. 什么是线程安全？Vector是一个线程安全类吗？</h4><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量 的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分 成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的</p>
<h4 id="53-什么是ThreadLocal变量？"><a href="#53-什么是ThreadLocal变量？" class="headerlink" title="53.什么是ThreadLocal变量？"></a>53.什么是ThreadLocal变量？</h4><p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被 彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因 为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通 过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是 ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。</p>
<h4 id="54-为什么你应该在循环中检查等待条件"><a href="#54-为什么你应该在循环中检查等待条件" class="headerlink" title="54.为什么你应该在循环中检查等待条件?"></a>54.为什么你应该在循环中检查等待条件?</h4><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来 时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方 法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《Effective Java》这本书中的线程和同步章节。</p>
<h4 id="55-Java中的同步集合与并发集合有什么区别？"><a href="#55-Java中的同步集合与并发集合有什么区别？" class="headerlink" title="55.Java中的同步集合与并发集合有什么区别？"></a>55.Java中的同步集合与并发集合有什么区别？</h4><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在 多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分 区等现代技术提高了可扩展性。</p>
<h4 id="56-Java中堆和栈有什么不同？"><a href="#56-Java中堆和栈有什么不同？" class="headerlink" title="56.Java中堆和栈有什么不同？"></a>56.Java中堆和栈有什么不同？</h4><p>为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈 调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己 的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p>
<h4 id="57-Java中活锁和死锁有什么区别？"><a href="#57-Java中活锁和死锁有什么区别？" class="headerlink" title="57.Java中活锁和死锁有什么区别？"></a>57.Java中活锁和死锁有什么区别？</h4><p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个 人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者 进程的状态可以改变但是却不能继续执行.</p>
<h4 id="58-怎么检测一个线程是否拥有锁？"><a href="#58-怎么检测一个线程是否拥有锁？" class="headerlink" title="58.怎么检测一个线程是否拥有锁？"></a>58.怎么检测一个线程是否拥有锁？</h4><p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p>
<h4 id="59-JVM中哪个参数是用来控制线程的栈堆栈小的"><a href="#59-JVM中哪个参数是用来控制线程的栈堆栈小的" class="headerlink" title="59.JVM中哪个参数是用来控制线程的栈堆栈小的"></a>59.JVM中哪个参数是用来控制线程的栈堆栈小的</h4><p>这个问题很简单， -Xss参数用来控制线程的堆栈大小。</p>
<h4 id="60-Java中synchronized-和-ReentrantLock-有什么不同？"><a href="#60-Java中synchronized-和-ReentrantLock-有什么不同？" class="headerlink" title="60. Java中synchronized 和 ReentrantLock 有什么不同？"></a>60. Java中synchronized 和 ReentrantLock 有什么不同？</h4><p>Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法</p>
<h4 id="61-有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#61-有三个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="61.有三个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>61.有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h4><p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。</p>
<h4 id="62-Java中Semaphore是什么？"><a href="#62-Java中Semaphore是什么？" class="headerlink" title="62.Java中Semaphore是什么？"></a>62.Java中Semaphore是什么？</h4><p>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前 会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采 取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。</p>
<h4 id="63-volatile-变量和-atomic-变量有什么不同？"><a href="#63-volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="63.volatile 变量和 atomic 变量有什么不同？"></a>63.volatile 变量和 atomic 变量有什么不同？</h4><p>这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性 的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<h4 id="64-写出3条你遵循的多线程最佳实践"><a href="#64-写出3条你遵循的多线程最佳实践" class="headerlink" title="64.写出3条你遵循的多线程最佳实践"></a>64.写出3条你遵循的多线程最佳实践</h4><p>给你的线程起个有意义的名字。<br>这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</p>
<p>避免锁定和缩小同步的范围。<br>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</p>
<p>多用同步类少用wait 和 notify。<br>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断 优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</p>
<p>多用并发集合少用同步集合。<br>这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。</p>
<h4 id="65-Java多线程中调用wait-和-sleep-方法有什么不同？"><a href="#65-Java多线程中调用wait-和-sleep-方法有什么不同？" class="headerlink" title="65.Java多线程中调用wait() 和 sleep()方法有什么不同？"></a>65.Java多线程中调用wait() 和 sleep()方法有什么不同？</h4><p>Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而 sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。</p>
<h4 id="66-java的反射机制"><a href="#66-java的反射机制" class="headerlink" title="66.java的反射机制"></a>66.java的反射机制</h4><p>java的反射机制是在运行状态中，对于任意一个类（Class）都能知道他的属性（Field）和方法（Method），对于任意一个对象都能够调用它的方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。它允许正在运行的java程序观测甚至是修改程序的动态行为。</p>
<p>Java中反射有如下几种实现方式：</p>
<p>1、通过Class.forName()方法加载字符串，就可以得到该字符串做代表的Class对象。</p>
<p>2、通过类名调用class属性得到该类的Class对象。</p>
<p>3、调用实例的getClass()方法。</p>
<p>4、如果是基本类型的包装类，则可以通过调用包装类的Type属性来获得该包装类的Class对象。</p>
<p>反射在java中的应用</p>
<p>1、java集成开发环境，每当我们敲入点号时，IDE便会根据点号前的内容，动态展示可以访问的字段和方法。</p>
<p>2、java调试器，它能够在调试过程中枚举某一对象所有字段的值。</p>
<p>3、web开发中，我们经常接触到各种配置的通用框架。为保证框架的可扩展性，他往往借助java的反射机制。例如Spring框架的依赖反转（IOC）便是依赖于反射机制。</p>
<h4 id="67-三大集合接口的引出"><a href="#67-三大集合接口的引出" class="headerlink" title="67.三大集合接口的引出"></a>67.三大集合接口的引出</h4><p>Java中的常见集合可以概括如下。</p>
<ul>
<li>Map接口和Collection接口是所有集合框架的父接口</li>
<li>Collection接口的子接口包括：Set接口和List接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、LinkedHashMap、ConcurrentHashMap以及Properties等</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ul>
<h2 id="二、C-面试笔记"><a href="#二、C-面试笔记" class="headerlink" title="二、C++面试笔记"></a>二、C++面试笔记</h2><h3 id="C-内容"><a href="#C-内容" class="headerlink" title="C++内容"></a>C++内容</h3><h4 id="1-物理内存和虚拟内存"><a href="#1-物理内存和虚拟内存" class="headerlink" title="1.物理内存和虚拟内存"></a>1.物理内存和虚拟内存</h4><ul>
<li>每个进程都认为自己独立的享有着计算机的内存</li>
<li>虚拟内存：程序运行时，会进行一系列的操作。<br>进程会构建自己的虚拟地址空间（进程地址空间），该地址空间所有进程都独立的享有一份，如果是32位机器，则会创建2^32（4G）大小的地址空间 ，如果是64位机器，可以创建2^64大小的地址空间（目前所有的程序都没有这么大），创建出来的虚拟地址空间中（以32位机器为例，一般编译器可以选择使用32位或者64位），其中1G为操作系统所用，剩下3G空间为用户所用</li>
<li>进程的虚拟地址通过页表访问物理内存，保证了多个进程访问物理内存之间的不冲突性。</li>
<li>每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址</li>
<li>当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。</li>
<li>在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</li>
</ul>
<h4 id="2-虚拟内存机制的优点"><a href="#2-虚拟内存机制的优点" class="headerlink" title="2.虚拟内存机制的优点"></a>2.虚拟内存机制的优点</h4><ul>
<li>在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</li>
<li>当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存</li>
<li>在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。</li>
</ul>
<h4 id="3-C-中的堆栈"><a href="#3-C-中的堆栈" class="headerlink" title="3.C++中的堆栈"></a>3.C++中的堆栈</h4><p><img src="https://img-blog.csdnimg.cn/20191031203641608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5NjY4NQ==,size_16,color_FFFFFF,t_70" alt></p>
<ul>
<li>栈又叫做堆栈，非静态局部变量/函数参数/返回值等，都在其中存放，栈是向下增长的。</li>
<li>内存映射段是装在动静态库，用户使用系统接口创建空想内存的地址区。（本节不详细说明）</li>
<li>堆，用于程序运行时动态内存管理分配的区域，与栈区相对，向上增长。</li>
<li>数据段是用来存储全局变量和静态数据的区域</li>
<li>代码段是用来存储代码的区域。</li>
</ul>
<h4 id="4-C语言中管理内存的方式"><a href="#4-C语言中管理内存的方式" class="headerlink" title="4.C语言中管理内存的方式"></a>4.C语言中管理内存的方式</h4><ul>
<li>malloc函数：分配一个大小size字节的内存块，返回指向该块开头的指针。</li>
<li>alloc函数：分配num个元素组成的内存块，每个元素的大小都是size大小，并将其所有位初始化为零。分配一个(num * size)字节的零初始化内存块</li>
<li>realloc：先判断当前的指针是否有足够的连续空间，如果有，扩大指针指向的地址，并且将新地址的指针返回，如果空间不够，先按照size指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来内存区域（注意：原来指针是自动释放，不需要使用free），同时返回新分配的内存区域的首地址。即重新分配存储器块的地址</li>
<li>free：简单来说，释放一个指针所指向的空间</li>
</ul>
<h4 id="5-free-与delete的区别"><a href="#5-free-与delete的区别" class="headerlink" title="5.free()与delete的区别"></a>5.free()与delete的区别</h4><ul>
<li><p>1、new/delete是C++的操作符，而malloc/free是C中的函数。</p>
</li>
<li><p>2、new做两件事，一是分配内存，二是调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。</p>
</li>
<li><p>3、new建立的是一个对象，而malloc分配的是一块内存；new建立的对象可以用成员函数访问，不要直接访问它的地址空间；malloc分配的是一块内存区域，用指针访问，可以在里面移动指针；new出来的指针是带有类型信息的，而malloc返回的是void指针。</p>
</li>
<li><p>4、new/delete是保留字，不需要头文件支持；malloc/free需要头文件库函数支持</p>
</li>
</ul>
<h4 id="6-进程和程序的区别和联系"><a href="#6-进程和程序的区别和联系" class="headerlink" title="6.进程和程序的区别和联系"></a>6.进程和程序的区别和联系</h4><ul>
<li>1、进程是动态的，而程序是静态的。</li>
<li>2、进程有一定的生命期，而程序是指令的集合，本身无“运动”的含义。没有建立进程的程序不能作为1个独立单位得到操作系统的认可。</li>
<li>3、1个程序可以对应多个进程，但1个进程只能对应1个程序。进程和程序的关系犹如演出和剧本的关系。</li>
<li>4、进程和程序的组成不同。从静态角度看，进程由程序、数据和进程控制块（PCB）三部分组成。而程序是一组有序的指令集合</li>
</ul>
<h4 id="7-static关键字的作用"><a href="#7-static关键字的作用" class="headerlink" title="7.static关键字的作用"></a>7.static关键字的作用</h4><ul>
<li><p>对于函数定义和代码块之外的变量声明，static修改标识符的链接属性，由默认的external变为internal，作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。</p>
</li>
<li><p>对于代码块内部的变量声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。</p>
</li>
<li><p>对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用</p>
</li>
<li><p>对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。一样，它们都属于类的静态成员，它们都不是对象成员。</p>
</li>
</ul>
<h4 id="8-C-和C的区别"><a href="#8-C-和C的区别" class="headerlink" title="8.C++和C的区别"></a>8.C++和C的区别</h4><p>设计思想上：</p>
<ul>
<li>C++是面向对象的语言，而C是面向过程的结构化编程语言</li>
</ul>
<p>语法上：</p>
<ul>
<li><p>C++具有封装、继承和多态三种特性</p>
</li>
<li><p>C++相比C，增加多许多类型安全的功能，比如强制类型转换、</p>
</li>
<li><p>C++支持范式编程，比如模板类、函数模板等</p>
</li>
</ul>
<h4 id="9-C-中四种cast转换"><a href="#9-C-中四种cast转换" class="headerlink" title="9.C++中四种cast转换"></a>9.C++中四种cast转换</h4><ul>
<li>1、const_cast:用于将const变量转为非const</li>
<li>2、static_cast: 用于各种隐式转换， 比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</li>
<li>dynamic_cast:用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常</li>
<li>reinterpret_cast:几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</li>
<li>为什么不使用C的强制转换？<br>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</li>
</ul>
<h4 id="10-C-C-中指针和引用的区别？"><a href="#10-C-C-中指针和引用的区别？" class="headerlink" title="10.C/C++ 中指针和引用的区别？"></a>10.C/C++ 中指针和引用的区别？</h4><ul>
<li><p>1.指针有自己的一块空间，而引用只是一个别名；</p>
</li>
<li><p>2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</p>
</li>
<li><p>3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</p>
</li>
<li><p>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</p>
</li>
<li><p>5.可以有const指针，但是没有const引用；</p>
</li>
<li><p>6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</p>
</li>
<li><p>7.指针可以有多级指针（**p），而引用只有一级；</p>
</li>
<li><p>8.指针和引用使用++运算符的意义不一样；</p>
</li>
<li><p>9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p>
</li>
</ul>
<h4 id="11-数组和指针的区别"><a href="#11-数组和指针的区别" class="headerlink" title="11.数组和指针的区别"></a>11.数组和指针的区别</h4><ul>
<li>指针：保存数据的地址。间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据。通常用于动态的数据结构。通过Malloc分配内存，free释放内存。通常指向匿名数据，操作匿名函数</li>
<li>保存数据。直接访问数据。通常用于固定数目且数据类型相同的元素。隐式的分配和删除。自身即为数据名。</li>
</ul>
<h4 id="12-野指针"><a href="#12-野指针" class="headerlink" title="12.野指针"></a>12.野指针</h4><ul>
<li>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</li>
</ul>
<h4 id="13-C-中的智能指针"><a href="#13-C-中的智能指针" class="headerlink" title="13.C++中的智能指针"></a>13.C++中的智能指针</h4><ul>
<li>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。</li>
<li>最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配</li>
<li>对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。</li>
<li>并可以通过get函数获得普通指针。</li>
</ul>
<h4 id="14-智能指针有没有内存泄露的情况"><a href="#14-智能指针有没有内存泄露的情况" class="headerlink" title="14.智能指针有没有内存泄露的情况"></a>14.智能指针有没有内存泄露的情况</h4><ul>
<li>当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</li>
<li>智能指针的内存泄漏如何解决<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从</span><br><span class="line">而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管</span><br><span class="line">理的对象是否已经被释放，从而避免非法访问。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="15-C-中析构函数的作用"><a href="#15-C-中析构函数的作用" class="headerlink" title="15.C++中析构函数的作用"></a>15.C++中析构函数的作用</h4><ul>
<li>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</li>
<li>析构函数名也应与类名相同，只是在函数名前面加一个位取反符，例如stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</li>
<li>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</li>
</ul>
<h4 id="16-C-中虚函数的作用和多态"><a href="#16-C-中虚函数的作用和多态" class="headerlink" title="16.C++中虚函数的作用和多态"></a>16.C++中虚函数的作用和多态</h4><ul>
<li>C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。</li>
<li>当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，[即B b; A a = &b;] 父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（如果不使用virtual方法，请看后面★*），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。</li>
<li>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。</li>
</ul>
<h4 id="17-虚函数的底层实现机制"><a href="#17-虚函数的底层实现机制" class="headerlink" title="17.虚函数的底层实现机制"></a>17.虚函数的底层实现机制</h4><ul>
<li>编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，每个类使用一个虚函数表，每个类对象用一个虚表指针。</li>
<li>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</li>
</ul>
<h4 id="18-为什么父类的析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数"><a href="#18-为什么父类的析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数" class="headerlink" title="18.为什么父类的析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数"></a>18.为什么父类的析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</h4><ul>
<li><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
</li>
<li><p>C ++ 默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
</li>
</ul>
<h4 id="19-函数指针"><a href="#19-函数指针" class="headerlink" title="19.函数指针"></a>19.函数指针</h4><ul>
<li>函数指针是指向函数的指针变量。</li>
<li>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。</li>
</ul>
<h4 id="20-fork函数"><a href="#20-fork函数" class="headerlink" title="20.fork函数"></a>20.fork函数</h4><ul>
<li>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。</li>
<li>在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</li>
<li>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。</li>
<li>Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</li>
</ul>
<h4 id="21-静态函数和虚函数的区别"><a href="#21-静态函数和虚函数的区别" class="headerlink" title="21.静态函数和虚函数的区别"></a>21.静态函数和虚函数的区别</h4><p>参考回答：</p>
<ul>
<li>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。</li>
<li>虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销</li>
</ul>
<h4 id="22-strcpy和strlen"><a href="#22-strcpy和strlen" class="headerlink" title="22.strcpy和strlen"></a>22.strcpy和strlen</h4><ul>
<li>strcpy是字符串拷贝函数，原型：<br>char <em>strcpy(char</em> dest, const char *src);从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。</li>
<li>strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</li>
</ul>
<h4 id="23-请你来写个函数在main函数执行前先运行"><a href="#23-请你来写个函数在main函数执行前先运行" class="headerlink" title="23.请你来写个函数在main函数执行前先运行"></a>23.请你来写个函数在main函数执行前先运行</h4><p>__attribute((constructor))是gcc扩展，标记这个函数应当在main函数之前执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__attribute((constructor))void before()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;before main\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-以下四行代码的区别是什么？-const-char-arr-“123”-char-brr-“123”-const-char-crr-“123”-char-drr-“123”"><a href="#24-以下四行代码的区别是什么？-const-char-arr-“123”-char-brr-“123”-const-char-crr-“123”-char-drr-“123”" class="headerlink" title="24.以下四行代码的区别是什么？ const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”;"></a>24.以下四行代码的区别是什么？ const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”;</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const char * arr &#x3D; &quot;123&quot;;</span><br><span class="line">&#x2F;&#x2F;字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char * brr &#x3D; &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改&quot;123&quot;的值</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const char crr[] &#x3D; &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char drr[] &#x3D; &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;字符串123保存在栈区，可以通过drr去修改</span><br></pre></td></tr></table></figure>

<h4 id="25-C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#25-C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="25.C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>25.C++里是怎么定义常量的？常量存放在内存的哪个位置？</h4><ul>
<li>常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。</li>
<li>对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局/静态存储区。</li>
<li>对于字面值常量，常量存放在常量存储区</li>
</ul>
<h4 id="26-如果同时定义了两个函数，一个带const，一个不带，会有问题吗？"><a href="#26-如果同时定义了两个函数，一个带const，一个不带，会有问题吗？" class="headerlink" title="26.如果同时定义了两个函数，一个带const，一个不带，会有问题吗？"></a>26.如果同时定义了两个函数，一个带const，一个不带，会有问题吗？</h4><ul>
<li>不会，这相当于函数的重载。</li>
</ul>
<h4 id="27-C-函数栈空间的最大值"><a href="#27-C-函数栈空间的最大值" class="headerlink" title="27.C++函数栈空间的最大值"></a>27.C++函数栈空间的最大值</h4><p>默认是1M，不过可以调整</p>
<h4 id="28-说一说extern“C”"><a href="#28-说一说extern“C”" class="headerlink" title="28.说一说extern“C”"></a>28.说一说extern“C”</h4><ul>
<li>C++调用C函数需要extern C，因为C语言没有函数重载。</li>
</ul>
<h4 id="29-隐式类型转换"><a href="#29-隐式类型转换" class="headerlink" title="29.隐式类型转换"></a>29.隐式类型转换</h4><ul>
<li>首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换。</li>
<li>其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。</li>
</ul>
<h4 id="30-RTTI是什么"><a href="#30-RTTI是什么" class="headerlink" title="30.RTTI是什么"></a>30.RTTI是什么</h4><ul>
<li>RTTI 是“Runtime Type Information”的缩写，意思是：运行时类型信息。它提供了运行时确定对象类型的方法。</li>
<li>两个重要的 RTTI 运算符的使用方法，它们是 typeid 和 dynamic_cast。</li>
<li>typeid的主要作用就是让用户知道当前的变量是什么类型的，对于内置数据类型以及自定义数据类型都生效</li>
<li>dynamic_cast主要用于在多态的时候，它允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构中安全地转换类型，把基类指针（引用）转换为派生类指针（引用）</li>
</ul>
<h4 id="31-虚函数表具体是怎样实现运行时多态的"><a href="#31-虚函数表具体是怎样实现运行时多态的" class="headerlink" title="31.虚函数表具体是怎样实现运行时多态的?"></a>31.虚函数表具体是怎样实现运行时多态的?</h4><ul>
<li>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换；</li>
<li>对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</li>
</ul>
<h4 id="32-C语言是怎么进行函数调用的？"><a href="#32-C语言是怎么进行函数调用的？" class="headerlink" title="32.C语言是怎么进行函数调用的？"></a>32.C语言是怎么进行函数调用的？</h4><ul>
<li>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。</li>
<li>调用前，先把返回地址压栈，然后把当前函数的esp指针压栈</li>
</ul>
<h4 id="33-C语言参数压栈顺序？"><a href="#33-C语言参数压栈顺序？" class="headerlink" title="33.C语言参数压栈顺序？"></a>33.C语言参数压栈顺序？</h4><p>从右到左</p>
<h4 id="34-C-如何处理返回值？"><a href="#34-C-如何处理返回值？" class="headerlink" title="34.C++如何处理返回值？"></a>34.C++如何处理返回值？</h4><ul>
<li>生成一个临时变量，把它的引用作为函数参数传入函数内。</li>
</ul>
<h4 id="35-C-中拷贝赋值函数的形参能否进行值传递？"><a href="#35-C-中拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="35.C++中拷贝赋值函数的形参能否进行值传递？"></a>35.C++中拷贝赋值函数的形参能否进行值传递？</h4><ul>
<li>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。</li>
</ul>
<h4 id="36-fork-wait-exec函数"><a href="#36-fork-wait-exec函数" class="headerlink" title="36.fork,wait,exec函数"></a>36.fork,wait,exec函数</h4><ul>
<li>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。</li>
<li>fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。</li>
<li>exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1</li>
</ul>
<h4 id="37-C-中struct和class的区别"><a href="#37-C-中struct和class的区别" class="headerlink" title="37.C++中struct和class的区别"></a>37.C++中struct和class的区别</h4><ul>
<li>在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。</li>
<li>class还可以定义模板类形参，比如template &lt;class T, int i&gt;。</li>
</ul>
<h4 id="38-什么是右值引用，跟左值又有什么区别？"><a href="#38-什么是右值引用，跟左值又有什么区别？" class="headerlink" title="38.什么是右值引用，跟左值又有什么区别？"></a>38.什么是右值引用，跟左值又有什么区别？</h4><ul>
<li>右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</span><br><span class="line"></span><br><span class="line">2. 能够更简洁明确地定义泛型函数。</span><br></pre></td></tr></table></figure></li>
<li>左值和右值的概念：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">左值：能对表达式取地址、或具名对象&#x2F;变量。一般指表达式结束后依然存在的持久对象。</span><br><span class="line"></span><br><span class="line">右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</span><br></pre></td></tr></table></figure></li>
<li>右值引用和左值引用的区别：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 左值可以寻址，而右值不可以。</span><br><span class="line"></span><br><span class="line">2. 左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。</span><br><span class="line"></span><br><span class="line">3. 左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="39-静态变量什么时候初始化"><a href="#39-静态变量什么时候初始化" class="headerlink" title="39.静态变量什么时候初始化"></a>39.静态变量什么时候初始化</h4><ul>
<li>静态变量存储在虚拟地址空间的数据段和bss段</li>
<li>C语言中其在代码执行之前初始化，属于编译期初始化。</li>
<li>而C ++ 中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造</li>
</ul>
<h3 id="容器STL"><a href="#容器STL" class="headerlink" title="容器STL"></a>容器STL</h3><h4 id="1-stl里面set和map怎么实现的"><a href="#1-stl里面set和map怎么实现的" class="headerlink" title="1.stl里面set和map怎么实现的?"></a>1.stl里面set和map怎么实现的?</h4><ul>
<li>集合，所有元素都会根据元素的值自动被排序，且不允许重复。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">底层实现：红黑树</span><br><span class="line"></span><br><span class="line">set 底层是通过红黑树（RB-tree）来实现的，由于红黑树是一种平衡二叉搜索树，自动排序的效果很不错，所以标准的 STL 的 set 即以 RB-Tree 为底层机制。又由于 set 所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 set 操作行为，都只有转调用 RB-tree 的操作行为而已。</span><br><span class="line"></span><br><span class="line">适用场景：有序不重复集合</span><br></pre></td></tr></table></figure></li>
<li>映射。map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</span><br><span class="line"></span><br><span class="line">底层：红黑树</span><br><span class="line"></span><br><span class="line">适用场景：有序键值对不重复映射</span><br></pre></td></tr></table></figure>
<h4 id="2-STL中map与unordered-map"><a href="#2-STL中map与unordered-map" class="headerlink" title="2.STL中map与unordered_map"></a>2.STL中map与unordered_map</h4>1、Map映射，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</li>
</ul>
<p>底层实现：红黑树</p>
<p>适用场景：有序键值对不重复映射</p>
<p>2、Multimap多重映射。multimap 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许键值重复。</p>
<p>底层实现：红黑树</p>
<p>适用场景：有序键值对可重复映射</p>
<h4 id="3-vector和list的区别，应用"><a href="#3-vector和list的区别，应用" class="headerlink" title="3.vector和list的区别，应用"></a>3.vector和list的区别，应用</h4><ul>
<li><p>1vector底层实现是数组；list是双向 链表。</p>
</li>
<li><p>2）vector支持随机访问，list不支持。</p>
</li>
<li><p>3）vector是顺序内存，list不是。</p>
</li>
<li><p>4）vector在中间节点进行插入删除会导致内存拷贝，list不会。</p>
</li>
<li><p>5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</p>
</li>
<li><p>6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</p>
</li>
</ul>
<p>应用</p>
<ul>
<li><p>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</p>
</li>
<li><p>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</p>
</li>
</ul>
<h4 id="4-STL迭代器是怎么删除元素的呢"><a href="#4-STL迭代器是怎么删除元素的呢" class="headerlink" title="4.STL迭代器是怎么删除元素的呢"></a>4.STL迭代器是怎么删除元素的呢</h4><ul>
<li><p>1.对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；</p>
</li>
<li><p>2.对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。</p>
</li>
<li><p>3.对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。</p>
</li>
</ul>
<h4 id="5-STL中迭代器的作用，有指针为何还要迭代器"><a href="#5-STL中迭代器的作用，有指针为何还要迭代器" class="headerlink" title="5.STL中迭代器的作用，有指针为何还要迭代器?"></a>5.STL中迭代器的作用，有指针为何还要迭代器?</h4><ul>
<li>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、–等。</li>
<li>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。</li>
</ul>
<p>迭代器产生原因</p>
<ul>
<li>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</li>
</ul>
<h4 id="6-STL里resize和reserve的区别"><a href="#6-STL里resize和reserve的区别" class="headerlink" title="6.STL里resize和reserve的区别"></a>6.STL里resize和reserve的区别</h4><ul>
<li>resize()：改变当前容器内含有元素的数量(size())，eg: vector<int>v; v.resize(len);v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；</int></li>
<li>reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；</li>
</ul>
<h3 id="编译与底层"><a href="#编译与底层" class="headerlink" title="编译与底层"></a>编译与底层</h3><h4 id="1-一个C-源文件从文本到可执行文件经历的过程？"><a href="#1-一个C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="1.一个C++源文件从文本到可执行文件经历的过程？"></a>1.一个C++源文件从文本到可执行文件经历的过程？</h4><ul>
<li><p>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</p>
</li>
<li><p>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</p>
</li>
<li><p>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</p>
</li>
<li><p>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</p>
</li>
</ul>
<h4 id="2-include头文件的顺序"><a href="#2-include头文件的顺序" class="headerlink" title="2.include头文件的顺序"></a>2.include头文件的顺序</h4><ul>
<li>对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。</li>
</ul>
<h4 id="3-双引号””和尖括号-lt-gt-的区别？"><a href="#3-双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="3.双引号””和尖括号&lt;&gt;的区别？"></a>3.双引号””和尖括号&lt;&gt;的区别？</h4><ul>
<li><p>双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。</p>
</li>
<li><p>双引号包含的头文件，查找头文件路径的顺序为：<br>1）.当前头文件目录；2）编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）;3)系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
</li>
<li><p>尖括号包含的头文件，查找头文件的路径顺序为：<br>1)编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）;2)系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
</li>
</ul>
<h4 id="4-malloc的原理"><a href="#4-malloc的原理" class="headerlink" title="4.malloc的原理"></a>4.malloc的原理</h4><ul>
<li>Malloc函数用于动态分配内存。</li>
<li>为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。</li>
<li>当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</li>
</ul>
<h4 id="5-brk系统调用和mmap系统调用的作用分别是什么？"><a href="#5-brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="5.brk系统调用和mmap系统调用的作用分别是什么？"></a>5.brk系统调用和mmap系统调用的作用分别是什么？</h4><ul>
<li>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</li>
</ul>
<h4 id="6-C-的内存管理是怎样的？"><a href="#6-C-的内存管理是怎样的？" class="headerlink" title="6.C++的内存管理是怎样的？"></a>6.C++的内存管理是怎样的？</h4><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</p>
<ul>
<li><p>代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
</li>
<li><p>数据段：存储程序中已初始化的全局变量和静态变量</p>
</li>
<li><p>bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</p>
</li>
<li><p>堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。</p>
</li>
<li><p>映射区:存储动态链接库以及调用mmap函数进行的文件映射</p>
</li>
<li><p>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
</li>
</ul>
<h4 id="7-如何判断内存泄漏？"><a href="#7-如何判断内存泄漏？" class="headerlink" title="7.如何判断内存泄漏？"></a>7.如何判断内存泄漏？</h4><ul>
<li>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。 </li>
<li>为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind</li>
<li>另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</li>
</ul>
<h4 id="8-什么时候会发生段错误"><a href="#8-什么时候会发生段错误" class="headerlink" title="8.什么时候会发生段错误"></a>8.什么时候会发生段错误</h4><ul>
<li>段错误通常发生在访问非法内存地址的时候</li>
<li>使用野指针</li>
<li>试图修改字符串常量的内容</li>
</ul>
<h4 id="9-memory-leak，也就是内存泄漏"><a href="#9-memory-leak，也就是内存泄漏" class="headerlink" title="9.memory leak，也就是内存泄漏"></a>9.memory leak，也就是内存泄漏</h4><ul>
<li>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。</li>
<li>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</li>
<li>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</li>
<li>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li>
<li>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li>
</ul>
<h4 id="10-说一下共享内存相关api"><a href="#10-说一下共享内存相关api" class="headerlink" title="10.说一下共享内存相关api"></a>10.说一下共享内存相关api</h4><p>1）新建共享内存shmget</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int shmget(key_t key,size_t size,int shmflg);</span><br><span class="line"></span><br><span class="line">key：共享内存键值，可以理解为共享内存的唯一性标记。</span><br><span class="line"></span><br><span class="line">size：共享内存大小</span><br><span class="line"></span><br><span class="line">shmflag：创建进程和其他进程的读写权限标识。</span><br><span class="line"></span><br><span class="line">返回值：相应的共享内存标识符，失败返回-1</span><br></pre></td></tr></table></figure>

<p>2）连接共享内存到当前进程的地址空间shmat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void *shmat(int shm_id,const void *shm_addr,int shmflg);</span><br><span class="line"></span><br><span class="line">shm_id：共享内存标识符</span><br><span class="line"></span><br><span class="line">shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。</span><br><span class="line"></span><br><span class="line">shmflg：标志位</span><br><span class="line"></span><br><span class="line">返回值：指向共享内存第一个字节的指针，失败返回-1</span><br></pre></td></tr></table></figure>

<p>3）当前进程分离共享内存shmdt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int shmdt(const void *shmaddr);</span><br></pre></td></tr></table></figure>

<p>4）控制共享内存shmctl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">和信号量的semctl函数类似，控制共享内存</span><br><span class="line"></span><br><span class="line">int shmctl(int shm_id,int command,struct shmid_ds *buf);</span><br><span class="line"></span><br><span class="line">shm_id：共享内存标识符</span><br><span class="line"></span><br><span class="line">command: 有三个值</span><br><span class="line"></span><br><span class="line">IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</span><br><span class="line"></span><br><span class="line">IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。</span><br><span class="line"></span><br><span class="line">IPC_RMID:删除共享内存</span><br><span class="line"></span><br><span class="line">buf：共享内存管理结构体。</span><br></pre></td></tr></table></figure>
<h4 id="11-如何采用单线程的方式处理高并发"><a href="#11-如何采用单线程的方式处理高并发" class="headerlink" title="11.如何采用单线程的方式处理高并发"></a>11.如何采用单线程的方式处理高并发</h4><ul>
<li>在单线程模型中，可以采用I/O复用来提高单线程处理多个请求的能力</li>
<li>然后再采用事件驱动模型</li>
<li>基于异步回调来处理事件来</li>
</ul>
<h4 id="12-C-如何处理内存泄漏？"><a href="#12-C-如何处理内存泄漏？" class="headerlink" title="12.C++如何处理内存泄漏？"></a>12.C++如何处理内存泄漏？</h4><ul>
<li>使用varglind，mtrace检测</li>
</ul>
<h3 id="C-11特性"><a href="#C-11特性" class="headerlink" title="C++11特性"></a>C++11特性</h3><h4 id="1-C-11-最常用的新特性如下："><a href="#1-C-11-最常用的新特性如下：" class="headerlink" title="1.C++11 最常用的新特性如下："></a>1.C++11 最常用的新特性如下：</h4><ul>
<li><p>auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导</p>
</li>
<li><p>nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。</p>
</li>
<li><p>智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。</p>
</li>
<li><p>初始化列表：使用初始化列表来对类进行初始化</p>
</li>
<li><p>右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率</p>
</li>
<li><p>atomic原子操作用于多线程资源互斥操作</p>
</li>
<li><p>新增STL容器array以及tuple</p>
</li>
</ul>
<h2 id="三、操作系统"><a href="#三、操作系统" class="headerlink" title="三、操作系统"></a>三、操作系统</h2><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-进程与线程的概念"><a href="#1-进程与线程的概念" class="headerlink" title="1.进程与线程的概念"></a>1.进程与线程的概念</h4><ul>
<li>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</li>
<li>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。</li>
<li>每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</li>
</ul>
<p>两者区别</p>
<ul>
<li><p>1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p>
</li>
<li><p>2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</p>
</li>
<li><p>3.进程是资源分配的最小单位，线程是CPU调度的最小单位；</p>
</li>
<li><p>4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。</p>
</li>
<li><p>5.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p>
</li>
<li><p>6.进程间不会相互影响 ；一个线程挂掉将导致整个进程挂掉</p>
</li>
<li><p>7.进程适应于多核、多机分布；线程适用于多核</p>
</li>
</ul>
<h4 id="2-进程间通信的方式"><a href="#2-进程间通信的方式" class="headerlink" title="2.进程间通信的方式"></a>2.进程间通信的方式</h4><p>进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。</p>
<ul>
<li>管道</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">管道主要包括无名管道和命名管道 :管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.1 普通管道PIPE：</span><br><span class="line"></span><br><span class="line">1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</span><br><span class="line"></span><br><span class="line">2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</span><br><span class="line"></span><br><span class="line">3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</span><br><span class="line"></span><br><span class="line">1.2 命名管道FIFO：</span><br><span class="line"></span><br><span class="line">1)FIFO可以在无关的进程之间交换数据</span><br><span class="line"></span><br><span class="line">2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</span><br></pre></td></tr></table></figure>
<ul>
<li>系统IPC<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.1 消息队列</span><br><span class="line"></span><br><span class="line">消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line">1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</span><br><span class="line"></span><br><span class="line">2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</span><br><span class="line"></span><br><span class="line">3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.2 信号量semaphore</span><br><span class="line"></span><br><span class="line">信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line">1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</span><br><span class="line"></span><br><span class="line">2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</span><br><span class="line"></span><br><span class="line">3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</span><br><span class="line"></span><br><span class="line">4)支持信号量组。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.3 信号signal</span><br><span class="line"></span><br><span class="line">信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.4 共享内存（Shared Memory）</span><br><span class="line"></span><br><span class="line">它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line">1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取</span><br><span class="line"></span><br><span class="line">2)因为多个进程可以同时操作，所以需要进行同步</span><br><span class="line"></span><br><span class="line">3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</span><br></pre></td></tr></table></figure>
<ul>
<li>套接字SOCKET<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-线程间通信的方式"><a href="#3-线程间通信的方式" class="headerlink" title="3.线程间通信的方式"></a>3.线程间通信的方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</span><br><span class="line"></span><br><span class="line">互斥量Synchronized&#x2F;Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</span><br><span class="line"></span><br><span class="line">信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</span><br><span class="line"></span><br><span class="line">事件(信号)，Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</span><br></pre></td></tr></table></figure>

<h4 id="4-虚拟内存的好处"><a href="#4-虚拟内存的好处" class="headerlink" title="4.虚拟内存的好处"></a>4.虚拟内存的好处</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.扩大地址空间；</span><br><span class="line"></span><br><span class="line">2.内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。</span><br><span class="line"></span><br><span class="line">3.公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。</span><br><span class="line"></span><br><span class="line">4.当进程通信时，可采用虚存共享的方式实现。</span><br><span class="line"></span><br><span class="line">5.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存</span><br><span class="line"></span><br><span class="line">6.虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高</span><br><span class="line"></span><br><span class="line">7.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片</span><br></pre></td></tr></table></figure>

<h4 id="5-虚拟内存的代价"><a href="#5-虚拟内存的代价" class="headerlink" title="5.虚拟内存的代价"></a>5.虚拟内存的代价</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</span><br><span class="line"></span><br><span class="line">2.虚拟地址到物理地址的转换，增加了指令的执行时间。</span><br><span class="line"></span><br><span class="line">3.页面的换入换出需要磁盘I&#x2F;O，这是很耗时的</span><br><span class="line"></span><br><span class="line">4.如果一页中只有一部分数据，会浪费内存。</span><br></pre></td></tr></table></figure>
<p>缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、在指令执行期间产生和处理缺页中断信号</span><br><span class="line"></span><br><span class="line">2、一条指令在执行期间，可能产生多次缺页中断</span><br><span class="line"></span><br><span class="line">3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。</span><br></pre></td></tr></table></figure>
<h4 id="6-操作系统中的缺页中断"><a href="#6-操作系统中的缺页中断" class="headerlink" title="6.操作系统中的缺页中断"></a>6.操作系统中的缺页中断</h4><ul>
<li>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。</li>
<li>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</li>
</ul>
<p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、保护CPU现场</span><br><span class="line"></span><br><span class="line">2、分析中断原因</span><br><span class="line"></span><br><span class="line">3、转入缺页中断处理程序进行处理</span><br><span class="line"></span><br><span class="line">4、恢复CPU现场，继续执行</span><br></pre></td></tr></table></figure>

<h4 id="7-fork和vfork的区别"><a href="#7-fork和vfork的区别" class="headerlink" title="7.fork和vfork的区别"></a>7.fork和vfork的区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段</span><br><span class="line"></span><br><span class="line">2. fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。</span><br><span class="line"></span><br><span class="line">3. vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</span><br><span class="line"></span><br><span class="line">4.当需要改变共享数据段中变量的值，则拷贝父进程。</span><br></pre></td></tr></table></figure>

<h4 id="8-请问如何修改文件最大句柄数？"><a href="#8-请问如何修改文件最大句柄数？" class="headerlink" title="8.请问如何修改文件最大句柄数？"></a>8.请问如何修改文件最大句柄数？</h4><ul>
<li>linux默认最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报”too many open files”的错误。</li>
<li>ulimit -n &lt;可以同时打开的文件数&gt;，将当前进程的最大句柄数修改为指定的参数(该方法只针对当前进程有效，重新打开一个shell或者重新开启一个进程，参数还是之前的值)</li>
<li>ulimit -a查询Linux相关的参数</li>
</ul>
<p>对所有进程都有效的方法，修改Linux系统参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;security&#x2F;limits.conf 添加</span><br><span class="line"></span><br><span class="line">*　　soft　　nofile　　65536</span><br><span class="line"></span><br><span class="line">*　　hard　　nofile　　65536</span><br><span class="line"></span><br><span class="line">将最大句柄数改为65536</span><br></pre></td></tr></table></figure>
<p>修改以后保存，注销当前用户，重新登录，修改后的参数就生效了</p>
<h4 id="9-并发-concurrency-和并行-parallelism"><a href="#9-并发-concurrency-和并行-parallelism" class="headerlink" title="9.并发(concurrency)和并行(parallelism)"></a>9.并发(concurrency)和并行(parallelism)</h4><ul>
<li><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p>
</li>
<li><p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p>
</li>
</ul>
<h4 id="10-MySQL的端口号是多少，如何修改这个端口号"><a href="#10-MySQL的端口号是多少，如何修改这个端口号" class="headerlink" title="10.MySQL的端口号是多少，如何修改这个端口号"></a>10.MySQL的端口号是多少，如何修改这个端口号</h4><ul>
<li>mysql的默认端口是3306。</li>
<li>编辑/etc/my.cnf文件，早期版本有可能是my.conf文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。</li>
</ul>
<h4 id="11-操作系统中的页表寻址"><a href="#11-操作系统中的页表寻址" class="headerlink" title="11.操作系统中的页表寻址"></a>11.操作系统中的页表寻址</h4><ul>
<li>页式内存管理，内存分成固定长度的一个个页片。操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表.</li>
<li>页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。</li>
<li>通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。</li>
<li>一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。</li>
</ul>
<h4 id="12-请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"><a href="#12-请问单核机器上写多线程程序，是否需要考虑加锁，为什么？" class="headerlink" title="12.请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"></a>12.请问单核机器上写多线程程序，是否需要考虑加锁，为什么？</h4><ul>
<li>在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。</li>
<li>在单核机器上的多线程程序，仍然存在线程同步的问题。</li>
<li>因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。</li>
<li>如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。</li>
</ul>
<h4 id="13-线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"><a href="#13-线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的" class="headerlink" title="13.线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"></a>13.线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的</h4><p>线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SP:堆栈指针，指向当前栈的栈顶地址</span><br><span class="line"></span><br><span class="line">PC:程序计数器，存储下一条将要执行的指令</span><br><span class="line"></span><br><span class="line">EAX:累加寄存器，用于加法乘法的缺省寄存器</span><br></pre></td></tr></table></figure>

<h4 id="14-线程间的同步方式，最好说出具体的系统调用"><a href="#14-线程间的同步方式，最好说出具体的系统调用" class="headerlink" title="14.线程间的同步方式，最好说出具体的系统调用"></a>14.线程间的同步方式，最好说出具体的系统调用</h4><ul>
<li>信号量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：</span><br><span class="line"></span><br><span class="line">P(SV):如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。</span><br><span class="line"></span><br><span class="line">V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。</span><br><span class="line"></span><br><span class="line">其系统调用为：</span><br><span class="line"></span><br><span class="line">sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。</span><br><span class="line"></span><br><span class="line">sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</span><br></pre></td></tr></table></figure></li>
<li>互斥量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区      时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：</span><br><span class="line"></span><br><span class="line">pthread_mutex_init:初始化互斥锁</span><br><span class="line"></span><br><span class="line">pthread_mutex_destroy：销毁互斥锁</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。</span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。</span><br></pre></td></tr></table></figure></li>
<li>条件变量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个&#x2F;多个线程。即，当某个共享变量等于某个值时，调用 signal&#x2F;broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：</span><br><span class="line"></span><br><span class="line">pthread_cond_init：初始化条件变量</span><br><span class="line"></span><br><span class="line">pthread_cond_destroy：销毁条件变量</span><br><span class="line"></span><br><span class="line">pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。</span><br><span class="line"></span><br><span class="line">pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。</span><br></pre></td></tr></table></figure>
<h4 id="15-多线程和多进程的不同"><a href="#15-多线程和多进程的不同" class="headerlink" title="15.多线程和多进程的不同"></a>15.多线程和多进程的不同</h4></li>
<li>进程是资源分配的最小单位，而线程时CPU调度的最小单位。</li>
<li>多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。</li>
<li>多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于多核、多机分布。</li>
</ul>
<h4 id="16-游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"><a href="#16-游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？" class="headerlink" title="16.游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"></a>16.游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？</h4><ul>
<li>游戏服务器应该为每个用户开辟一个进程。因为同一进程间的线程会相互影响，一个线程死掉会影响其他线程，从而导致进程崩溃。因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程</li>
</ul>
<h4 id="17-OS缺页置换算法"><a href="#17-OS缺页置换算法" class="headerlink" title="17.OS缺页置换算法"></a>17.OS缺页置换算法</h4><p>当前操作系统最常采用的缺页置换算法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、FIFO（先进先出淘汰算法）</span><br><span class="line"></span><br><span class="line">思想：最近刚访问的，将来访问的可能性比较大。</span><br><span class="line"></span><br><span class="line">实现：使用一个队列，新加入的页面放入队尾，每次淘汰队首的页面，即最先进入的数据，最先被淘汰。</span><br><span class="line"></span><br><span class="line">弊端：无法体现页面冷热信息</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2、LFU（最不经常访问淘汰算法）</span><br><span class="line"></span><br><span class="line">思想：如果数据过去被访问多次，那么将来被访问的频率也更高。</span><br><span class="line"></span><br><span class="line">实现：每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块。</span><br><span class="line"></span><br><span class="line">开销：排序开销。</span><br><span class="line"></span><br><span class="line">弊端：缓存颠簸。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3、LRU（最近最少使用替换算法）</span><br><span class="line"></span><br><span class="line">思想：如果数据最近被访问过，那么将来被访问的几率也更高。</span><br><span class="line"></span><br><span class="line">实现：使用一个栈，新页面或者命中的页面则将该页面移动到栈底，每次替换栈顶的缓存页面。</span><br><span class="line"></span><br><span class="line">优点：LRU算法对热点数据命中率是很高的。</span><br><span class="line"></span><br><span class="line">缺陷：</span><br><span class="line"></span><br><span class="line">1）缓存颠簸，当缓存（1，2，3）满了，之后数据访问（0，3，2，1，0，3，2，1。。。）。</span><br><span class="line"></span><br><span class="line">2）缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4、LRU-K（LRU-2、LRU-3）</span><br><span class="line"></span><br><span class="line">思想：最久未使用K次淘汰算法。</span><br><span class="line"></span><br><span class="line">LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</span><br><span class="line"></span><br><span class="line">相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</span><br><span class="line"></span><br><span class="line">实现：</span><br><span class="line"></span><br><span class="line">1）数据第一次被访问，加入到访问历史列表；</span><br><span class="line"></span><br><span class="line">2）如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</span><br><span class="line"></span><br><span class="line">3）当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</span><br><span class="line"></span><br><span class="line">4）缓存数据队列中被再次访问后，重新排序；</span><br><span class="line"></span><br><span class="line">5）需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</span><br><span class="line"></span><br><span class="line">针对问题：</span><br><span class="line"></span><br><span class="line">LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5、2Q</span><br><span class="line"></span><br><span class="line">类似LRU-2。使用一个FIFO队列和一个LRU队列。</span><br><span class="line"></span><br><span class="line">实现：</span><br><span class="line"></span><br><span class="line">1）新访问的数据插入到FIFO队列；</span><br><span class="line"></span><br><span class="line">2）如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</span><br><span class="line"></span><br><span class="line">3）如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；</span><br><span class="line"></span><br><span class="line">4）如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；</span><br><span class="line"></span><br><span class="line">5）LRU队列淘汰末尾的数据。</span><br><span class="line"></span><br><span class="line">针对问题：LRU的缓存污染</span><br><span class="line"></span><br><span class="line">弊端：</span><br><span class="line"></span><br><span class="line">当FIFO容量为2时，访问负载是：ABCABCABC会退化为FIFO，用不到LRU。</span><br></pre></td></tr></table></figure>
<h4 id="18-作系统中的结构体对齐，字节对齐"><a href="#18-作系统中的结构体对齐，字节对齐" class="headerlink" title="18.作系统中的结构体对齐，字节对齐"></a>18.作系统中的结构体对齐，字节对齐</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、原因：</span><br><span class="line">1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</span><br><span class="line"></span><br><span class="line">2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</span><br><span class="line"></span><br><span class="line">2、规则</span><br><span class="line"></span><br><span class="line">1）数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</span><br><span class="line"></span><br><span class="line">2）结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</span><br><span class="line"></span><br><span class="line">3）结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。</span><br><span class="line"></span><br><span class="line">3、定义结构体对齐</span><br><span class="line"></span><br><span class="line">可以通过预编译命令#pragma pack(n)，n&#x3D;1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。</span><br><span class="line"></span><br><span class="line">4、举例</span><br><span class="line"></span><br><span class="line">#pragma pack(2)</span><br><span class="line"></span><br><span class="line">struct AA &#123;</span><br><span class="line"></span><br><span class="line">int a;       &#x2F;&#x2F;长度4 &gt; 2 按2对齐；偏移量为0；存放位置区间[0,3]</span><br><span class="line"></span><br><span class="line">char b;  &#x2F;&#x2F;长度1 &lt; 2 按1对齐；偏移量为4；存放位置区间[4]</span><br><span class="line"></span><br><span class="line">short c;     &#x2F;&#x2F;长度2 &#x3D; 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</span><br><span class="line"></span><br><span class="line">char d;  &#x2F;&#x2F;长度1 &lt; 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#pragma pack()</span><br></pre></td></tr></table></figure>

<h4 id="19-多进程和多线程的使用场景"><a href="#19-多进程和多线程的使用场景" class="headerlink" title="19.多进程和多线程的使用场景"></a>19.多进程和多线程的使用场景</h4><ul>
<li>多进程模型的优势是CPU</li>
<li>多线程模型主要优势为线程间切换代价较小，因此适用于I/O密集型的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于单机多核分布式场景。</li>
<li>多进程模型，适用于CPU密集型。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。</li>
</ul>
<h4 id="20-互斥锁和读写锁的区别"><a href="#20-互斥锁和读写锁的区别" class="headerlink" title="20.互斥锁和读写锁的区别"></a>20.互斥锁和读写锁的区别</h4><p>概念</p>
<ul>
<li><p>互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</p>
</li>
<li><p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p>
</li>
</ul>
<p>互斥锁和读写锁的区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）读写锁区分读者和写者，而互斥锁不区分</span><br><span class="line"></span><br><span class="line">2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</span><br></pre></td></tr></table></figure>
<h4 id="21-Linux的4种锁机制："><a href="#21-Linux的4种锁机制：" class="headerlink" title="21.Linux的4种锁机制："></a>21.Linux的4种锁机制：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线</span><br><span class="line">程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于</span><br><span class="line">读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠</span><br><span class="line">，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂</span><br><span class="line">的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时</span><br><span class="line">，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制</span><br><span class="line">被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。</span><br></pre></td></tr></table></figure>
<h4 id="22-进程状态转换图"><a href="#22-进程状态转换图" class="headerlink" title="22.进程状态转换图"></a>22.进程状态转换图</h4><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470678794_F9BF116BD97A95A5E655DF9E1672186F" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）创建状态：进程正在被创建</span><br><span class="line"></span><br><span class="line">2）就绪状态：进程被加入到就绪队列中等待CPU调度运行</span><br><span class="line"></span><br><span class="line">3）执行状态：进程正在被运行</span><br><span class="line"></span><br><span class="line">4）等待阻塞状态：进程因为某种原因，比如等待I&#x2F;O，等待设备，而暂时不能运行。</span><br><span class="line"></span><br><span class="line">5）终止状态：进程运行完毕</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。</span><br><span class="line"></span><br><span class="line">2）静止阻塞：进程在外存，同时被某种原因阻塞了。</span><br><span class="line"></span><br><span class="line">3）活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。</span><br><span class="line"></span><br><span class="line">4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。</span><br></pre></td></tr></table></figure>
<p>交换技术</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I&#x2F;0速</span><br><span class="line">度比处理机速度慢得多，可能出现全部进程阻塞等待I&#x2F;O。</span><br></pre></td></tr></table></figure>
<p>针对以上问题，提出了两种解决方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）交换技术：换出一部分进程到外存，腾出内存空间。</span><br><span class="line">2）虚拟存储技术：每个进程只能装入一部分程序和数据。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内</span><br><span class="line">存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。</span><br></pre></td></tr></table></figure>
<h4 id="23-A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？"><a href="#23-A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？" class="headerlink" title="23.A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？"></a>23.A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4&#x2F;8字节的空间（0x000m），分配给指针a。</span><br><span class="line"></span><br><span class="line">2）new A：通过new动态的在堆区申请类A大小的空间（0x000n）。</span><br><span class="line"></span><br><span class="line">3）a &#x3D; new A：将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）&#x3D;0x000n。</span><br><span class="line"></span><br><span class="line">4）a-&gt;i：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) &#x3D; </span><br><span class="line">10的赋值操作，即内存0x000n + offset的值是10。</span><br></pre></td></tr></table></figure>

<h4 id="24-用户态和内核态区别"><a href="#24-用户态和内核态区别" class="headerlink" title="24.用户态和内核态区别"></a>24.用户态和内核态区别</h4><ul>
<li>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。</li>
<li>用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。</li>
<li>内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</li>
</ul>
<h4 id="25-死循环-来连接时新建线程的方法效率有点低，怎么改进？"><a href="#25-死循环-来连接时新建线程的方法效率有点低，怎么改进？" class="headerlink" title="25.死循环+来连接时新建线程的方法效率有点低，怎么改进？"></a>25.死循环+来连接时新建线程的方法效率有点低，怎么改进？</h4><p>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术</p>
<h4 id="26-怎样确定当前线程是繁忙还是阻塞？"><a href="#26-怎样确定当前线程是繁忙还是阻塞？" class="headerlink" title="26.怎样确定当前线程是繁忙还是阻塞？"></a>26.怎样确定当前线程是繁忙还是阻塞？</h4><p>使用ps命令查看</p>
<h4 id="27-请问就绪状态的进程在等待什么？"><a href="#27-请问就绪状态的进程在等待什么？" class="headerlink" title="27.请问就绪状态的进程在等待什么？"></a>27.请问就绪状态的进程在等待什么？</h4><p>被调度使用cpu的运行权</p>
<h4 id="28-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#28-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="28.两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>28.两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h4><p>单核cpu，并且开了抢占可以造成这种情况。</p>
<h4 id="29-windows消息机制知道吗"><a href="#29-windows消息机制知道吗" class="headerlink" title="29.windows消息机制知道吗"></a>29.windows消息机制知道吗</h4><p>当用户有操作(鼠标，键盘等)时，系统会将这些时间转化为消息。每个打开的进程系统都为其维护了一个消息队列，系统会将这些消息放到进程的消息队列中，而应用程序会循环从消息队列中取出来消息，完成对应的操作</p>
<h4 id="30-请你说一说死锁产生的必要条件？"><a href="#30-请你说一说死锁产生的必要条件？" class="headerlink" title="30.请你说一说死锁产生的必要条件？"></a>30.请你说一说死锁产生的必要条件？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.互斥条件：一个资源每次只能被一个进程使用。</span><br><span class="line">2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</span><br><span class="line">3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</span><br><span class="line">4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</span><br></pre></td></tr></table></figure>

<h4 id="31-内存溢出和内存泄漏"><a href="#31-内存溢出和内存泄漏" class="headerlink" title="31.内存溢出和内存泄漏"></a>31.内存溢出和内存泄漏</h4><p>1、内存溢出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</span><br></pre></td></tr></table></figure>
<p>内存溢出原因：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1).内存中加载的数据量过于庞大，如一次从数据库取出过多数据</span><br><span class="line"></span><br><span class="line">2).集合类中有对对象的引用，使用完后未清空，使得不能回收</span><br><span class="line"></span><br><span class="line">3).代码中存在死循环或循环产生过多重复的对象实体</span><br><span class="line"></span><br><span class="line">4).使用的第三方软件中的BUG</span><br><span class="line"></span><br><span class="line">5).启动参数内存值设定的过小</span><br></pre></td></tr></table></figure>
<p>2、内存泄漏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理</span><br><span class="line">上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</span><br></pre></td></tr></table></figure>
<p>内存泄漏的分类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc </span><br><span class="line">new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete </span><br><span class="line">删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2、系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle </span><br><span class="line">,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3、没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，</span><br><span class="line">那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</span><br></pre></td></tr></table></figure>
<h4 id="32-常用线程模型"><a href="#32-常用线程模型" class="headerlink" title="32.常用线程模型"></a>32.常用线程模型</h4><p>1、Future模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该模型通常在使用的时候需要结合Callable接口配合使用。</span><br><span class="line"></span><br><span class="line">Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。</span><br><span class="line"></span><br><span class="line">Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。</span><br></pre></td></tr></table></figure>
<p>2、fork&amp;join模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子</span><br><span class="line">任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。</span><br><span class="line"></span><br><span class="line">这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时</span><br><span class="line">间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。</span><br></pre></td></tr></table></figure>
<p>3、actor模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继</span><br><span class="line">续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。</span><br></pre></td></tr></table></figure>

<p>4、生产者消费者模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个&#x2F;多个线程来生产任务，然后</span><br><span class="line">再开启一个&#x2F;多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费</span><br><span class="line">者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活</span><br><span class="line">的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。</span><br></pre></td></tr></table></figure>

<p>5、master-worker模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处</span><br><span class="line">理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。</span><br></pre></td></tr></table></figure>

<h4 id="33-协程与线程的区别"><a href="#33-协程与线程的区别" class="headerlink" title="33.协程与线程的区别"></a>33.协程与线程的区别</h4><ul>
<li><p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
</li>
<li><p>那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
</li>
<li><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
</li>
</ul>
<h4 id="34-系统调用是什么，你用过哪些系统调用"><a href="#34-系统调用是什么，你用过哪些系统调用" class="headerlink" title="34.系统调用是什么，你用过哪些系统调用"></a>34.系统调用是什么，你用过哪些系统调用</h4><ul>
<li>系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。</li>
<li>操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。</li>
<li>特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。</li>
<li>应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。</li>
<li>计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。</li>
<li>操作系统是这些资源的唯一入口，这个入口就是系统调用。</li>
</ul>
<p>写数据write，创建进程fork，vfork等都是系统调用。</p>
<h4 id="35-手写一下fork调用示例"><a href="#35-手写一下fork调用示例" class="headerlink" title="35.手写一下fork调用示例"></a>35.手写一下fork调用示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line">    printf(&quot;before fork pid:%d\n&quot;, getpid());</span><br><span class="line">    int abc &#x3D; 10;</span><br><span class="line">    pid &#x3D; fork();</span><br><span class="line">    </span><br><span class="line">    if (pid &#x3D;&#x3D; -1) &#123;           &#x2F;&#x2F;错误返回</span><br><span class="line">        perror(&quot;tile&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (pid &gt; 0) &#123;              &#x2F;&#x2F;父进程空间</span><br><span class="line">        abc++;</span><br><span class="line">        printf(&quot;parent:pid:%d \n&quot;, getpid());</span><br><span class="line">        printf(&quot;abc:%d \n&quot;, abc);</span><br><span class="line">        sleep(20);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (pid &#x3D;&#x3D; 0) &#123;       &#x2F;&#x2F;子进程空间</span><br><span class="line">        abc++;</span><br><span class="line">        printf(&quot;child:%d,parent: %d\n&quot;, getpid(), getppid());</span><br><span class="line">        printf(&quot;abc:%d&quot;, abc);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;fork after...\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="36-用户态到内核态的转化原理"><a href="#36-用户态到内核态的转化原理" class="headerlink" title="36.用户态到内核态的转化原理"></a>36.用户态到内核态的转化原理</h4><p>1、系统调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完</span><br><span class="line">成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。</span><br></pre></td></tr></table></figure>
<p>2、异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处</span><br><span class="line">理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。</span><br></pre></td></tr></table></figure>
<p>3、外围设备的中断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的</span><br><span class="line">指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然</span><br><span class="line">也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</span><br></pre></td></tr></table></figure>

<h4 id="37-微内核与宏内核"><a href="#37-微内核与宏内核" class="headerlink" title="37.微内核与宏内核"></a>37.微内核与宏内核</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。</span><br><span class="line">优点：效率高。</span><br><span class="line"></span><br><span class="line">缺点：稳定性差，开发过程中的bug经常会导致整个系统挂掉。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。</span><br><span class="line"></span><br><span class="line">优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃</span><br><span class="line"></span><br><span class="line">缺点：效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了。</span><br></pre></td></tr></table></figure>
<h4 id="38-僵尸进程"><a href="#38-僵尸进程" class="headerlink" title="38.僵尸进程"></a>38.僵尸进程</h4><p>1）正常进程</p>
<ul>
<li>子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</li>
<li>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1进程号the process ID</span><br><span class="line"></span><br><span class="line">2退出状态the termination status of the process</span><br><span class="line"></span><br><span class="line">3运行时间the amount of CPU time taken by the process等</span><br></pre></td></tr></table></figure>
2）孤儿进程</li>
<li>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li>
</ul>
<p>3）僵尸进程</p>
<ul>
<li>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</li>
<li>僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段</li>
<li>如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。</li>
<li>如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</li>
</ul>
<p>4）危害</p>
<ul>
<li>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。</li>
</ul>
<p>5）外部消灭：</p>
<ul>
<li>通过kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源</li>
</ul>
<p>6）内部解决：</p>
<ul>
<li><p>1、子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。</p>
</li>
<li><p>2、fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。</p>
</li>
</ul>
<h4 id="39-5种IO模型"><a href="#39-5种IO模型" class="headerlink" title="39.5种IO模型"></a>39.5种IO模型</h4><p>1.阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</p>
<p>2.非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。</p>
<p>3.信号驱动IO:信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</p>
<p>4.IO复用/多路转接IO:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</p>
<p>5.异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</p>
<h4 id="40-操作系统为什么要分内核态和用户态"><a href="#40-操作系统为什么要分内核态和用户态" class="headerlink" title="40.操作系统为什么要分内核态和用户态?"></a>40.操作系统为什么要分内核态和用户态?</h4><ul>
<li>为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。</li>
<li>分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。</li>
</ul>
<h4 id="41-操作系统怎么设计的page-cache"><a href="#41-操作系统怎么设计的page-cache" class="headerlink" title="41.操作系统怎么设计的page cache"></a>41.操作系统怎么设计的page cache</h4><ul>
<li>加快从磁盘读取文件的速率。page cache中有一部分磁盘文件的缓存</li>
<li>因为从磁盘中读取文件比较慢，所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。</li>
<li>在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项</li>
<li>它通过两个数据结构来管理这些 Cache<br>项，一个是radix tree，另一个是双向链表。Radix tree 是一种搜索树，Linux<br>内核利用这个数据结构来通过文件内偏移快速定位Cache项</li>
</ul>
<h4 id="42-死循环-来连接时新建线程的方法效率有点低，怎么改进？"><a href="#42-死循环-来连接时新建线程的方法效率有点低，怎么改进？" class="headerlink" title="42.死循环+来连接时新建线程的方法效率有点低，怎么改进？"></a>42.死循环+来连接时新建线程的方法效率有点低，怎么改进？</h4><ul>
<li>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。</li>
<li>改进死循环：使用select epoll这样的技术</li>
</ul>
<h4 id="43-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#43-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="43.两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>43.两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h4><ul>
<li>单核cpu，并且开了抢占可以造成这种情况。</li>
</ul>
<h4 id="44-请问怎么实现线程池"><a href="#44-请问怎么实现线程池" class="headerlink" title="44.请问怎么实现线程池"></a>44.请问怎么实现线程池</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.设置一个生产者消费者队列，作为临界资源</span><br><span class="line">2.初始化n个线程，并让其运行起来，加锁去队列取任务运行</span><br><span class="line">3.当任务队列为空的时候，所有线程阻塞</span><br><span class="line">4.当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程</span><br></pre></td></tr></table></figure>

<h4 id="44-Linux下怎么得到一个文件的100到200行"><a href="#44-Linux下怎么得到一个文件的100到200行" class="headerlink" title="44.Linux下怎么得到一个文件的100到200行"></a>44.Linux下怎么得到一个文件的100到200行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &#39;100,200p&#39; inputfile</span><br><span class="line">head -200 inputfile|tail -100</span><br></pre></td></tr></table></figure>
<h4 id="45-awk的使用"><a href="#45-awk的使用" class="headerlink" title="45.awk的使用"></a>45.awk的使用</h4><p>1）作用：</p>
<ul>
<li>样式扫描和处理语言。它允许创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</li>
</ul>
<h2 id="四、计算机网络"><a href="#四、计算机网络" class="headerlink" title="四、计算机网络"></a>四、计算机网络</h2><h3 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-请你说一下TCP怎么保证可靠性"><a href="#1-请你说一下TCP怎么保证可靠性" class="headerlink" title="1.请你说一下TCP怎么保证可靠性"></a>1.请你说一下TCP怎么保证可靠性</h4><p>（1）序列号、确认应答、超时重传</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一</span><br><span class="line">次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认</span><br><span class="line">应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。</span><br></pre></td></tr></table></figure>
<p>（2）窗口控制与高速重发控制/快速重传（重复确认应答）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据</span><br><span class="line">，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。</span><br></pre></td></tr></table></figure>
<p>（3）拥塞控制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发</span><br><span class="line">，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗</span><br><span class="line">口的值不再指数上升，而是加法增加（每次确认应答&#x2F;每个rtt，拥塞窗口大小+1），以此来避免拥塞。</span><br></pre></td></tr></table></figure>

<h4 id="2-三次握手"><a href="#2-三次握手" class="headerlink" title="2.三次握手"></a>2.三次握手</h4><ol>
<li><p>Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ol>
<p><img src="http://blog.chinaunix.net/attachment/201304/8/22312037_1365405910EROI.png" alt></p>
<h4 id="3-四次挥手"><a href="#3-四次挥手" class="headerlink" title="3.四次挥手"></a>3.四次挥手</h4><p>1.数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。</p>
<p>2.服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。</p>
<p>3.当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认</p>
<p>4.客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。</p>
<p><img src="http://blog.chinaunix.net/attachment/201304/9/22312037_1365503104wDR0.png" alt></p>
<h4 id="4-IP地址作用，以及MAC地址作用"><a href="#4-IP地址作用，以及MAC地址作用" class="headerlink" title="4.IP地址作用，以及MAC地址作用"></a>4.IP地址作用，以及MAC地址作用</h4><ul>
<li>MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。</li>
<li>IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</li>
</ul>
<h4 id="5-OSI七层模型和TCP-IP四层模型，每层列举2个协议"><a href="#5-OSI七层模型和TCP-IP四层模型，每层列举2个协议" class="headerlink" title="5.OSI七层模型和TCP/IP四层模型，每层列举2个协议"></a>5.OSI七层模型和TCP/IP四层模型，每层列举2个协议</h4><p>OSI七层模型及其包含的协议如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS</span><br></pre></td></tr></table></figure>

<h4 id="6-搜索baidu，会用到计算机网络中的什么层？"><a href="#6-搜索baidu，会用到计算机网络中的什么层？" class="headerlink" title="6.搜索baidu，会用到计算机网络中的什么层？"></a>6.搜索baidu，会用到计算机网络中的什么层？</h4><p>浏览器中输入URL</p>
<p>浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p>
<p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p>
<h4 id="7-达到什么情况的时候开始减慢增长的速度？"><a href="#7-达到什么情况的时候开始减慢增长的速度？" class="headerlink" title="7.达到什么情况的时候开始减慢增长的速度？"></a>7.达到什么情况的时候开始减慢增长的速度？</h4><p>采用慢开始和拥塞避免算法的时候</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度</span><br><span class="line"></span><br><span class="line">2. 一旦出现丢包的情况，就重新进行慢开始，减慢增长速度</span><br></pre></td></tr></table></figure>

<h4 id="8-传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"><a href="#8-传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文" class="headerlink" title="8.传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文?"></a>8.传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文?</h4><ul>
<li>根据端口区分；</li>
<li>看ip头中的协议标识字段，17是udp，6是tcp</li>
</ul>
<h4 id="9-tcp握手为什么两次不可以？为什么不用四次？"><a href="#9-tcp握手为什么两次不可以？为什么不用四次？" class="headerlink" title="9.tcp握手为什么两次不可以？为什么不用四次？"></a>9.tcp握手为什么两次不可以？为什么不用四次？</h4><ul>
<li>两次不可以：tcp是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常</li>
<li>不用四次：<br>本来握手应该和挥手一样都是需要确认两个方向都能联通的</li>
</ul>
<h4 id="10-TCP和UDP的区别和各自适用的场景"><a href="#10-TCP和UDP的区别和各自适用的场景" class="headerlink" title="10.TCP和UDP的区别和各自适用的场景?"></a>10.TCP和UDP的区别和各自适用的场景?</h4><p>1）TCP和UDP区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1） 连接</span><br><span class="line"></span><br><span class="line">TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。</span><br><span class="line"></span><br><span class="line">UDP无连接。</span><br><span class="line"></span><br><span class="line">2） 服务对象</span><br><span class="line"></span><br><span class="line">TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；</span><br><span class="line"></span><br><span class="line">UDP支持一对一，一对多，多对一，多对多的交互通信。</span><br><span class="line"></span><br><span class="line">3） 可靠性</span><br><span class="line"></span><br><span class="line">TCP是可靠交付：无差错，不丢失，不重复，按序到达。</span><br><span class="line"></span><br><span class="line">UDP是尽最大努力交付，不保证可靠交付。</span><br><span class="line"></span><br><span class="line">4）拥塞控制，流量控制</span><br><span class="line"></span><br><span class="line">TCP有拥塞控制和流量控制保证数据传输的安全性。</span><br><span class="line"></span><br><span class="line">UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</span><br><span class="line"></span><br><span class="line">5） 报文长度</span><br><span class="line"></span><br><span class="line">TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</span><br><span class="line"></span><br><span class="line">UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</span><br><span class="line"></span><br><span class="line">6)   首部开销</span><br><span class="line"></span><br><span class="line">TCP首部开销大，首部20个字节。</span><br><span class="line"></span><br><span class="line">UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</span><br></pre></td></tr></table></figure>

<p>2）TCP和UDP适用场景</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选用TCP 协议（如文件传输、重要状态的更新等）；</span><br><span class="line">使用 UDP 协议（如视频传输、实时通信等）。</span><br></pre></td></tr></table></figure>

<h4 id="11-socket编程中服务器端和客户端主要用到哪些函数"><a href="#11-socket编程中服务器端和客户端主要用到哪些函数" class="headerlink" title="11.socket编程中服务器端和客户端主要用到哪些函数?"></a>11.socket编程中服务器端和客户端主要用到哪些函数?</h4><p>1）基于TCP的socket：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、服务器端程序：</span><br><span class="line"></span><br><span class="line">1创建一个socket，用函数socket()</span><br><span class="line"></span><br><span class="line">2绑定IP地址、端口等信息到socket上，用函数bind()</span><br><span class="line"></span><br><span class="line">3设置允许的最大连接数，用函数listen()</span><br><span class="line"></span><br><span class="line">4接收客户端上来的连接，用函数accept()</span><br><span class="line"></span><br><span class="line">5收发数据，用函数send()和recv()，或者read()和write()</span><br><span class="line"></span><br><span class="line">6关闭网络连接</span><br><span class="line"></span><br><span class="line">2、客户端程序：</span><br><span class="line"></span><br><span class="line">1创建一个socket，用函数socket()</span><br><span class="line"></span><br><span class="line">2设置要连接的对方的IP地址和端口等属性</span><br><span class="line"></span><br><span class="line">3连接服务器，用函数connect()</span><br><span class="line"></span><br><span class="line">4收发数据，用函数send()和recv()，或read()和write()</span><br><span class="line"></span><br><span class="line">5关闭网络连接</span><br></pre></td></tr></table></figure>
<p>2）基于UDP的socket：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、服务器端流程</span><br><span class="line"></span><br><span class="line">1建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。</span><br><span class="line"></span><br><span class="line">2设置服务器地址和侦听端口，初始化要绑定的网络地址结构。</span><br><span class="line"></span><br><span class="line">3绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。</span><br><span class="line"></span><br><span class="line">4接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。</span><br><span class="line"></span><br><span class="line">5向客户端发送数据，使用sendto()函数向服务器主机发送数据。</span><br><span class="line"></span><br><span class="line">6关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</span><br><span class="line"></span><br><span class="line">2、客户端流程</span><br><span class="line"></span><br><span class="line">1建立套接字文件描述符，socket()。</span><br><span class="line"></span><br><span class="line">2设置服务器地址和端口，struct sockaddr。</span><br><span class="line"></span><br><span class="line">3向服务器发送数据，sendto()。</span><br><span class="line"></span><br><span class="line">4接收服务器的数据，recvfrom()。</span><br><span class="line"></span><br><span class="line">5关闭套接字，close()。</span><br></pre></td></tr></table></figure>

<h4 id="12-讲述一下Socket编程的send-recv-accept-socket-函数？"><a href="#12-讲述一下Socket编程的send-recv-accept-socket-函数？" class="headerlink" title="12.讲述一下Socket编程的send() recv() accept() socket()函数？"></a>12.讲述一下Socket编程的send() recv() accept() socket()函数？</h4><p>1.send函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。</p>
<p>2.recv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。</p>
<p>3.accept函数用了接收一个连接，内核维护了半连接队列和一个已完成连接队列，当队列为空的时候，accept函数阻塞，不为空的时候accept函数从上边取下来一个已完成连接，返回一个文件描述符。</p>
<h2 id="五、数据库"><a href="#五、数据库" class="headerlink" title="五、数据库"></a>五、数据库</h2><h3 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-数据库事务隔离"><a href="#1-数据库事务隔离" class="headerlink" title="1.数据库事务隔离"></a>1.数据库事务隔离</h4><p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<h4 id="2-数据库的四个基本特征"><a href="#2-数据库的四个基本特征" class="headerlink" title="2.数据库的四个基本特征"></a>2.数据库的四个基本特征</h4><p>1）原子性（Atomicity）</p>
<p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<p>2）一致性（Consistency）</p>
<p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<p>3）隔离性（Isolation）</p>
<p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>4）持久性（Durability）</p>
<p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<h4 id="3-索引是什么？"><a href="#3-索引是什么？" class="headerlink" title="3.索引是什么？"></a>3.索引是什么？</h4><p>1、索引</p>
<p>数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。</p>
<p>2、优点：</p>
<p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
<p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p>
<p>3、缺点：</p>
<p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p>
<p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p>
<h4 id="4-数据库的三大范式"><a href="#4-数据库的三大范式" class="headerlink" title="4.数据库的三大范式"></a>4.数据库的三大范式</h4><p>第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分</p>
<p>第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式</p>
<p>第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于键码</p>
<h4 id="5-mysql的MVCC机制"><a href="#5-mysql的MVCC机制" class="headerlink" title="5.mysql的MVCC机制"></a>5.mysql的MVCC机制</h4><ul>
<li>MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。</li>
<li>MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</li>
</ul>
<h4 id="6-SQL优化方法有哪些"><a href="#6-SQL优化方法有哪些" class="headerlink" title="6.SQL优化方法有哪些?"></a>6.SQL优化方法有哪些?</h4><ul>
<li>通过建立索引对查询进行优化</li>
<li>对查询进行优化，应尽量避免全表扫描</li>
</ul>
<h4 id="7-mongodb和redis的区别"><a href="#7-mongodb和redis的区别" class="headerlink" title="7.mongodb和redis的区别"></a>7.mongodb和redis的区别</h4><p>1.内存管理机制上</p>
<ul>
<li>Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据。</li>
<li>MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘。</li>
</ul>
<p>2.支持的数据结构上</p>
<ul>
<li>Redis 支持的数据结构丰富，包括hash、set、list等。</li>
<li>MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富</li>
</ul>
<h4 id="8-Redis是单线程的，但是为什么这么高效呢"><a href="#8-Redis是单线程的，但是为什么这么高效呢" class="headerlink" title="8.Redis是单线程的，但是为什么这么高效呢?"></a>8.Redis是单线程的，但是为什么这么高效呢?</h4><ul>
<li>通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型</li>
<li>又可以很好地与Redis服务器中其他同样以单线程运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</li>
</ul>
<h4 id="9-Redis和memcached的区别"><a href="#9-Redis和memcached的区别" class="headerlink" title="9.Redis和memcached的区别"></a>9.Redis和memcached的区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）数据类型 ：redis数据类型丰富，支持set liset等类型；memcache支持简单数据类型，需要客户端自己处理复杂对象</span><br><span class="line">2）持久性：redis支持数据落地持久化存储；memcache不支持数据持久存储。)</span><br><span class="line"></span><br><span class="line">3）分布式存储：redis支持master-slave复制模式；memcache可以使用一致性hash做分布式。</span><br><span class="line"></span><br><span class="line">4）value大小不同：memcache是一个内存缓存，key的长度小于250字符，单个item存储要小于1M，不适合虚拟机使用</span><br><span class="line"></span><br><span class="line">5）数据一致性不同：redis使用的是单线程模型，保证了数据按顺序提交；memcache需要使用cas保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作</span><br><span class="line"></span><br><span class="line">6）cpu利用：redis单线程模型只能使用一个cpu，可以开启多个redis进程</span><br></pre></td></tr></table></figure>

<h4 id="10-使用redis可能出现的问题"><a href="#10-使用redis可能出现的问题" class="headerlink" title="10.使用redis可能出现的问题"></a>10.使用redis可能出现的问题</h4><p>答： 在这里我们主要介绍Redis可能出现的三个问题，如下所示：</p>
<p>缓存雪崩：<br>举例：缓存同一时间大面积的失效，这个时候又来的一波请求都到数据库上，导致数据库连接异常。</p>
<p>解决办法：可以给缓存设置不同的缓存时间，更新数据使用互斥锁或者通过双缓存在避免缓存雪崩。</p>
<p>缓存穿透：<br>举例：故意的去请求缓存中不存在的数据，导致请求都打到了数据库上，导致数据库异常。</p>
<p>解决办法：可以使用互斥锁或者无论是否取到结果都将结果存入缓存，还可以使用有效的机制来拦截不合法的key值等。</p>
<p>数据库和缓存的双写一致性问题：<br>在高并发请求下很容易导致数据不一致的问题，如果你的业务需要保证数据的强一致性，那么建议不要使用缓存。在数据库中和缓存数据的删除或者写入过程中，如果有失败的情况，会导致数据的不一致。</p>
<h4 id="11-为什么-Redis-中要使用-I-O-多路复用这种技术呢？"><a href="#11-为什么-Redis-中要使用-I-O-多路复用这种技术呢？" class="headerlink" title="11.为什么 Redis 中要使用 I/O 多路复用这种技术呢？"></a>11.为什么 Redis 中要使用 I/O 多路复用这种技术呢？</h4><p>首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的。</p>
<p>阻塞式的 I/O 模型并不能满足这里的需求，我们需要一种效率更高的 I/O 模型来支撑 Redis 的多个客户（redis-cli），这里涉及的就是 I/O 多路复用模型了。<br>Redis 服务采用 Reactor 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符）</p>
<p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 accept、read、write 和 close 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。<br>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务实现的简单。</p>
<h2 id="六、设计模式"><a href="#六、设计模式" class="headerlink" title="六、设计模式"></a>六、设计模式</h2><h3 id="常见问题-3"><a href="#常见问题-3" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-OOP的设计模式的五项原则"><a href="#1-OOP的设计模式的五项原则" class="headerlink" title="1.OOP的设计模式的五项原则"></a>1.OOP的设计模式的五项原则</h4><p>1、单一职责原则</p>
<p>单一职责有2个含义，一个是避免相同的职责分散到不同的类中，另一个是避免一个类承担太多职责。减少类的耦合，提高类的复用性。</p>
<p>2、接口隔离原则</p>
<p>表明客户端不应该被强迫实现一些他们不会使用的接口，应该把胖接口中额方法分组，然后用多个接口代替它，每个接口服务于一个子模块。简单说，就是使用多个专门的接口比使用单个接口好很多。</p>
<p>3、开放-封闭原则</p>
<p>open模块的行为必须是开放的、支持扩展的，而不是僵化的。</p>
<p>closed在对模块的功能进行扩展时，不应该影响或大规模影响已有的程序模块。一句话概括：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。</p>
<p>4、替换原则</p>
<p>子类型必须能够替换掉他们的父类型、并出现在父类能够出现的任何地方。</p>
<p>5、依赖倒置原则</p>
<p>上层模块不应该依赖于下层模块，他们共同依赖于一个抽象，即：父类不能依赖子类，他们都要依赖抽象类。</p>
<p>抽象不能依赖于具体，具体应该要依赖于抽象</p>
<h4 id="2-你用过哪些设计模式"><a href="#2-你用过哪些设计模式" class="headerlink" title="2.你用过哪些设计模式"></a>2.你用过哪些设计模式</h4><p>单例模式：单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p>
<p>工厂模式：工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。</p>
<p>观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<h4 id="3-你所知道的设计模式有哪些？"><a href="#3-你所知道的设计模式有哪些？" class="headerlink" title="3.你所知道的设计模式有哪些？"></a>3.你所知道的设计模式有哪些？</h4><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模<br>式、建造者模式、原型模式。</p>
<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、<br>外观模式、桥接模式、组合模式、享元模式。</p>
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模<br>式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<h4 id="4-Android-中举几个例子说说用到了什么设计模式-？"><a href="#4-Android-中举几个例子说说用到了什么设计模式-？" class="headerlink" title="4.Android 中举几个例子说说用到了什么设计模式 ？"></a>4.Android 中举几个例子说说用到了什么设计模式 ？</h4><ul>
<li><p>AlertDialog、Notification 源码中使用了 Builder（建造者）<br>模式完成参数的初始化</p>
</li>
<li><p>Okhttp 内部使用了责任链模式来完成每个 Interceptor 拦截<br>器的调用</p>
</li>
<li><p>RxJava 的观察者模式；单例模式；GridView 的适配器模式；<br>Intent 的原型模式</p>
</li>
<li><p>日常开发的 BaseActivity 抽象工厂模式</p>
</li>
</ul>
<h2 id="七、git用法"><a href="#七、git用法" class="headerlink" title="七、git用法"></a>七、git用法</h2><h4 id="1-merge-和-rebase-的运行机制有什么不同"><a href="#1-merge-和-rebase-的运行机制有什么不同" class="headerlink" title="1. merge 和 rebase 的运行机制有什么不同"></a>1. merge 和 rebase 的运行机制有什么不同</h4><ol>
<li>可以看出merge结果能够体现出时间线，但是rebase会打乱时间线。 </li>
<li>而rebase看起来简洁，但是merge看起来不太简洁。 </li>
<li>最终结果是都把代码合起来了，所以具体怎么使用这两个命令看项目需要。</li>
</ol>
<p>还有一点说明的是，在项目中经常使用git pull来拉取代码，git pull相当于是git fetch + git merge，如果此时运行git pull -r，也就是git pull –rebase，相当于git fetch + git rebase</p>
]]></content>
      <categories>
        <category>面试笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>面试笔记</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>非诚勿扰——程序员专场</title>
    <url>/2020/06/22/%E9%9D%9E%E8%AF%9A%E5%8B%BF%E6%89%B0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%93%E5%9C%BA/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/%E9%9D%9E%E8%AF%9A%E5%8B%BF%E6%89%B0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%93%E5%9C%BA/oxj7mm.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">炫彩小镇</div>
</center>
> 本文是本人在Dian团队2019年的年终茶话会写的剧本，并且担任导演，当年该小品以高票当选第一名

<a id="more"></a>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/%E9%9D%9E%E8%AF%9A%E5%8B%BF%E6%89%B0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%93%E5%9C%BA/《非诚勿扰——程序员专场》.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">剧本</div>
</center>]]></content>
      <categories>
        <category>文集及讲座</category>
      </categories>
      <tags>
        <tag>剧本</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu使用ssr</title>
    <url>/2020/06/22/Ubuntu%E4%BD%BF%E7%94%A8ssr/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/Ubuntu%E4%BD%BF%E7%94%A8ssr/n6r6m7.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">深邃眼眸</div>
</center>

<h4 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h4><p>下载electron-ssr</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;shadowsocksrr&#x2F;electron-ssr&#x2F;releases</span><br></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i &lt;包名&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="二、配置终端"><a href="#二、配置终端" class="headerlink" title="二、配置终端"></a>二、配置终端</h4><p>先点击图标启动electron-ssr，将自己的ssr配置添加进去</p>
<p>终端临时走ssr需配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ export http_proxy&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:12333&quot;</span><br><span class="line">$ export https_proxy&#x3D;&quot;https:&#x2F;&#x2F;127.0.0.1:12333&quot;</span><br></pre></td></tr></table></figure>
<p>检测是否可以翻墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -i www.google.com</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上汇编环境搭建</title>
    <url>/2020/06/29/Mac%E4%B8%8Anasm%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/29/NWb44U.md.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">星路</div>
</center>

<blockquote>
<p>此文为学习汇编语言程序设计写代码时搭建的环境笔记</p>
</blockquote>
<a id="more"></a>

<h3 id="一、下载nasm"><a href="#一、下载nasm" class="headerlink" title="一、下载nasm"></a>一、下载nasm</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew install nasm</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi HelloWord.asm</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SECTION .data</span><br><span class="line"> </span><br><span class="line">msg: db &quot;HelloWorld!&quot;, 0x0a</span><br><span class="line">len: equ $-msg</span><br><span class="line"> </span><br><span class="line">SECTION .text</span><br><span class="line">global _main</span><br><span class="line"> </span><br><span class="line">_main:</span><br><span class="line">    mov rax,0x2000004  ;0x2000004 表示 syscall 调用号 write</span><br><span class="line">    mov rdi,1          ;表示控制台输出</span><br><span class="line">    mov rsi,msg        ;syscall 调用会到 rsi 来获取字符</span><br><span class="line">    mov rdx,len        ;字符串长度</span><br><span class="line">    syscall</span><br><span class="line"> </span><br><span class="line">    mov rax,0x2000001  ;0x2000001 表示退出 syscall</span><br><span class="line">    mov rdi,0</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nasm -f macho64 HelloWorld.asm -o HelloWorld.o</span><br></pre></td></tr></table></figure>
<p>链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ld -o HelloWorld -e _main HelloWorld.o -macosx_version_min 10.15 -static</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;HelloWorld</span><br></pre></td></tr></table></figure>

<h3 id="二、Mac-通过DOSBox搭建汇编环境"><a href="#二、Mac-通过DOSBox搭建汇编环境" class="headerlink" title="二、Mac 通过DOSBox搭建汇编环境"></a>二、Mac 通过DOSBox搭建汇编环境</h3><blockquote>
<p>该教程主要参考<a href="https://www.e-learn.cn/topic/3366973" target="_blank" rel="noopener">此博客</a>，学习汇编的资料在<a href="https://github.com/honghong1234/assembly-exercise" target="_blank" rel="noopener">https://github.com/honghong1234/assembly-exercise</a></p>
</blockquote>
<h4 id="1-下载安装相关工具"><a href="#1-下载安装相关工具" class="headerlink" title="1.下载安装相关工具"></a>1.下载安装相关工具</h4><p>选择Mac版的DOSBox</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.dosbox.com&#x2F;download.php?main&#x3D;1</span><br></pre></td></tr></table></figure>
<p>下载汇编常用工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">链接: https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1p5jMRxx0ISPCdOy1cIqR3Q  密码: u97w</span><br></pre></td></tr></table></figure>

<h4 id="2-在用户目录下新建DOSBox目录"><a href="#2-在用户目录下新建DOSBox目录" class="headerlink" title="2.在用户目录下新建DOSBox目录"></a>2.在用户目录下新建DOSBox目录</h4><p>制作目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir ~&#x2F;DOSBox&#x2F;</span><br></pre></td></tr></table></figure>
<p>修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;Users&#x2F;yzh&#x2F;Library&#x2F;Preferences&#x2F;DOSBox\ 0.74-3-1\ Preferences</span><br></pre></td></tr></table></figure>
<p>文件最后添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 挂载~&#x2F;DOSBox目录为C盘</span><br><span class="line">mount C ~&#x2F;DOSBox</span><br><span class="line"># 进入C盘（~&#x2F;DOSBox目录）</span><br><span class="line">C:</span><br></pre></td></tr></table></figure>
<p>启动BOSBox</p>
<h4 id="3-在DOSBox目录下编写helloworld测试DOSBox环境"><a href="#3-在DOSBox目录下编写helloworld测试DOSBox环境" class="headerlink" title="3.在DOSBox目录下编写helloworld测试DOSBox环境"></a>3.在DOSBox目录下编写helloworld测试DOSBox环境</h4><p>在桌面新建hello.asm文件，用记事本打开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DATAS SEGMENT</span><br><span class="line">    ;此处输入数据段代码  </span><br><span class="line">    ;13、10都是十进制，分别表示垂直制表符、退格，&#39;$&#39;表示字符串结尾</span><br><span class="line">    STRING  DB  &#39;Hello World!&#39;,13,10,&#39;$&#39;</span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line">STACKS SEGMENT</span><br><span class="line">    ;此处输入堆栈段代码</span><br><span class="line">STACKS ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">    ASSUME CS:CODES,DS:DATAS,SS:STACKS</span><br><span class="line">START:</span><br><span class="line">    MOV AX,DATAS</span><br><span class="line">    MOV DS,AX</span><br><span class="line">    ;此处输入代码段代码</span><br><span class="line">    </span><br><span class="line">    LEA  DX,STRING</span><br><span class="line">    MOV  AH,9</span><br><span class="line">    INT  21H</span><br><span class="line">    </span><br><span class="line">    MOV AH,4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure>
<p>汇编hello.asm文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MASM HELLO.ASM #回车三次</span><br></pre></td></tr></table></figure>
<p>链接HELLO.OBJ文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LINK HELLO.OBJ</span><br></pre></td></tr></table></figure>
<p>HELLO.EXE文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HELLO.EXE</span><br></pre></td></tr></table></figure>

<h4 id="4-DOSBox调试功能"><a href="#4-DOSBox调试功能" class="headerlink" title="4.DOSBox调试功能"></a>4.DOSBox调试功能</h4><ul>
<li>R命令查看、改变CPU寄存器的内容；</li>
<li>D命令查看内存中的内容；</li>
<li>E命令改写内存中的内容；</li>
<li>U命令将内存中的机器指令翻译成汇编指令；</li>
<li>T命令执行一条机器指令；</li>
<li>G命令跳转到偏移地址；</li>
<li>P命令结束循环或者是int 21H时是退出程序；</li>
<li>A命令是以汇编指令的格式在内存中写入一条机器指令。</li>
</ul>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Nasm</tag>
        <tag>DOSBox</tag>
      </tags>
  </entry>
  <entry>
    <title>MyTinySTL源码阅读笔记</title>
    <url>/2020/06/25/MyTinySTL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/25/N08yid.md.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">走向生</div>
</center>

<blockquote>
<p>此文为阅读MyTinySTL做的笔记，学习代码的风格与设计，以及实现算法</p>
</blockquote>
<a id="more"></a>

<h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h3><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h5 id="1-红黑树产生"><a href="#1-红黑树产生" class="headerlink" title="1.红黑树产生"></a>1.红黑树产生</h5><p>平衡二叉树真的很不错，在查找时既有着二叉查找树的优越性，在插入时还能通过调整继续保持着。那么为什么还要使用到红黑树呢？我觉得可以从以下两个方面来考虑：</p>
<p>（1）删除：对于平衡二叉树来说，在最坏情况下，需要维护从被删节点到根节点这条路径上所有节点的平衡性，旋转的量级是O(logN)。但是红黑树就不一样了，最多只需3次旋转就会重新平衡，旋转的量级是O(1)。</p>
<p>（2）保持平衡：平衡二叉树高度平衡，这也就意味着在大量插入和删除节点的场景下，平衡二叉树为了保持平衡需要调整的频率会更高。</p>
<p>注意：在大量查找的情况下，平衡二叉树的效率更高，也是首要选择。在大量增删的情况下，红黑树是首选。</p>
<p>鉴于以上原因，因此我们才使用到了红黑树这种更好的结构。上面提了这么多次红黑树，相信你已经迫不及待的想要认识一下了。下面就正式拉开红黑树的序幕。</p>
<h5 id="2-红黑树的应用场景"><a href="#2-红黑树的应用场景" class="headerlink" title="2.红黑树的应用场景"></a>2.红黑树的应用场景</h5><ul>
<li>STL中的Map和Set的数据结构</li>
<li>TreeMap in Java</li>
<li>HashMap in Java</li>
<li>计算机科学中的关联数组</li>
<li>Linux内核中完全公平调度</li>
<li>实时计算</li>
<li>计算几何</li>
</ul>
<h5 id="3-搜索"><a href="#3-搜索" class="headerlink" title="3.搜索"></a>3.搜索</h5><p>树的遍历</p>
<ul>
<li>广度优先（BFS）：先访问离根节点最近的点</li>
<li>深度优先（DFS）：前序遍历、中序遍历、后续遍历</li>
</ul>
<h5 id="3-红黑树的性质"><a href="#3-红黑树的性质" class="headerlink" title="3.红黑树的性质"></a>3.红黑树的性质</h5><ul>
<li>根节点必须黑色</li>
<li>父子不能同为红色</li>
<li>从任何一个节点出发，到达叶子节点经过的黑色节点数量必须一致</li>
</ul>
<h3 id="关于C-的积累"><a href="#关于C-的积累" class="headerlink" title="关于C++的积累"></a>关于C++的积累</h3><h4 id="1-C-C-中宏特殊字符的含义及用法总结"><a href="#1-C-C-中宏特殊字符的含义及用法总结" class="headerlink" title="1.C/C++/中宏特殊字符的含义及用法总结"></a>1.C/C++/中宏特殊字符的含义及用法总结</h4><p>在C／C＋＋中，宏定义是由define完成的，宏定义中有几种常见的特殊字符需要我们了解，常用的特殊字符有以下几种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#：在宏展开的时候会将#后面的参数替换成字符串； 字符串化</span><br><span class="line">##:将前后两个的单词拼接在一起； 连接化</span><br><span class="line">#@:将值序列变为一个字符；   字符化</span><br><span class="line">\:将两行连接起来。行连接化</span><br></pre></td></tr></table></figure>

<h4 id="2-typedef-typename的使用"><a href="#2-typedef-typename的使用" class="headerlink" title="2.typedef typename的使用"></a>2.typedef typename的使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef typename std::vector&lt;T&gt;::size_type size_type;</span><br></pre></td></tr></table></figure>

<p>语句的意思是：<br>typedef创建了存在类型的别名，而typename告诉编译器std::vector<T>::size_type是一个类型而不是一个成员。</T></p>
<h4 id="3-C-中的-default和-delete"><a href="#3-C-中的-default和-delete" class="headerlink" title="3.C++中的 =default和=delete"></a>3.C++中的 =default和=delete</h4><p>每当我们声明一个有参构造函数时，编译器就不会创建默认构造函数。在这种情况下，我们可以使用default说明符来创建默认说明符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; use of defaulted functions</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; A user-defined</span><br><span class="line">    A(int x)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;This is a parameterized constructor&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Using the default specifier to instruct</span><br><span class="line">    &#x2F;&#x2F; the compiler to create the default implementation of the constructor.</span><br><span class="line">    A() &#x3D; default;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    A a;          &#x2F;&#x2F;call A()</span><br><span class="line">    A x(1);       &#x2F;&#x2F;call A(int x)</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C ++ 11之前，操作符delete 只有一个目的，即释放已动态分配的内存。而C ++ 11标准引入了此操作符的另一种用法，即：禁用成员函数的使用。这是通过附加= delete来完成的; 说明符到该函数声明的结尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; copy-constructor using delete operator </span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std; </span><br><span class="line">  </span><br><span class="line">class A &#123; </span><br><span class="line">public: </span><br><span class="line">    A(int x): m(x) &#123; &#125; </span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; Delete the copy constructor </span><br><span class="line">    A(const A&amp;) &#x3D; delete;      </span><br><span class="line">    &#x2F;&#x2F; Delete the copy assignment operator </span><br><span class="line">    A&amp; operator&#x3D;(const A&amp;) &#x3D; delete;  </span><br><span class="line">    int m; </span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line">int main() &#123; </span><br><span class="line">    A a1(1), a2(2), a3(3); </span><br><span class="line">    &#x2F;&#x2F; Error, the usage of the copy assignment operator is disabled </span><br><span class="line">    a1 &#x3D; a2;   </span><br><span class="line">    &#x2F;&#x2F; Error, the usage of the copy constructor is disabled </span><br><span class="line">    a3 &#x3D; A(a2);  </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>MyTinySTL</tag>
      </tags>
  </entry>
  <entry>
    <title>cJson源码阅读</title>
    <url>/2020/06/23/cJson%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/23/Ntg2o6.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">朦胧脸庞</div>
</center>

<blockquote>
<p>此文为阅读cJson做的笔记，学习代码的风格与设计</p>
</blockquote>
<a id="more"></a>

<h4 id="一、cJson的数据结构"><a href="#一、cJson的数据结构" class="headerlink" title="一、cJson的数据结构"></a>一、cJson的数据结构</h4><p>cJSON的数据结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* The cJSON structure: *&#x2F;</span><br><span class="line">typedef struct cJSON &#123;</span><br><span class="line">	struct cJSON *next,*prev;	&#x2F;* next&#x2F;prev allow you to walk array&#x2F;object chains. Alternatively, use GetArraySize&#x2F;GetArrayItem&#x2F;GetObjectItem *&#x2F;</span><br><span class="line">	struct cJSON *child;		&#x2F;* An array or object item will have a child pointer pointing to a chain of the items in the array&#x2F;object. *&#x2F;</span><br><span class="line"></span><br><span class="line">	int type;					&#x2F;* The type of the item, as above. *&#x2F;</span><br><span class="line"></span><br><span class="line">	char *valuestring;			&#x2F;* The item&#39;s string, if type&#x3D;&#x3D;cJSON_String *&#x2F;</span><br><span class="line">	int valueint;				&#x2F;* The item&#39;s number, if type&#x3D;&#x3D;cJSON_Number *&#x2F;</span><br><span class="line">	double valuedouble;			&#x2F;* The item&#39;s number, if type&#x3D;&#x3D;cJSON_Number *&#x2F;</span><br><span class="line"></span><br><span class="line">	char *string;				&#x2F;* The item&#39;s name string, if this item is the child of, or is in the list of subitems of an object. *&#x2F;</span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure>

<p>其中，typey有7种类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* cJSON Types: *&#x2F;</span><br><span class="line">#define cJSON_False 0</span><br><span class="line">#define cJSON_True 1</span><br><span class="line">#define cJSON_NULL 2</span><br><span class="line">#define cJSON_Number 3</span><br><span class="line">#define cJSON_String 4</span><br><span class="line">#define cJSON_Array 5</span><br><span class="line">#define cJSON_Object 6</span><br></pre></td></tr></table></figure>

<h4 id="二、cJson的使用"><a href="#二、cJson的使用" class="headerlink" title="二、cJson的使用"></a>二、cJson的使用</h4><h5 id="构造json"><a href="#构造json" class="headerlink" title="构造json"></a>构造json</h5><p> 要构建的json：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;semantic&quot;: &#123;</span><br><span class="line">        &quot;slots&quot;:    &#123;</span><br><span class="line">            &quot;name&quot;: &quot;张三&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rc&quot;:   0,</span><br><span class="line">    &quot;operation&quot;:    &quot;CALL&quot;,</span><br><span class="line">    &quot;service&quot;:  &quot;telephone&quot;,</span><br><span class="line">    &quot;text&quot;: &quot;打电话给张三&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;cJSON.h&quot;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cJSON * root &#x3D;  cJSON_CreateObject();</span><br><span class="line">    cJSON * item &#x3D;  cJSON_CreateObject();</span><br><span class="line">    cJSON * next &#x3D;  cJSON_CreateObject();</span><br><span class="line"> </span><br><span class="line">    cJSON_AddItemToObject(root, &quot;rc&quot;, cJSON_CreateNumber(0));&#x2F;&#x2F;根节点下添加</span><br><span class="line">    cJSON_AddItemToObject(root, &quot;operation&quot;, cJSON_CreateString(&quot;CALL&quot;));</span><br><span class="line">    cJSON_AddItemToObject(root, &quot;service&quot;, cJSON_CreateString(&quot;telephone&quot;));</span><br><span class="line">    cJSON_AddItemToObject(root, &quot;text&quot;, cJSON_CreateString(&quot;打电话给张三&quot;));</span><br><span class="line">    cJSON_AddItemToObject(root, &quot;semantic&quot;, item);&#x2F;&#x2F;root节点下添加semantic节点</span><br><span class="line">    cJSON_AddItemToObject(item, &quot;slots&quot;, next);&#x2F;&#x2F;semantic节点下添加item节点</span><br><span class="line">    cJSON_AddItemToObject(next, &quot;name&quot;, cJSON_CreateString(&quot;张三&quot;));&#x2F;&#x2F;添加name节点</span><br><span class="line"> </span><br><span class="line">    printf(&quot;%s\n&quot;, cJSON_Print(root));</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="解析的json"><a href="#解析的json" class="headerlink" title="解析的json"></a>解析的json</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;semantic&quot;: &#123;</span><br><span class="line">        &quot;slots&quot;:    &#123;</span><br><span class="line">            &quot;name&quot;: &quot;张三&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rc&quot;:   0,</span><br><span class="line">    &quot;operation&quot;:    &quot;CALL&quot;,</span><br><span class="line">    &quot;service&quot;:  &quot;telephone&quot;,</span><br><span class="line">    &quot;text&quot;: &quot;打电话给张三&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;cJSON.h&quot;</span><br><span class="line"> </span><br><span class="line">void printJson(cJSON * root)&#x2F;&#x2F;以递归的方式打印json的最内层键值对</span><br><span class="line">&#123;</span><br><span class="line">    for(int i&#x3D;0; i&lt;cJSON_GetArraySize(root); i++)   &#x2F;&#x2F;遍历最外层json键值对</span><br><span class="line">    &#123;</span><br><span class="line">        cJSON * item &#x3D; cJSON_GetArrayItem(root, i);        </span><br><span class="line">        if(cJSON_Object &#x3D;&#x3D; item-&gt;type)      &#x2F;&#x2F;如果对应键的值仍为cJSON_Object就递归调用printJson</span><br><span class="line">            printJson(item);</span><br><span class="line">        else                                &#x2F;&#x2F;值不为json对象就直接打印出键和值</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%s-&gt;&quot;, item-&gt;string);</span><br><span class="line">            printf(&quot;%s\n&quot;, cJSON_Print(item));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char * jsonStr &#x3D; &quot;&#123;\&quot;semantic\&quot;:&#123;\&quot;slots\&quot;:&#123;\&quot;name\&quot;:\&quot;张三\&quot;&#125;&#125;, \&quot;rc\&quot;:0, \&quot;operation\&quot;:\&quot;CALL\&quot;, \&quot;service\&quot;:\&quot;telephone\&quot;, \&quot;text\&quot;:\&quot;打电话给张三\&quot;&#125;&quot;;</span><br><span class="line">    cJSON * root &#x3D; NULL;</span><br><span class="line">    cJSON * item &#x3D; NULL;&#x2F;&#x2F;cjson对象</span><br><span class="line"> </span><br><span class="line">    root &#x3D; cJSON_Parse(jsonStr);     </span><br><span class="line">    if (!root) </span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Error before: [%s]\n&quot;,cJSON_GetErrorPtr());</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, &quot;有格式的方式打印Json:&quot;);           </span><br><span class="line">        printf(&quot;%s\n\n&quot;, cJSON_Print(root));</span><br><span class="line">        printf(&quot;%s\n&quot;, &quot;无格式方式打印json：&quot;);</span><br><span class="line">        printf(&quot;%s\n\n&quot;, cJSON_PrintUnformatted(root));</span><br><span class="line"> </span><br><span class="line">        printf(&quot;%s\n&quot;, &quot;一步一步的获取name 键值对:&quot;);</span><br><span class="line">        printf(&quot;%s\n&quot;, &quot;获取semantic下的cjson对象:&quot;);</span><br><span class="line">        item &#x3D; cJSON_GetObjectItem(root, &quot;semantic&quot;);&#x2F;&#x2F;</span><br><span class="line">        printf(&quot;%s\n&quot;, cJSON_Print(item));</span><br><span class="line">        printf(&quot;%s\n&quot;, &quot;获取slots下的cjson对象&quot;);</span><br><span class="line">        item &#x3D; cJSON_GetObjectItem(item, &quot;slots&quot;);</span><br><span class="line">        printf(&quot;%s\n&quot;, cJSON_Print(item));</span><br><span class="line">        printf(&quot;%s\n&quot;, &quot;获取name下的cjson对象&quot;);</span><br><span class="line">        item &#x3D; cJSON_GetObjectItem(item, &quot;name&quot;);</span><br><span class="line">        printf(&quot;%s\n&quot;, cJSON_Print(item));</span><br><span class="line"> </span><br><span class="line">        printf(&quot;%s:&quot;, item-&gt;string);   &#x2F;&#x2F;看一下cjson对象的结构体中这两个成员的意思</span><br><span class="line">        printf(&quot;%s\n&quot;, item-&gt;valuestring);</span><br><span class="line">                        </span><br><span class="line"> </span><br><span class="line">        printf(&quot;\n%s\n&quot;, &quot;打印json所有最内层键值对:&quot;);</span><br><span class="line">        printJson(root);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="三、算法提炼"><a href="#三、算法提炼" class="headerlink" title="三、算法提炼"></a>三、算法提炼</h4><h5 id="pow2gt函数"><a href="#pow2gt函数" class="headerlink" title="pow2gt函数"></a>pow2gt函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int pow2gt (int x)	&#123;</span><br><span class="line">   	  --x;	</span><br><span class="line">      x|&#x3D;x&gt;&gt;1;	</span><br><span class="line">      x|&#x3D;x&gt;&gt;2;	</span><br><span class="line">      x|&#x3D;x&gt;&gt;4;	</span><br><span class="line">      x|&#x3D;x&gt;&gt;8;	</span><br><span class="line">      x|&#x3D;x&gt;&gt;16;	</span><br><span class="line">      return x+1;	</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/loading/loading.gif" data-original="./cJson%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/20161013234606_75816.png" alt></p>
<p>考虑到int是32位，那么对于任何一个M，当它执行完上图中的5步操作后，M的最左边为1的那位向右全部被赋值为1，因此，在最后return x+1 时，就会返回&gt;=M最小的2的N次方数。而最开始的–x，是因为当x本身就是一个2的N次方数时，返回值为x本身，所以需要减1来保证正确性。</p>
<h4 id="四、使用的函数学习"><a href="#四、使用的函数学习" class="headerlink" title="四、使用的函数学习"></a>四、使用的函数学习</h4><h5 id="1-int-tolower-int-c"><a href="#1-int-tolower-int-c" class="headerlink" title="1.int tolower(int c)"></a>1.int tolower(int c)</h5><p>C 库函数 int tolower(int c) 把给定的字母转换为小写字母。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int i &#x3D; 0;</span><br><span class="line">   char c;</span><br><span class="line">   char str[] &#x3D; &quot;RUNOOB&quot;;</span><br><span class="line"> </span><br><span class="line">   while( str[i] ) </span><br><span class="line">   &#123;</span><br><span class="line">      putchar(tolower(str[i]));</span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob</span><br></pre></td></tr></table></figure>

<h5 id="2-memcpy-void-str1-const-void-str2-size-t-n"><a href="#2-memcpy-void-str1-const-void-str2-size-t-n" class="headerlink" title="2.memcpy(void *str1, const void *str2, size_t n)"></a>2.memcpy(void *str1, const void *str2, size_t n)</h5><blockquote>
<p>C 库函数 void *memcpy(void *str1, const void *str2, size_t n) 从存储区 str2 复制 n 个字节到存储区 str1。</p>
</blockquote>
<ul>
<li>str1 – 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li>
<li>str2 – 指向要复制的数据源，类型强制转换为 void* 指针。</li>
<li>n – 要被复制的字节数。</li>
</ul>
<h5 id="3-memset"><a href="#3-memset" class="headerlink" title="3.memset()"></a>3.memset()</h5><blockquote>
<p>C 库函数 void *memset(void *str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void *memset(void *str, int c, size_t n)</span><br></pre></td></tr></table></figure>
<ul>
<li>str – 指向要填充的内存块。</li>
<li>c – 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。</li>
<li>n – 要被设置为该值的字节数。</li>
</ul>
<h4 id="风格学习"><a href="#风格学习" class="headerlink" title="风格学习"></a>风格学习</h4><ul>
<li>函数命名要规范，尽量表达清楚函数的用途</li>
<li>相近函数功能在头文件里放到一块</li>
<li>每个函数上面要写清楚注释，说明函数的功能，每个函数的参数的意义，以及某些参数限定的传参</li>
<li>对输入参数进行过滤，尤其判断一些异常情况</li>
</ul>
<h4 id="五、其他细节问题"><a href="#五、其他细节问题" class="headerlink" title="五、其他细节问题"></a>五、其他细节问题</h4><h5 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h5><p>在cJson的头文件中存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot;</span><br></pre></td></tr></table></figure>
<p>C++之父在设计C++之时，考虑到当时已经存在了大量的C代码，为了支持原来的C代码和已经写好C库，需要在C++中尽可能的支持C，而extern “C”就是其中的一个策略。</p>
<p>因此，为了在C++代码中调用用C写成的库文件，就需要用extern “C”来告诉编译器:这是一个用C写成的库文件，请用C的方式来链接它们。</p>
<h5 id="extern声明函数"><a href="#extern声明函数" class="headerlink" title="extern声明函数"></a>extern声明函数</h5><p>如果函数 的声明中带有关键字extern，仅仅是暗示这个函数 可能在别的源文件里定义，没有其它作用。即下述两个函数 声明没有明显的区别：extern int f(); 和int f();</p>
<p>当然，这样的用处还是有的，就是在程序中取代include “*.h”来声明函数 ，在一些复杂的项目中，比较习惯在所有的函数 声明前添加extern修饰。</p>
<h5 id="size-t和int区别"><a href="#size-t和int区别" class="headerlink" title="size_t和int区别"></a>size_t和int区别</h5><p> size_t是一些C/C++标准在stddef.h中定义的。这个类型足以用来表示对象的大小。size_t的真实类型与操作系统有关。</p>
<p> 在32位架构中被普遍定义为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef   unsigned int size_t;</span><br></pre></td></tr></table></figure>
<p>而在64位架构中被定义为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef  unsigned long size_t;</span><br></pre></td></tr></table></figure>
<p>为什么有时候不用int，而是用size_type或者size_t</p>
<blockquote>
<p>与int固定四个字节不同有所不同,size_t的取值range是目标平台下最大可能的数组尺寸,一些平台下size_t的范围小于int的正数范围,又或者大于unsigned int. 使用Int既有可能浪费，又有可能范围不够大。</p>
</blockquote>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>cJson</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言程序设计</title>
    <url>/2020/06/28/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/28/N2R1Bj.md.png">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">眼神</div>
</center>

<blockquote>
<p>此文为学习汇编语言程序设计所做的笔记</p>
</blockquote>
<a id="more"></a>

<h3 id="第一章-汇编语言基础"><a href="#第一章-汇编语言基础" class="headerlink" title="第一章 汇编语言基础"></a>第一章 汇编语言基础</h3><h4 id="一、硬件组成"><a href="#一、硬件组成" class="headerlink" title="一、硬件组成"></a>一、硬件组成</h4><p>从应用角度看，汇编语言程序员可以将计算机抽象为：寄存器、存储器地址、输入输出地址</p>
<h5 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1.寄存器"></a>1.寄存器</h5><ul>
<li>处理器内部的高速存储单元</li>
<li>用于暂时存放程序执行过程中的代码和数据</li>
<li>透明寄存器：对应用人员不可见、不能编程直接控制</li>
<li>可编程寄存器：通用寄存器、专用寄存器</li>
</ul>
<h5 id="2-通用寄存器"><a href="#2-通用寄存器" class="headerlink" title="2.通用寄存器"></a>2.通用寄存器</h5><ul>
<li>32位通用寄存器：EAX、EBX、ECX、EDX；ESI、EDI；EBP、ESP</li>
<li>16位通用寄存器：AX、BX、CX、DX、SI、DI、BP、SP</li>
<li>8位通用寄存器：AH、AL、BH、BL、CH、CL、DH、DL</li>
</ul>
<h5 id="3-专用寄存器"><a href="#3-专用寄存器" class="headerlink" title="3.专用寄存器"></a>3.专用寄存器</h5><ul>
<li>标志寄存器：EFLAGS</li>
<li>指令指针寄存器：EIP</li>
<li>段寄存器：CS、DS、SS、ES、FS、GS</li>
</ul>
<h5 id="4-通用寄存器名称"><a href="#4-通用寄存器名称" class="headerlink" title="4.通用寄存器名称"></a>4.通用寄存器名称</h5><ul>
<li>EAX：累加器</li>
<li>EBX：基址寄存器</li>
<li>ECX：计数器</li>
<li>EDX：数据寄存器</li>
<li>ESI：源变址寄存器</li>
<li>EDI：目的编制寄存器</li>
<li>EBP：基址指针</li>
<li>ESP：堆栈指针</li>
</ul>
<h4 id="二、存储器组织"><a href="#二、存储器组织" class="headerlink" title="二、存储器组织"></a>二、存储器组织</h4><h5 id="1-存储器地址"><a href="#1-存储器地址" class="headerlink" title="1.存储器地址"></a>1.存储器地址</h5><ul>
<li>主存储器容量很大，被划分成许多存储单元</li>
<li>每个存储单元被编排一个号码、即存储单元地址</li>
<li>每个存储单元一字节为基本存储单位，即按字节编址，一个字节等于8bit</li>
</ul>
<h5 id="2-位、字节、字、双字"><a href="#2-位、字节、字、双字" class="headerlink" title="2.位、字节、字、双字"></a>2.位、字节、字、双字</h5><p>双字 = 2 字 = 4字节 = 32 位</p>
<h5 id="3-存储模型"><a href="#3-存储模型" class="headerlink" title="3.存储模型"></a>3.存储模型</h5><ul>
<li>高性能处理器集成存储管理单元MMU</li>
<li>操作系统利用MMU进行主存进行管理</li>
<li>IA-32处理处理器提供3种存储模型：平展存储模型、段式存储模型、实地址存储模型</li>
</ul>
<h5 id="4-存储空间分段管理"><a href="#4-存储空间分段管理" class="headerlink" title="4.存储空间分段管理"></a>4.存储空间分段管理</h5><p>“段”是保存相关代码或数据的一个主存区域</p>
<ul>
<li>代码段：存放程序的可执行代码</li>
<li>数据段：存放程序所有的数据，例如全局变量</li>
<li>堆栈段：程序需要的特殊区域，存放放回地址、临时变量等</li>
</ul>
<h5 id="5-逻辑地址"><a href="#5-逻辑地址" class="headerlink" title="5.逻辑地址"></a>5.逻辑地址</h5><ul>
<li>存储器空间可以分段管理，采用逻辑地址指示</li>
<li>逻辑地址 = 段地址 ： 偏移地址</li>
<li>处理器内部以及程序员编程时采用逻辑地址</li>
</ul>
<h5 id="6-物理地址和逻辑地址的转换"><a href="#6-物理地址和逻辑地址的转换" class="headerlink" title="6.物理地址和逻辑地址的转换"></a>6.物理地址和逻辑地址的转换</h5><ul>
<li>程序员编程时采用逻辑地址</li>
<li>操作系统利用存储管理单元MMU将逻辑地址映射为线性地址（虚拟地址）</li>
<li>处理器使用物理地址访问存储器芯片</li>
</ul>
<h5 id="7-Win32的虚拟地址分配"><a href="#7-Win32的虚拟地址分配" class="headerlink" title="7.Win32的虚拟地址分配"></a>7.Win32的虚拟地址分配</h5><ul>
<li>系统区（2GB）：操作系统代码、系统DLL等</li>
<li>用户区（2GB）：用户DLL、进程堆栈、DOS/Win16兼容区、空指针区、</li>
</ul>
<h5 id="8-标志寄存器"><a href="#8-标志寄存器" class="headerlink" title="8.标志寄存器"></a>8.标志寄存器</h5><ul>
<li>状态寄存器：记录指令执行结果的辅助信息</li>
<li>控制标志：方向DF，仅用于串操作指令</li>
<li>系统标志：控制操作系统或核心管理程序的操作方式</li>
</ul>
<h5 id="9-指令指针寄存器EIP"><a href="#9-指令指针寄存器EIP" class="headerlink" title="9.指令指针寄存器EIP"></a>9.指令指针寄存器EIP</h5><ul>
<li>顺序执行时自动增量</li>
<li>分支、调用等操作时执行控制转移指令修改</li>
<li>出现中断或异常时被处理器赋值二相应改变</li>
</ul>
<h5 id="10-段寄存器"><a href="#10-段寄存器" class="headerlink" title="10.段寄存器"></a>10.段寄存器</h5><p>段寄存器表明某个段在主存中的位置</p>
<ul>
<li>代码段（CS）——基地址由代码段CS指示、偏移地址由指令指针寄存器EIP保存</li>
<li>堆栈段（SS）——基地址由SS指示、偏移地址由ESP指示</li>
<li>数据段（DS、ES、FS、GS）——段基地址由DS指示，有时也由ES、FS、GS指示，偏移地址由有效地址EA指示</li>
</ul>
<h4 id="三、处理器指令格式"><a href="#三、处理器指令格式" class="headerlink" title="三、处理器指令格式"></a>三、处理器指令格式</h4><h5 id="1-处理器指令"><a href="#1-处理器指令" class="headerlink" title="1.处理器指令"></a>1.处理器指令</h5><ul>
<li>程序用程序设计语言编写，有指令构成</li>
<li>指令由操作码和操作数组成</li>
<li>操作码在汇编语言使用指令助记符表示</li>
<li>操作数在汇编语言中使用寄存器、变量、常量等形式表示</li>
</ul>
<h5 id="2-IA-32处理器的代码格式"><a href="#2-IA-32处理器的代码格式" class="headerlink" title="2.IA-32处理器的代码格式"></a>2.IA-32处理器的代码格式</h5><ul>
<li>IA-32处理器采用可变长的指令格式</li>
<li>操作码——可选的指令前缀；1~3字节的主要操作吗</li>
<li>操作数——可选的地址域、可选的的位移量、可选的立即数</li>
</ul>
<h5 id="3-汇编语言语句"><a href="#3-汇编语言语句" class="headerlink" title="3.汇编语言语句"></a>3.汇编语言语句</h5><ul>
<li>源程序由语句组成</li>
<li>通常一个语句占一行</li>
<li>一个语句不操作132个字符，4个部分</li>
<li>执行性语句：表达处理器指令、实行功能</li>
<li>说明性语句：表达伪指令，控制编程方式</li>
</ul>
<h5 id="4-标号和名字"><a href="#4-标号和名字" class="headerlink" title="4.标号和名字"></a>4.标号和名字</h5><ul>
<li>标号和名字是用户定义的标识符</li>
<li>标号在执行性语句中</li>
<li>名字在说明性语句中</li>
</ul>
<h5 id="5-标识符"><a href="#5-标识符" class="headerlink" title="5.标识符"></a>5.标识符</h5><ul>
<li>取名原则类似于高级语言，但是默认不区别大小写字母</li>
<li>不能以数字开头</li>
<li>在一个源程序中，用户定义的每个标识符必须唯一</li>
<li>不能是保留字</li>
</ul>
<h5 id="6-助记符"><a href="#6-助记符" class="headerlink" title="6.助记符"></a>6.助记符</h5><ul>
<li>帮助记忆指令功能的符号</li>
<li>硬指令助记符表示处理器指令</li>
<li>伪指令助记符表达一个汇编命令</li>
</ul>
<h5 id="7-包含伪指令INCLUDE"><a href="#7-包含伪指令INCLUDE" class="headerlink" title="7.包含伪指令INCLUDE"></a>7.包含伪指令INCLUDE</h5><ul>
<li>用于声明常用的常量定义、过程说明、共享的子程序库等</li>
<li>相当于C和C++语言中，包含头文件的作用</li>
</ul>
<h5 id="8-程序的开始和结束"><a href="#8-程序的开始和结束" class="headerlink" title="8.程序的开始和结束"></a>8.程序的开始和结束</h5><ul>
<li>程序开始执行的位置（使用一个标号，作为汇编结束END伪指令的参数）</li>
<li>应用程序执行终止（语句“EXIT 0”终止程序执行，返回操作系统，提供一个返回代码0）</li>
<li>源程序汇编结束——使用END伪指令语句</li>
</ul>
<h3 id="第二章-数据表示"><a href="#第二章-数据表示" class="headerlink" title="第二章 数据表示"></a>第二章 数据表示</h3><h4 id="一、常量表达"><a href="#一、常量表达" class="headerlink" title="一、常量表达"></a>一、常量表达</h4><h5 id="1-常量"><a href="#1-常量" class="headerlink" title="1.常量"></a>1.常量</h5><ul>
<li>常量是程序中使用的一个确定数值</li>
<li>表达形式：常数、字符和字符串、符号常量、数值表达式</li>
</ul>
<h4 id="二、变量定义"><a href="#二、变量定义" class="headerlink" title="二、变量定义"></a>二、变量定义</h4><h5 id="1-什么是变量"><a href="#1-什么是变量" class="headerlink" title="1.什么是变量"></a>1.什么是变量</h5><ul>
<li>变量是随程序运行会变化的数据，保存在刻度可写的主存空间</li>
<li>变量表达主存数据，即存储操作数</li>
</ul>
<h5 id="2-变量的定义"><a href="#2-变量的定义" class="headerlink" title="2.变量的定义"></a>2.变量的定义</h5><ul>
<li>变量名：用户标识符，表示首元素逻辑地址；</li>
<li>变量定义伪指令：为指令助记符，表示变量类型</li>
<li>初值表：用逗号分隔的一个或多个参数，表示变量初值</li>
</ul>
<h5 id="3-主要的变量定义伪指令"><a href="#3-主要的变量定义伪指令" class="headerlink" title="3.主要的变量定义伪指令"></a>3.主要的变量定义伪指令</h5><ul>
<li>BYTE：每个数据8位</li>
<li>WORD：每个数据16位</li>
<li>DWORD：每个数据32位</li>
</ul>
<h5 id="4-变量定义的初值表"><a href="#4-变量定义的初值表" class="headerlink" title="4.变量定义的初值表"></a>4.变量定义的初值表</h5><ul>
<li>使用“？”表示初值不确定，即未赋初值</li>
<li>使用赋值操作符DUP表示多个同样的数值，形式：重复次数 DUP（重复参数）</li>
</ul>
<h4 id="三、变量运用"><a href="#三、变量运用" class="headerlink" title="三、变量运用"></a>三、变量运用</h4><h5 id="1-字节数据的存储顺序"><a href="#1-字节数据的存储顺序" class="headerlink" title="1.字节数据的存储顺序"></a>1.字节数据的存储顺序</h5><ul>
<li>大端方式：高对低，低对高</li>
<li>小端方式：高对高、低对低</li>
</ul>
<h5 id="2-变量属性"><a href="#2-变量属性" class="headerlink" title="2.变量属性"></a>2.变量属性</h5><ul>
<li>地址属性：首个变量所在存储单元的逻辑地址</li>
<li>类型属性：变量定义的数据单位</li>
</ul>
<h5 id="3-变量的地址属性及地址操作符"><a href="#3-变量的地址属性及地址操作符" class="headerlink" title="3.变量的地址属性及地址操作符"></a>3.变量的地址属性及地址操作符</h5><ul>
<li>[]:括起来的表达式作为存储器地址指针</li>
<li>$:返回当前偏移的地址</li>
<li>OFFSET 变量名:返回变量名所在段的偏移地址</li>
<li>SEG 变量名:返回段基地址</li>
</ul>
<h5 id="4-类型操作符"><a href="#4-类型操作符" class="headerlink" title="4.类型操作符"></a>4.类型操作符</h5><ul>
<li>类型名 PTR 变量名：将变量名按照指定的类型使用</li>
<li>TYPE 变量名：返回占用字节空间的数字量数值</li>
<li>LENGTHOF 变量名：返回整个变量的数据项</li>
<li>SIZEOF 变量名：返回整个变量占用的字节数</li>
</ul>
<h3 id="第三章-数据寻址"><a href="#第三章-数据寻址" class="headerlink" title="第三章 数据寻址"></a>第三章 数据寻址</h3><h4 id="一、立即数寻址"><a href="#一、立即数寻址" class="headerlink" title="一、立即数寻址"></a>一、立即数寻址</h4><h5 id="1-寻址方式"><a href="#1-寻址方式" class="headerlink" title="1.寻址方式"></a>1.寻址方式</h5><ul>
<li>数据寻址：指令执行过程中，访问所需要操作的数据</li>
<li>指令寻址：一条指令执行后，确定执行的下一条指令的位置</li>
</ul>
<h5 id="2-数据寻址"><a href="#2-数据寻址" class="headerlink" title="2.数据寻址"></a>2.数据寻址</h5><ul>
<li>立即数寻址：数据保存在指令代码中</li>
<li>寄存器寻址：数据在寄存器中，用寄存器名表示</li>
<li>存储器寻址：数据来自主存储器，变量指向存储单元，所以访问变量就是存储器寻址。</li>
<li>IO寻址：数据在外设中，用IO地址表示，可分为直接寻址和间接寻址</li>
</ul>
<h4 id="二、寄存器寻址"><a href="#二、寄存器寻址" class="headerlink" title="二、寄存器寻址"></a>二、寄存器寻址</h4><ul>
<li>操作数存放在处理器的内部</li>
<li>用寄存器名表示它的内容</li>
</ul>
<h4 id="三、存储器寻址"><a href="#三、存储器寻址" class="headerlink" title="三、存储器寻址"></a>三、存储器寻址</h4><h5 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h5><ul>
<li>指令代码表达形式地址</li>
<li>由形式地址结合规则经过计算得到有效地址EA</li>
<li>处理器将有效地址转换为物理地址访问存储单元</li>
<li>逻辑地址 = 段基地址 ： 偏移地址</li>
</ul>
<h5 id="2-段寄存器指示段基地址"><a href="#2-段寄存器指示段基地址" class="headerlink" title="2.段寄存器指示段基地址"></a>2.段寄存器指示段基地址</h5><ul>
<li>读取指令，一定是代码段CS</li>
<li>堆栈操作，针对堆栈段SS</li>
<li>读取数据，默认在数据段DS</li>
</ul>
<h5 id="3-32位有效地址的组成"><a href="#3-32位有效地址的组成" class="headerlink" title="3.32位有效地址的组成"></a>3.32位有效地址的组成</h5><p>基址寄存器 + 变址寄存器 * 比例 + 位移量</p>
<ul>
<li>基址寄存器 ：任何8个32位通用寄存器之一</li>
<li>变址寄存器：除ESP外的任何32位通用寄存器之一</li>
<li>比例：1，2，4或8</li>
<li>位移量：8或32位有符号位</li>
</ul>
<h5 id="4-16位有效地址的组成"><a href="#4-16位有效地址的组成" class="headerlink" title="4.16位有效地址的组成"></a>4.16位有效地址的组成</h5><p>基地址寄存器 + 变址寄存器 + 位移量</p>
<ul>
<li>基地址寄存器：BX或BP</li>
<li>变址寄存器：SI或DI</li>
<li>位移量：8或16位有符号值</li>
</ul>
<h5 id="5-直接寻址常用于存取变量"><a href="#5-直接寻址常用于存取变量" class="headerlink" title="5.直接寻址常用于存取变量"></a>5.直接寻址常用于存取变量</h5><ul>
<li>直接使用变量名</li>
<li>变量名加或减一个常量</li>
<li>使用中括号括起的变量名</li>
</ul>
<h5 id="6-寄存器间接寻址和相对寻址"><a href="#6-寄存器间接寻址和相对寻址" class="headerlink" title="6.寄存器间接寻址和相对寻址"></a>6.寄存器间接寻址和相对寻址</h5><ul>
<li>间接寻址其有效地址存放在寄存器中，用中括号括起寄存器表达</li>
<li>相对寻址其有效地址是寄存器内容与位移量之和，寄存器要用中括号括起来</li>
</ul>
<h3 id="第四章-通用数据处理指令"><a href="#第四章-通用数据处理指令" class="headerlink" title="第四章 通用数据处理指令"></a>第四章 通用数据处理指令</h3><h4 id="一、数据传送类指令"><a href="#一、数据传送类指令" class="headerlink" title="一、数据传送类指令"></a>一、数据传送类指令</h4><ul>
<li>MOV：把一个字节、字或双字的操作数从源位置传送至目的位置</li>
<li>LEA：地址传送指令获取存储器操作数的地址</li>
<li>PUSH：数据压进堆栈</li>
<li>POP：数据弹出堆栈</li>
</ul>
<h4 id="二、算术运算类指令"><a href="#二、算术运算类指令" class="headerlink" title="二、算术运算类指令"></a>二、算术运算类指令</h4><h5 id="1-进位标志位CF和溢出标志位"><a href="#1-进位标志位CF和溢出标志位" class="headerlink" title="1.进位标志位CF和溢出标志位"></a>1.进位标志位CF和溢出标志位</h5><ul>
<li>当加减法运算结果的最高有效位（加法）或借位（减法）时，进位标志位置1</li>
<li>针对无符号整数，判断加减结果是否超出表达范围</li>
<li>有溢出，运算结果已经不正确</li>
<li>无符号数，关心进位；有符号数，注意溢出</li>
</ul>
<h5 id="2-零标志、符号标志和奇偶标志"><a href="#2-零标志、符号标志和奇偶标志" class="headerlink" title="2.零标志、符号标志和奇偶标志"></a>2.零标志、符号标志和奇偶标志</h5><ul>
<li>运行结果为0，则零标志ZF置1</li>
<li>运算结果最高位为1，则符号标志位SF=1，即最高位=符号位</li>
<li>当运算结果最低字节中“1”的个数为零或偶数时，奇偶标志位PF=1；否则PF=0</li>
</ul>
<h5 id="3-运算指令"><a href="#3-运算指令" class="headerlink" title="3.运算指令"></a>3.运算指令</h5><ul>
<li>ADD：目的操作数加上源操作数，和送到目的操作数</li>
<li>SUB：目的操作数减去源操作数，差送到目的操作数</li>
<li>INC：只有一个操作数，将寄存器中的操作数加一返回原处</li>
<li>DEC：只有一个操作数，将寄存器中的操作数减一返回原处</li>
<li><ul>
<li>NEG：只有一个操作数，将寄存器中的操作数进行求补运算，即用零减去操所数</li>
</ul>
</li>
</ul>
<h4 id="三、位操作类指令"><a href="#三、位操作类指令" class="headerlink" title="三、位操作类指令"></a>三、位操作类指令</h4><h5 id="1-逻辑运算指令"><a href="#1-逻辑运算指令" class="headerlink" title="1.逻辑运算指令"></a>1.逻辑运算指令</h5><ul>
<li>AND：逻辑与</li>
<li>OR：逻辑或</li>
<li>NOT：逻辑非</li>
<li>XOR：逻辑异或</li>
<li>TEST：测试指令</li>
</ul>
<h5 id="2-移位指令"><a href="#2-移位指令" class="headerlink" title="2.移位指令"></a>2.移位指令</h5><ul>
<li>逻辑左移指令 SHL：各位同时左移</li>
<li>逻辑右移指令 SHR：各位同时右移</li>
<li>算术左移指令 SAL：各位同时左移，最高位不变</li>
<li>算术右移指令 SAR：各位同时右移，最高位不变</li>
</ul>
<h5 id="3-循环移位指令"><a href="#3-循环移位指令" class="headerlink" title="3.循环移位指令"></a>3.循环移位指令</h5><ul>
<li>不带进位循环左移指令 ROL</li>
<li>不带进位循环右移指令 ROR</li>
<li>带进位循环左移指令 RCL</li>
<li>带进位循环右移指令 RCR</li>
</ul>
<h3 id="第五章-顺序程序结构"><a href="#第五章-顺序程序结构" class="headerlink" title="第五章 顺序程序结构"></a>第五章 顺序程序结构</h3><p>程序的顺序结构是不含分支、循环和调用的一条语句（指令）、一条语句（指令）逐个顺序执行的程序结构。</p>
<ul>
<li>移位可以实现乘法（10 = 2^3 + 2）</li>
<li>自然数求和程序</li>
</ul>
<h3 id="第六章-分支程序结构"><a href="#第六章-分支程序结构" class="headerlink" title="第六章 分支程序结构"></a>第六章 分支程序结构</h3><h4 id="一、指令寻址方式"><a href="#一、指令寻址方式" class="headerlink" title="一、指令寻址方式"></a>一、指令寻址方式</h4><h5 id="1-指令寻址"><a href="#1-指令寻址" class="headerlink" title="1.指令寻址"></a>1.指令寻址</h5><ul>
<li>顺序寻址</li>
<li>跳转寻址——直接寻址、相对寻址、间接寻址（寄存器间接寻址、存储器间接寻址）</li>
</ul>
<h5 id="2-指令的直接寻址"><a href="#2-指令的直接寻址" class="headerlink" title="2.指令的直接寻址"></a>2.指令的直接寻址</h5><ul>
<li>直接提供目的地址</li>
<li>目标地址 = 指令操作数</li>
</ul>
<h5 id="3-指令的间接寻址"><a href="#3-指令的间接寻址" class="headerlink" title="3.指令的间接寻址"></a>3.指令的间接寻址</h5><ul>
<li>目标地址来自寄存器或存储单元、间接获得</li>
<li>可分为寄存器间接寻址和存储器间接寻址</li>
</ul>
<h5 id="4-程序流程的控制转移"><a href="#4-程序流程的控制转移" class="headerlink" title="4.程序流程的控制转移"></a>4.程序流程的控制转移</h5><ul>
<li>程序代码在代码段，CS指明代码段在主存中的段基地址，EIP给出将要执行的偏移地址</li>
<li>指令调转寻址，程序控制转移，EIP（CS）随之改变</li>
<li>通过改变EIP（和CS）控制程序流程，实现程序分支、循环、调用等结构</li>
</ul>
<h5 id="5-无条件转移指令（JMP）"><a href="#5-无条件转移指令（JMP）" class="headerlink" title="5.无条件转移指令（JMP）"></a>5.无条件转移指令（JMP）</h5><ul>
<li>JMP lable 程序转向lable标号指定的地址</li>
<li>JMP reg32/reg16 程序转向寄存器指定的地址</li>
<li>JMP mem48/mem32/mem16 程序转向存储单元指定的地址</li>
</ul>
<h5 id="6-条件转移指令（Jcc）"><a href="#6-条件转移指令（Jcc）" class="headerlink" title="6.条件转移指令（Jcc）"></a>6.条件转移指令（Jcc）</h5><ul>
<li>单个标志状态位作为条件；两数大小关系作为条件</li>
<li>ZF：JZ，JE；JNZ，JNE</li>
<li>CF：JC，JNC</li>
<li>OF：JO，JNO</li>
<li>SF：JS，JNS</li>
<li>PF：JP，JPE，JNP，JPO</li>
</ul>
<h4 id="二、单分支结构"><a href="#二、单分支结构" class="headerlink" title="二、单分支结构"></a>二、单分支结构</h4><ul>
<li>注意和if-then语句相反，当瞒住条件，就发生转移，跳过分支体</li>
<li>条件不满足，顺序向下执行分支体</li>
</ul>
<h4 id="三、双分支结构"><a href="#三、双分支结构" class="headerlink" title="三、双分支结构"></a>三、双分支结构</h4><ul>
<li>相当于高级语言的if-then-else语句</li>
<li>条件为真执行一个分支，条件为假执行另一个分支</li>
</ul>
<h3 id="第七章-循环指令结构"><a href="#第七章-循环指令结构" class="headerlink" title="第七章 循环指令结构"></a>第七章 循环指令结构</h3><h4 id="一、循环指令"><a href="#一、循环指令" class="headerlink" title="一、循环指令"></a>一、循环指令</h4><h5 id="1-LOOP指令"><a href="#1-LOOP指令" class="headerlink" title="1.LOOP指令"></a>1.LOOP指令</h5><ul>
<li>LOOP是循环指令，用于实现减量计数多的循环控制</li>
<li>初值为0时循环次数为2^32次</li>
<li>LOOP指令是先减1后做判断</li>
</ul>
<h5 id="2-JECXZ指令"><a href="#2-JECXZ指令" class="headerlink" title="2.JECXZ指令"></a>2.JECXZ指令</h5><ul>
<li>为避免计数初值为0可能导致的程序错误</li>
<li>用于跳过ECX=0的情况</li>
</ul>
<h4 id="二、计数控制循环"><a href="#二、计数控制循环" class="headerlink" title="二、计数控制循环"></a>二、计数控制循环</h4><ul>
<li>计数可以减量进行，即减到0结束</li>
<li>计数可以增量进行，即达到规定值结束</li>
</ul>
<h4 id="三、条件控制循环"><a href="#三、条件控制循环" class="headerlink" title="三、条件控制循环"></a>三、条件控制循环</h4><ul>
<li>根据条件决定是否进行循环</li>
<li>所见的是“先判断、后循环”结构</li>
</ul>
<h3 id="第八章-子程序结构"><a href="#第八章-子程序结构" class="headerlink" title="第八章 子程序结构"></a>第八章 子程序结构</h3><h4 id="一、子程序设计"><a href="#一、子程序设计" class="headerlink" title="一、子程序设计"></a>一、子程序设计</h4><h5 id="1-子程序指令"><a href="#1-子程序指令" class="headerlink" title="1.子程序指令"></a>1.子程序指令</h5><ul>
<li>主程序：执行调用指令CALL调用子程序</li>
<li>子程序：执行返回指令RET返回主程序</li>
</ul>
<h4 id="二、参数传递"><a href="#二、参数传递" class="headerlink" title="二、参数传递"></a>二、参数传递</h4><h5 id="1-参数传递"><a href="#1-参数传递" class="headerlink" title="1.参数传递"></a>1.参数传递</h5><ul>
<li>参数分类：入口参数、出口参数</li>
<li>参数具体内容：数据本身、数据的存储地址</li>
<li>参数传递方式：通用寄存器、共享变量、堆栈</li>
</ul>
<h5 id="2-寄存器传参"><a href="#2-寄存器传参" class="headerlink" title="2.寄存器传参"></a>2.寄存器传参</h5><ul>
<li>把参数存于约定的寄存器</li>
<li>少量数据直接传递数值</li>
<li>大量数据只能传递地址</li>
<li>带有出口参数的寄存器不能保护和恢复</li>
</ul>
<h5 id="3-共享变量传参"><a href="#3-共享变量传参" class="headerlink" title="3.共享变量传参"></a>3.共享变量传参</h5><ul>
<li>子程序和主程序使用同一个变量名存取数据</li>
<li>如果变量定义和使用不在同一个程序模块中，需要使用PUBLIC、EXTERN声明</li>
<li>特别适合在多个程序段间、尤其在不同程序模块间传递数据</li>
<li>对应高级语言中的全局变量</li>
</ul>
<h5 id="4-堆栈传递参数"><a href="#4-堆栈传递参数" class="headerlink" title="4.堆栈传递参数"></a>4.堆栈传递参数</h5><ul>
<li>主程序将入口参数压入堆栈</li>
<li>子程序从堆栈中取出参数</li>
<li>出口参数通常不适用堆栈传递</li>
</ul>
<h4 id="三、程序模块"><a href="#三、程序模块" class="headerlink" title="三、程序模块"></a>三、程序模块</h4><h5 id="1-MASM支持的多模块方法"><a href="#1-MASM支持的多模块方法" class="headerlink" title="1.MASM支持的多模块方法"></a>1.MASM支持的多模块方法</h5><ul>
<li>源文件包含</li>
<li>模块连接</li>
<li>子程序库</li>
<li>库文件包含</li>
</ul>
<h5 id="2-源文件包含"><a href="#2-源文件包含" class="headerlink" title="2.源文件包含"></a>2.源文件包含</h5><ul>
<li>INC：各种常量、声明语句等组织在包含文件</li>
<li>MAC：常用的或有价值的宏定义存放宏定义文件</li>
<li>ASM：常用的子程序形成汇编语言源文件</li>
</ul>
<h5 id="3-模块连接"><a href="#3-模块连接" class="headerlink" title="3.模块连接"></a>3.模块连接</h5><p>子程序单独编写一个源程序文件</p>
<ul>
<li>使用共用伪指令PUBLIC和外部伪指令EXTERN声明</li>
<li>子程序在代码段，与主程序文件采用相同的存储模型</li>
<li>没有开始执行和结束执行点，但有汇编结束语句</li>
<li>处理好子程序与主程序之间的参数传递问题</li>
</ul>
<h5 id="4-子程序库的使用"><a href="#4-子程序库的使用" class="headerlink" title="4.子程序库的使用"></a>4.子程序库的使用</h5><ul>
<li>子程序单独编写一个源程序文件</li>
<li>子程序源文件汇编形成目标模块OBJ文件</li>
<li>利用库管理工具把子程序模块加入到子程序库</li>
<li>在连接主程序时提供子程序库文件名</li>
</ul>
<h5 id="5-库文件包含"><a href="#5-库文件包含" class="headerlink" title="5.库文件包含"></a>5.库文件包含</h5><ul>
<li>要使用已存入库文件中的子程序</li>
<li>在主程序源文件中用库文件包含伪指令INCLUDELIB声明</li>
</ul>
<h5 id="6-宏汇编"><a href="#6-宏汇编" class="headerlink" title="6.宏汇编"></a>6.宏汇编</h5><ul>
<li>宏（Macro）是具有宏名的一段汇编语句序列</li>
<li>宏需要先使用MACRO/ENDM伪指令进行定义</li>
<li>然后在程序中使用宏名（带参数）进行宏调用</li>
<li>源程序进行汇编时，宏名被汇编程序用宏定义的，代码序列替代，实现宏展开</li>
<li>这个过程就是“宏汇编”</li>
</ul>
<h5 id="7-宏与子程序"><a href="#7-宏与子程序" class="headerlink" title="7.宏与子程序"></a>7.宏与子程序</h5><ul>
<li>宏仅是源程序级的简化</li>
<li>子程序不仅简化源程序，还是目标程序级的简化</li>
<li>当程序段较短或要求较快执行时，选用宏</li>
<li>当程序段较长或为减小目标代码时，选用子程序</li>
</ul>
]]></content>
      <categories>
        <category>汇编语言程序设计</category>
      </categories>
      <tags>
        <tag>汇编语言程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程笔记</title>
    <url>/2020/06/23/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/23/Ntg2o6.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">朦胧脸庞</div>
</center>

<blockquote>
<p>此文为学习北京大学孙艳春 、黄罡 、刘譞哲的软件工程所做的笔记</p>
</blockquote>
<a id="more"></a>

<h3 id="第一章-软件工程简介"><a href="#第一章-软件工程简介" class="headerlink" title="第一章 软件工程简介"></a>第一章 软件工程简介</h3><h4 id="一、软件的定义及特点"><a href="#一、软件的定义及特点" class="headerlink" title="一、软件的定义及特点"></a>一、软件的定义及特点</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>计算机中的程序及其文档</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>无形的、不可见的逻辑实体</li>
<li>没有磨损、老化的问题</li>
<li>是设计开发的，不是生产制造的</li>
<li>复杂、开发成本高、易于复制</li>
</ul>
<h5 id="软件的种类"><a href="#软件的种类" class="headerlink" title="软件的种类"></a>软件的种类</h5><ul>
<li>系统软件：操作系统、编译器</li>
<li>支撑软件——支持软件开发、维护和运行的软件：中间件、数据库</li>
<li>应用软件：财务管理软件、浏览器</li>
</ul>
<h4 id="二、软件工程的起源和概念"><a href="#二、软件工程的起源和概念" class="headerlink" title="二、软件工程的起源和概念"></a>二、软件工程的起源和概念</h4><h5 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h5><ul>
<li>早期计算机程序</li>
<li>在信息产业中，微电子是基础，计算机是载体，软件是<strong>核心</strong></li>
</ul>
<h5 id="软件开发的三个阶段"><a href="#软件开发的三个阶段" class="headerlink" title="软件开发的三个阶段"></a>软件开发的三个阶段</h5><ul>
<li>个人程序时期</li>
<li>软件作坊时期</li>
<li>软件工程时期</li>
</ul>
<h5 id="软件工程的定义"><a href="#软件工程的定义" class="headerlink" title="软件工程的定义"></a>软件工程的定义</h5><blockquote>
<p><em>其目的是倡导使用工程的原理、原则和方法进行软件开发，已解决软件危机</em></p>
</blockquote>
<h4 id="三、软件开发的本质和基本手段"><a href="#三、软件开发的本质和基本手段" class="headerlink" title="三、软件开发的本质和基本手段"></a>三、软件开发的本质和基本手段</h4><h5 id="软件开发的含义"><a href="#软件开发的含义" class="headerlink" title="软件开发的含义"></a>软件开发的含义</h5><blockquote>
<p>实现问题域c中的概念和处理逻辑到运行平台的概念和处理逻辑的映射</p>
</blockquote>
<p>问题域-&gt;需求-&gt;设计-&gt;实现-&gt;运行平台</p>
<h5 id="实现映射的基本手段"><a href="#实现映射的基本手段" class="headerlink" title="实现映射的基本手段"></a>实现映射的基本手段</h5><p>建模</p>
<ul>
<li>概念模型</li>
<li>设计模型</li>
<li>实现模型</li>
<li>部署模型</li>
</ul>
<h4 id="四、软件工程框架"><a href="#四、软件工程框架" class="headerlink" title="四、软件工程框架"></a>四、软件工程框架</h4><p>软件框架三元组——目标、原则、活动</p>
<h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><blockquote>
<p>生产具有正确性、可用性以及开销合宜的产品</p>
</blockquote>
<h5 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h5><blockquote>
<p>生产一个具有最终满足需求且达到工程目标的软件产品所需的步骤<br>主要包括需求、设计、实现、确认和支持等活动</p>
</blockquote>
<h5 id="框架的作用"><a href="#框架的作用" class="headerlink" title="框架的作用"></a>框架的作用</h5><ul>
<li>给出软件所涉及软件工程的工程要素</li>
<li>给出各要素之间的关系</li>
<li>给出软件工程学科所研究的主要内容</li>
</ul>
<h4 id="五、软件生存周期"><a href="#五、软件生存周期" class="headerlink" title="五、软件生存周期"></a>五、软件生存周期</h4><h5 id="生存周期概念"><a href="#生存周期概念" class="headerlink" title="生存周期概念"></a>生存周期概念</h5><blockquote>
<p>软件产品或系统的一系列活动的全周期。从形成的概念开始，经历开发、交付使用、在使用中不断修订和演化，直到最后被淘汰。</p>
</blockquote>
<h4 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h4><ul>
<li>软件过程：活动的集合</li>
<li>活动：任务的集合</li>
<li>任务：将输入转换为输出的操作</li>
</ul>
<h4 id="六、生存周期过程的分类"><a href="#六、生存周期过程的分类" class="headerlink" title="六、生存周期过程的分类"></a>六、生存周期过程的分类</h4><h5 id="过程分类"><a href="#过程分类" class="headerlink" title="过程分类"></a>过程分类</h5><ul>
<li>基本过程：指那些和软件生产直接相关的活动集<blockquote>
<p>具体分为获取过程、供应过程、开发过程、运行过程、维护过程</p>
</blockquote>
</li>
<li>支持过程：有关各方按目标所从事的一系列支持活动集<blockquote>
<p>文档过程、配置管理过程、质量保证、验证过程、确认过程、联合审评、审计过程、问题解决</p>
</blockquote>
</li>
<li>组织过程：那些与软件生产组织有关的活动集<blockquote>
<p>管理过程、基础设施过程、改进过程、人力资源过程、资产管理过程、复用程序管理过程、领域软件工程过程</p>
</blockquote>
</li>
</ul>
<h4 id="七、常见的软件生存周期模型"><a href="#七、常见的软件生存周期模型" class="headerlink" title="七、常见的软件生存周期模型"></a>七、常见的软件生存周期模型</h4><h5 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h5><ul>
<li>将软件生存周期的各项活动规定为依固定顺序而连接的若干阶段工作</li>
<li>每个阶段的输入，以及本阶段的工作成果，作为输出传入下一阶段</li>
</ul>
<h5 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h5><ul>
<li>是瀑布模型的第一个变体，具有瀑布模型的所有优点</li>
<li>第一个版本交付版本所需要的成本和时间是很少的</li>
<li>由于很快发布第一个版本，因此可以减少用户需求的变更</li>
</ul>
<h5 id="演化模型"><a href="#演化模型" class="headerlink" title="演化模型"></a>演化模型</h5><ul>
<li>是一种有弹性的过程模式</li>
<li>由一些小的开发步组成，每步历经需求分析、设计、实现和验证，产生软件产品的一个增量</li>
</ul>
<h5 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h5><ul>
<li>迭代、无缝</li>
<li>与面向对象技术的关系</li>
</ul>
<h3 id="第二章-软件需求"><a href="#第二章-软件需求" class="headerlink" title="第二章 软件需求"></a>第二章 软件需求</h3><h4 id="一、需求的作用"><a href="#一、需求的作用" class="headerlink" title="一、需求的作用"></a>一、需求的作用</h4><ul>
<li>需求分析</li>
<li>软件体系结构设计</li>
<li>验证、正确及测试</li>
</ul>
<h4 id="二、需求的定义"><a href="#二、需求的定义" class="headerlink" title="二、需求的定义"></a>二、需求的定义</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><blockquote>
<p>一个需求是一个有关“要予构造”的称述，描述了待开发产品/系统功能上的能力、性能参数或者其他性质。</p>
</blockquote>
<h5 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h5><ul>
<li>必要的</li>
<li>无歧义的</li>
<li>可测量的</li>
<li>可跟踪的</li>
</ul>
<h4 id="三、需求分类"><a href="#三、需求分类" class="headerlink" title="三、需求分类"></a>三、需求分类</h4><ul>
<li><p>功能</p>
<blockquote>
<p>功能需求规约了系统或者系统构建必须执行的功能</p>
</blockquote>
</li>
<li><p>性能</p>
<blockquote>
<p>规约了一个系统或系统构建必须具有的性能特性</p>
</blockquote>
</li>
<li><p>外部接口</p>
<blockquote>
<p>系统接口、用户接口、硬件接口、软件接口、通讯接口、内存约束、操作、地点需求</p>
</blockquote>
</li>
<li><p>约束设计</p>
<blockquote>
<p>设计约束限制了系统或系统构件的设计方案，对项目规划、所需的附加成本和工作生产直接影响</p>
</blockquote>
</li>
<li><p>质量属性</p>
<blockquote>
<p>可靠性、存活性、可维护性、用户友好性、安全性、可移植性</p>
</blockquote>
</li>
</ul>
<h4 id="四、需求发现"><a href="#四、需求发现" class="headerlink" title="四、需求发现"></a>四、需求发现</h4><ul>
<li>自悟</li>
<li>交谈</li>
<li>小组会</li>
<li>观察</li>
<li>提炼</li>
<li>综合运用</li>
</ul>
<h4 id="五、需求规约的概念和格式"><a href="#五、需求规约的概念和格式" class="headerlink" title="五、需求规约的概念和格式"></a>五、需求规约的概念和格式</h4><p>需求规约是一个软件产品/系统的概念模型</p>
<ul>
<li>引言：目的、范围、定义、参考文献、概述</li>
<li>总体描述：产品概述、产品功能、约束、假设和依赖</li>
<li>特定需求</li>
<li>附录</li>
<li>索引</li>
</ul>
<h3 id="第三章-结构化分析方法"><a href="#第三章-结构化分析方法" class="headerlink" title="第三章 结构化分析方法"></a>第三章 结构化分析方法</h3><h4 id="一、结构化分析方法概念"><a href="#一、结构化分析方法概念" class="headerlink" title="一、结构化分析方法概念"></a>一、结构化分析方法概念</h4><p>软件开发方法：软件卡法过程所遵循的办法和步骤；软件开发活动的目的是有效地得到一个运行的系统及其支持文档，并且满足有关的质量要求；<br>软件开发方法学指的是规则、方法和工具的集成</p>
<p>结构化方法</p>
<ul>
<li>结构化分析方法</li>
<li>结构化设计方法</li>
<li>结构化程序设计方法</li>
</ul>
<p>结构分析</p>
<ul>
<li>提供一组术语</li>
<li>给出表达模型的工具</li>
<li>给出指导过程</li>
</ul>
<h4 id="二、结构化分析模型"><a href="#二、结构化分析模型" class="headerlink" title="二、结构化分析模型"></a>二、结构化分析模型</h4><p>结构化设计一般又可分为概要设计阶段和详细设计阶段。</p>
<h5 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h5><ul>
<li>数据流</li>
<li>加工 </li>
<li>数据存储</li>
<li>数据源</li>
<li>数据潭<br>其中数据流、数据存储支持数据抽象</li>
</ul>
<h5 id="模型表达工具"><a href="#模型表达工具" class="headerlink" title="模型表达工具"></a>模型表达工具</h5><ul>
<li>DFD图：描述系统功能</li>
<li>数据字典</li>
<li>加工小说明</li>
</ul>
<h4 id="三、初始化模块结构图精化的启发式规则"><a href="#三、初始化模块结构图精化的启发式规则" class="headerlink" title="三、初始化模块结构图精化的启发式规则"></a>三、初始化模块结构图精化的启发式规则</h4><h5 id="启发式"><a href="#启发式" class="headerlink" title="启发式"></a>启发式</h5><p>根据设计准则，从长期开发实践中，总结出来的设计准则</p>
<h5 id="常见的六种启发式规则"><a href="#常见的六种启发式规则" class="headerlink" title="常见的六种启发式规则"></a>常见的六种启发式规则</h5><ul>
<li>改进软件结构，提高模块独立性;</li>
<li>模块规模适中-每页60行语句;</li>
<li>深度、宽度、扇入和扇出适中;</li>
<li>模块的作用域力争在控制域之内;</li>
<li>降低模块接口的复杂性;</li>
<li>模块功能应该可以预测。</li>
</ul>
<h4 id="四、接口设计"><a href="#四、接口设计" class="headerlink" title="四、接口设计"></a>四、接口设计</h4><h5 id="接口设计的分类"><a href="#接口设计的分类" class="headerlink" title="接口设计的分类"></a>接口设计的分类</h5><ul>
<li>模块或软件构件间的接口设计</li>
<li>软件与其他软硬件系统之间的接口设计</li>
<li>软件与人之间的交互设计</li>
</ul>
<h5 id="设计遵循原则"><a href="#设计遵循原则" class="headerlink" title="设计遵循原则"></a>设计遵循原则</h5><ul>
<li>一致性</li>
<li>操作步骤少</li>
<li>不要”哑播放“</li>
<li>提供Undo功能</li>
<li>减少人脑的记忆负担</li>
<li>提高学习效率</li>
</ul>
<h4 id="五、数据设计"><a href="#五、数据设计" class="headerlink" title="五、数据设计"></a>五、数据设计</h4><ul>
<li>文件设计</li>
<li>数据库设计</li>
</ul>
<h4 id="六、详细设计工具"><a href="#六、详细设计工具" class="headerlink" title="六、详细设计工具"></a>六、详细设计工具</h4><ul>
<li>伪码（PDL）：一种混合语言，外部使用形式语言定义控制结构和数据结构，每部使用自然语言。</li>
<li>路程图：顺序、选择、循环</li>
<li>PAD图：支持自顶向下逐步求精的结构化详细设计，PAD图是一种描述程序逻辑结构的工具</li>
<li>N-S图</li>
<li>判定表和判定树</li>
</ul>
<h4 id="七、软件设计规约"><a href="#七、软件设计规约" class="headerlink" title="七、软件设计规约"></a>七、软件设计规约</h4><h5 id="概念和组成"><a href="#概念和组成" class="headerlink" title="概念和组成"></a>概念和组成</h5><blockquote>
<p>概念：软件设计规约对软件的组织或其组成部分的内部结构的描述，满足系统需求规约所指定的全部功能及性能要求</p>
</blockquote>
<blockquote>
<p>组成：概要设计规约和详细设计规约</p>
</blockquote>
<h5 id="概要设计规约"><a href="#概要设计规约" class="headerlink" title="概要设计规约"></a>概要设计规约</h5><ul>
<li>系统环境</li>
<li>设计描述</li>
<li>对每个模块的描述</li>
<li>数据结构和全局数据</li>
</ul>
<h5 id="详细设计规约"><a href="#详细设计规约" class="headerlink" title="详细设计规约"></a>详细设计规约</h5><p>在概要设计的基础上，增加：各处理过程的算法；算法所设计的全部数据结构的描述</p>
<h5 id="设计规约的格式"><a href="#设计规约的格式" class="headerlink" title="设计规约的格式"></a>设计规约的格式</h5><ul>
<li>引言</li>
<li>总体设计</li>
</ul>
<h4 id="八、结构化方法的总结"><a href="#八、结构化方法的总结" class="headerlink" title="八、结构化方法的总结"></a>八、结构化方法的总结</h4><h5 id="世界观"><a href="#世界观" class="headerlink" title="世界观"></a>世界观</h5><blockquote>
<p>一切系统都是由信息流构成的，每个信息流都有自己的起点——数据源，自己归宿——数据潭，驱动信息流动的加工，因此所谓信息处理主要表现为信息的流动。</p>
</blockquote>
<h5 id="基本原理和原则"><a href="#基本原理和原则" class="headerlink" title="基本原理和原则"></a>基本原理和原则</h5><ul>
<li>自顶向下功能分解</li>
<li>数据抽象</li>
<li>功能抽象</li>
<li>模块化</li>
</ul>
<p>结构化方法的抽象层包括</p>
<ul>
<li>需求分析层</li>
<li>设计层</li>
<li>实现层</li>
</ul>
<h3 id="第三章-UML"><a href="#第三章-UML" class="headerlink" title="第三章 UML"></a>第三章 UML</h3><h4 id="一、面向对象方法的概念"><a href="#一、面向对象方法的概念" class="headerlink" title="一、面向对象方法的概念"></a>一、面向对象方法的概念</h4><h5 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h5><ul>
<li>使用面向对象程序设计语言</li>
<li>使用对象、类、集成、封装、消息等基本概念进行编程</li>
</ul>
<h5 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h5><ul>
<li>用对象作为对这些事务的抽象表示，并以此作为系统的基本构成单位</li>
<li>封装：对象的属性和操作做结合为一体，构成一个独立的实体，对外屏蔽其内部细节</li>
<li>对事务进行分类，把具有相同属性和相同操作的对象归为一类</li>
<li>通过不同程度的上运用抽象原则，可以得到较一般和较特殊的类</li>
<li>复杂的对象可以用简单的对象作为其构成的部分</li>
<li>对象之间只能通过消息进行通信</li>
<li>用关联表达类之间的静态关系</li>
</ul>
<h5 id="面向对象学习内容"><a href="#面向对象学习内容" class="headerlink" title="面向对象学习内容"></a>面向对象学习内容</h5><ul>
<li>基本知识</li>
<li>面向对象的分析（OOA）</li>
<li>面向对象的设计（OOD）</li>
<li>面向对象的程序设计（OOP）</li>
</ul>
<h4 id="二、UML的概念"><a href="#二、UML的概念" class="headerlink" title="二、UML的概念"></a>二、UML的概念</h4><h5 id="UML概念"><a href="#UML概念" class="headerlink" title="UML概念"></a>UML概念</h5><blockquote>
<p>UML是系统设计和分析的工具</p>
</blockquote>
<ul>
<li>规约系统的制品</li>
<li>构造系的制品</li>
</ul>
<h5 id="面向对象方法术语"><a href="#面向对象方法术语" class="headerlink" title="面向对象方法术语"></a>面向对象方法术语</h5><ul>
<li>结构化表达客观事物的术语</li>
<li>表达客观事物之间关系的术语</li>
<li>用于组织特定对象结构的包</li>
<li>注解</li>
</ul>
<h4 id="三、类和对象"><a href="#三、类和对象" class="headerlink" title="三、类和对象"></a>三、类和对象</h4><h5 id="定义和表示"><a href="#定义和表示" class="headerlink" title="定义和表示"></a>定义和表示</h5><blockquote>
<p>类：一组具有相同属性、操作、关系和语义的对象的描述</p>
</blockquote>
<blockquote>
<p>对象：类的一个实例</p>
</blockquote>
<h5 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h5><ul>
<li>使用黑体字。，第一个字母通常大写，位于第一栏的中央</li>
<li>简单的名词或者名词短语</li>
</ul>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li>一个类可以有多个属性或者没有属性</li>
<li>可见性：公有的；受保护的（其子类才能使用）；私有的（本类的操作才能使用）；包内的：只有在同一包中声明的类才能使用</li>
</ul>
<h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><ul>
<li>操作名除了第一个词之外，其他单词首字母需要大写</li>
<li>操作可以是抽象操作，此时采用斜体</li>
<li>可见性：与类相同</li>
<li>返回值</li>
<li>参数表</li>
</ul>
<h4 id="四、接口"><a href="#四、接口" class="headerlink" title="四、接口"></a>四、接口</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><blockquote>
<p>接口是一组操作的集合，其中每个操作描述了类或者构件的一个服务</p>
</blockquote>
<blockquote>
<p>基本作用：模型化系统的“接缝”</p>
</blockquote>
<h5 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h5><ul>
<li>可以用带有分栏和关键字的矩阵符号来表示接口</li>
<li>可以用小圆圈表示接口</li>
</ul>
<h5 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h5><ul>
<li>接口只描述类的外不可见操作，不描述内部结构</li>
<li>接口没有属性，状态或者关联，接口只要操作</li>
<li>接口形式上等价于一个没有属性、没有方法只有抽象操作的抽象类</li>
<li>接口之间没有关联、泛化、实现、依赖，但是可以参与泛化、实现和依赖关系</li>
</ul>
<h5 id="五、协作"><a href="#五、协作" class="headerlink" title="五、协作"></a>五、协作</h5><blockquote>
<p>协作：是一组类、接口和其他元素的群体，它们共同工作以提供比个组成部分的总和更强的合作行为</p>
</blockquote>
<ul>
<li>结构部分</li>
<li>行为部分</li>
</ul>
<h5 id="六、其他重要概念"><a href="#六、其他重要概念" class="headerlink" title="六、其他重要概念"></a>六、其他重要概念</h5><p>用况</p>
<blockquote>
<p>是对一组动作序列的描述，系统执行这些动作产生对特定的参与者一个有值的、可观察的结果。</p>
</blockquote>
<p>主动类</p>
<blockquote>
<p>一种至少具有一个进程或者线程的类，因此它能够启动控制活动。</p>
</blockquote>
<p>构件</p>
<blockquote>
<p>系统逻辑的并且可替换的成分，遵循并提供了一组接口的实现</p>
</blockquote>
<p>制品</p>
<blockquote>
<p>系统中物理的、可替代的部分</p>
</blockquote>
<p>节点</p>
<blockquote>
<p>在运行时存在的物理元素，通常它表示一种具有记忆能力和处理能力的计算资源。</p>
</blockquote>
<h5 id="七、包"><a href="#七、包" class="headerlink" title="七、包"></a>七、包</h5><blockquote>
<p>为了组织类目，控制信息组织和文档组织的复杂性，UML引入了术语——包</p>
</blockquote>
<ul>
<li>表示：在大矩形中描述的内容，而把该包的名字放在左上角的小矩形中</li>
<li>依赖：访问依赖和引用依赖，是的一个包可以访问和引入其他包</li>
</ul>
<h5 id="八、表达关系术语"><a href="#八、表达关系术语" class="headerlink" title="八、表达关系术语"></a>八、表达关系术语</h5><p><em>关联</em></p>
<ul>
<li>定义：关联是类目之间的结构关系，描述了这一组具有相同结构、相同语义的链</li>
</ul>
<p><em>泛化</em></p>
<ul>
<li>定义：泛化是一般性事务和它的较为特殊种类之间的关系</li>
</ul>
<p>关于泛化需要注意的点</p>
<ul>
<li>子类可以继承父类的属性和操作，并且有更多的属性和操作</li>
<li>子类可以替换父类的声明</li>
<li>若子类的一个操作的实现覆盖了父类同一个操作的实现，这种情况被称为多态性</li>
<li>没有父类并且至少有一个子类的类被称为根类或者基类</li>
</ul>
<p><em>实现</em></p>
<ul>
<li>定义：实现是类目之间的一种语义关系，其中一个类目规约了保证另一个类目执行的契约</li>
</ul>
<p><em>依赖</em></p>
<ul>
<li>定义：依赖是一种使用关系，用于描述一个事务使用另一个事务的信息和服务</li>
</ul>
<h5 id="九、UML模型表达工具概述"><a href="#九、UML模型表达工具概述" class="headerlink" title="九、UML模型表达工具概述"></a>九、UML模型表达工具概述</h5><p>系统静态部分建模工具</p>
<ul>
<li>类图：显示类（及接口）、类的内部结构以及与其他类的关系</li>
<li>构件图</li>
<li>组合结构图</li>
<li>对象图</li>
<li>部署图</li>
<li>制品图</li>
</ul>
<p>系统动态建模工具</p>
<ul>
<li>用况图</li>
<li>状态图</li>
<li>活动图</li>
<li>顺序图</li>
<li>通信图</li>
<li>交互概观图</li>
<li>定时图</li>
</ul>
<h5 id="十、顺序图"><a href="#十、顺序图" class="headerlink" title="十、顺序图"></a>十、顺序图</h5><ul>
<li>定义：顺序图是一种交互图，即有一组对象以及这些对象之间的关系组成，其中还包含这些对象之间被发送的消息</li>
<li>内容：交互各方；交互方式——同步或者异步；交互内容——消息；</li>
<li>控制类型：选择执行；条件执行；并发执行；迭代执行</li>
</ul>
<h5 id="十一、状态图"><a href="#十一、状态图" class="headerlink" title="十一、状态图"></a>十一、状态图</h5><ul>
<li>定义：状态图示显示一个状态的图，其中强调了从一个状态到另一个状态的控制流</li>
<li>内容：简单状态和组合状态；事件；转换</li>
<li>状态分类：初态、终态、正常状态</li>
</ul>
<h3 id="第四章-面向对象"><a href="#第四章-面向对象" class="headerlink" title="第四章 面向对象"></a>第四章 面向对象</h3><h4 id="一、面向对象的分析（OOA）"><a href="#一、面向对象的分析（OOA）" class="headerlink" title="一、面向对象的分析（OOA）"></a>一、面向对象的分析（OOA）</h4><h5 id="OOA的基本任务"><a href="#OOA的基本任务" class="headerlink" title="OOA的基本任务"></a>OOA的基本任务</h5><blockquote>
<p>对问题域和系统责任进行分析和理解，对其中的事务和它们之间的关系产生正确的认识，找出描述问题域和系统责任所需的类和对象。</p>
</blockquote>
<h5 id="OOA模型"><a href="#OOA模型" class="headerlink" title="OOA模型"></a>OOA模型</h5><ul>
<li>需求模型</li>
<li>OOA模型</li>
<li>辅助模型</li>
<li>模型规约</li>
</ul>
<h4 id="二、识别类"><a href="#二、识别类" class="headerlink" title="二、识别类"></a>二、识别类</h4><ul>
<li>研究问题域和用户需求</li>
<li>策略和启发</li>
<li>审查和筛选</li>
<li>识别主动对象</li>
</ul>
<h4 id="三、识别属性和操作"><a href="#三、识别属性和操作" class="headerlink" title="三、识别属性和操作"></a>三、识别属性和操作</h4><h5 id="识别属性"><a href="#识别属性" class="headerlink" title="识别属性"></a>识别属性</h5><ul>
<li>策略和启发</li>
<li>审查和筛选</li>
<li>属性的命名：原则与类命名相同</li>
<li>属性的详细说明</li>
</ul>
<h5 id="识别操作"><a href="#识别操作" class="headerlink" title="识别操作"></a>识别操作</h5><ul>
<li>区分对象行为的类型</li>
<li>发现操作的策略和启发</li>
<li>审查和调整</li>
<li>认识对象的主动行为</li>
<li>操作的命名和定位</li>
<li>操作的详细说明</li>
</ul>
<h4 id="四、识别对象之间的关系"><a href="#四、识别对象之间的关系" class="headerlink" title="四、识别对象之间的关系"></a>四、识别对象之间的关系</h4><ul>
<li>识别继承</li>
<li>识别关联</li>
<li>识别聚合</li>
<li>识别依赖</li>
</ul>
<h4 id="五、人机交互部分的设计"><a href="#五、人机交互部分的设计" class="headerlink" title="五、人机交互部分的设计"></a>五、人机交互部分的设计</h4><h5 id="什么是人机交互部分"><a href="#什么是人机交互部分" class="headerlink" title="什么是人机交互部分"></a>什么是人机交互部分</h5><blockquote>
<p>系统中负责人机交互的部分，突出人如何命令系统以及系统如何向用户提交信息。</p>
</blockquote>
<h5 id="人机交互部分的需求分析"><a href="#人机交互部分的需求分析" class="headerlink" title="人机交互部分的需求分析"></a>人机交互部分的需求分析</h5><ul>
<li>分析与系统交互的人</li>
<li>从use case分析人机交互</li>
<li>命令的组织</li>
</ul>
<h5 id="人机界面的设计准则"><a href="#人机界面的设计准则" class="headerlink" title="人机界面的设计准则"></a>人机界面的设计准则</h5><ul>
<li>使用简单</li>
<li>一致性</li>
<li>启发性</li>
<li>减少人脑记忆的负担</li>
<li>减少重复的输入</li>
<li>容错性</li>
<li>及时反馈</li>
<li>防止灾难性地错误</li>
</ul>
<h4 id="六、控制驱动部分的设计"><a href="#六、控制驱动部分的设计" class="headerlink" title="六、控制驱动部分的设计"></a>六、控制驱动部分的设计</h4><h5 id="什么是控制驱动部分"><a href="#什么是控制驱动部分" class="headerlink" title="什么是控制驱动部分"></a>什么是控制驱动部分</h5><ul>
<li>是OOD模型的组成部分之一，该部分由系统中全部主动类构成</li>
<li>一个控制流就是一个进程或者线程</li>
</ul>
<h5 id="需要控制驱动部分的原因"><a href="#需要控制驱动部分的原因" class="headerlink" title="需要控制驱动部分的原因"></a>需要控制驱动部分的原因</h5><ul>
<li>并发行为是现实中固有的</li>
<li>当前的大量系统都是并发系统</li>
<li>多任务的设置</li>
<li>为了隔离硬件、操作系统、网络的变化对整个系统的影响</li>
</ul>
<h5 id="如何设计控制驱动部分"><a href="#如何设计控制驱动部分" class="headerlink" title="如何设计控制驱动部分"></a>如何设计控制驱动部分</h5><ul>
<li>识别控制流</li>
<li>审查与筛选</li>
<li>控制流的表示与分类</li>
</ul>
<h4 id="七、数据管理部分的设计"><a href="#七、数据管理部分的设计" class="headerlink" title="七、数据管理部分的设计"></a>七、数据管理部分的设计</h4><h5 id="什么是数据管理部分"><a href="#什么是数据管理部分" class="headerlink" title="什么是数据管理部分"></a>什么是数据管理部分</h5><blockquote>
<p>数据管理部分OOD模型模型中负责与具体的数据管理系统衔接的外围组成部分，它的系统中需要长久存储的对象提供了在选定的数据管理系统中进行数据存储与恢复的功能</p>
</blockquote>
<h5 id="如何设计数据管理部分"><a href="#如何设计数据管理部分" class="headerlink" title="如何设计数据管理部分"></a>如何设计数据管理部分</h5><ul>
<li>选择数据管理系统</li>
<li>数据存放设计</li>
</ul>
<h4 id="八、面向对象设计概述"><a href="#八、面向对象设计概述" class="headerlink" title="八、面向对象设计概述"></a>八、面向对象设计概述</h4><h5 id="OOD的根本目标"><a href="#OOD的根本目标" class="headerlink" title="OOD的根本目标"></a>OOD的根本目标</h5><ul>
<li>提高软件生产率</li>
<li>提高质量</li>
<li>加强可维护性</li>
</ul>
<h5 id="OOP和OOD的关系"><a href="#OOP和OOD的关系" class="headerlink" title="OOP和OOD的关系"></a>OOP和OOD的关系</h5><ul>
<li>从OOA到OOD不是转化、不是细化，是调整和整补</li>
<li>OOD运用与OOA部分相同的概念</li>
<li>OOD采用与OOA一致的表示方法</li>
</ul>
<h4 id="九、如何进行问题域部分的设计"><a href="#九、如何进行问题域部分的设计" class="headerlink" title="九、如何进行问题域部分的设计"></a>九、如何进行问题域部分的设计</h4><ul>
<li>为复用设计与编程的类而增加结构</li>
<li>增加一般类以建立共同协议</li>
<li>按编程语言调整继承和多态</li>
<li>提高性能</li>
<li>为实现对象永久存储所做的修改</li>
<li>为编程方便增加底层细节</li>
</ul>
<h4 id="十、面向对象的编程和编程语言"><a href="#十、面向对象的编程和编程语言" class="headerlink" title="十、面向对象的编程和编程语言"></a>十、面向对象的编程和编程语言</h4><h5 id="程序设计范型"><a href="#程序设计范型" class="headerlink" title="程序设计范型"></a>程序设计范型</h5><ul>
<li>过程化编程</li>
<li>面向对象编程</li>
<li>指令式编程</li>
</ul>
<h5 id="面向对象是一种新的程序设计范型"><a href="#面向对象是一种新的程序设计范型" class="headerlink" title="面向对象是一种新的程序设计范型"></a>面向对象是一种新的程序设计范型</h5><ul>
<li>思想方法：从客观存在的事务出发构造软件系统，运用人类日常的思维方式</li>
<li>主要特点：使用对象、类、继承、封装、聚合、关联、消息、多态性等基本概念来进行程序设计</li>
</ul>
<h5 id="选择编程语言"><a href="#选择编程语言" class="headerlink" title="选择编程语言"></a>选择编程语言</h5><blockquote>
<p>C++是一种在C语言基础上扩充OO成分，对封装采取灵活策略的语言，所以属于混合型面向对象语言。</p>
</blockquote>
<ul>
<li>基本原则——主要考虑成本、进度、效率等实际因素</li>
<li>OOPL是实现OOD的理想语言</li>
<li>带有类库、编程环境、权限管理的OOPL更好</li>
</ul>
<h3 id="第五章-敏捷开发"><a href="#第五章-敏捷开发" class="headerlink" title="第五章 敏捷开发"></a>第五章 敏捷开发</h3><h4 id="一、敏捷开发简介"><a href="#一、敏捷开发简介" class="headerlink" title="一、敏捷开发简介"></a>一、敏捷开发简介</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><blockquote>
<p>是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速需求变化的一种软件开发能力。</p>
</blockquote>
<h5 id="原则（部分）"><a href="#原则（部分）" class="headerlink" title="原则（部分）"></a>原则（部分）</h5><ul>
<li>最优先要做的是：通过尽早地、持续地交付有价值的软件来使客户满意</li>
<li>及时到了开发后期，也要欢迎需求改变</li>
<li>经常交互可工作的软件，其时间间隔可以是几周到几个月</li>
</ul>
<h4 id="二、极限编程"><a href="#二、极限编程" class="headerlink" title="二、极限编程"></a>二、极限编程</h4><h5 id="实践原则"><a href="#实践原则" class="headerlink" title="实践原则"></a>实践原则</h5><ul>
<li>客户作为团队的成员</li>
<li>“用户素材”</li>
<li>短的交互期</li>
<li>验收测试</li>
<li>结对编程</li>
<li>测试驱动开发</li>
<li>集体所有权</li>
<li>持续集成</li>
</ul>
<h5 id="极限编程的过程"><a href="#极限编程的过程" class="headerlink" title="极限编程的过程"></a>极限编程的过程</h5><ul>
<li>策划：用户故事；权值；迭代计划</li>
<li>设计：Spike解决方案</li>
<li>编码：重构</li>
<li>测试：验收测试；单元测试</li>
<li>发布：软件增量；项目速度估算</li>
</ul>
<h4 id="三、敏捷设计"><a href="#三、敏捷设计" class="headerlink" title="三、敏捷设计"></a>三、敏捷设计</h4><h5 id="设计应该避免的问题"><a href="#设计应该避免的问题" class="headerlink" title="设计应该避免的问题"></a>设计应该避免的问题</h5><ul>
<li>僵化性</li>
<li>脆弱性</li>
<li>粘固性——设计难于复用</li>
<li>粘滞性</li>
<li>不必要的复杂性</li>
<li>不必要的复制</li>
<li>晦涩性</li>
</ul>
<h5 id="防止软件腐化的基本途径"><a href="#防止软件腐化的基本途径" class="headerlink" title="防止软件腐化的基本途径"></a>防止软件腐化的基本途径</h5><ul>
<li>几乎不进行预先设计，不需要成熟的初始设计</li>
<li>多次使用单元测试和验收测试</li>
<li>灵活和持续的改进</li>
</ul>
<h4 id="四、SCRUM模型"><a href="#四、SCRUM模型" class="headerlink" title="四、SCRUM模型"></a>四、SCRUM模型</h4><h5 id="Scrum的三个阶段"><a href="#Scrum的三个阶段" class="headerlink" title="Scrum的三个阶段"></a>Scrum的三个阶段</h5><ul>
<li>规划纲要阶段</li>
<li>一系类冲刺循环</li>
<li>项目结束阶段总结项目，完善需要的文档</li>
</ul>
<h5 id="Scrum过程流"><a href="#Scrum过程流" class="headerlink" title="Scrum过程流"></a>Scrum过程流</h5><ul>
<li>待定项</li>
<li>冲刺</li>
<li>演示</li>
</ul>
<h3 id="第六章-软件测试"><a href="#第六章-软件测试" class="headerlink" title="第六章 软件测试"></a>第六章 软件测试</h3><h4 id="一、软件测试的概念"><a href="#一、软件测试的概念" class="headerlink" title="一、软件测试的概念"></a>一、软件测试的概念</h4><h5 id="软件测试的定义和目标"><a href="#软件测试的定义和目标" class="headerlink" title="软件测试的定义和目标"></a>软件测试的定义和目标</h5><blockquote>
<p>监测和评价软件以确定其质量的过程和方法</p>
</blockquote>
<blockquote>
<p>分类：静态测试；动态测试（黑盒测试，白盒测试）</p>
</blockquote>
<h5 id="软件测试的目标"><a href="#软件测试的目标" class="headerlink" title="软件测试的目标"></a>软件测试的目标</h5><ul>
<li>预防错误</li>
<li>发现错误</li>
</ul>
<h4 id="二、软件测试的过程模型和原则"><a href="#二、软件测试的过程模型和原则" class="headerlink" title="二、软件测试的过程模型和原则"></a>二、软件测试的过程模型和原则</h4><h5 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h5><ul>
<li>环境</li>
<li>被测对象模型</li>
<li>错误模型</li>
</ul>
<h5 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h5><ul>
<li>所有的测试都应当追溯到用户需求</li>
<li>在测试共走开始前，要进行测试计划的设计</li>
<li>测试应从小规模开始，逐步转向大规模</li>
<li>穷举测试是不可能的</li>
<li>为了尽可能发现错误，应由独立的第三方来测试</li>
<li>测试只能尽可能多地发现错误，无法保证发现所有的错误</li>
</ul>
<h4 id="三、白盒测试"><a href="#三、白盒测试" class="headerlink" title="三、白盒测试"></a>三、白盒测试</h4><h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><blockquote>
<p>白盒测试也称结构测试或者逻辑驱动测试，它是知道产品内部工作过程，可通过测试来检测产品内部动作是否按照规格说明书的规定正常运行</p>
</blockquote>
<h5 id="各种测试"><a href="#各种测试" class="headerlink" title="各种测试"></a>各种测试</h5><ul>
<li>路径测试：执行所有额能的穿过程序的控制流程路径，策略是最强的，但是一般不可实现</li>
<li>语句测试：至少执行程序中所有语句一次</li>
<li>分支测试：至少执行程序中每一分支一次</li>
<li>条件组合测试：设计足够多的测试用例，是每个判定中所有可能条件取值至少执行一次</li>
<li>循环测试：关键路径选取</li>
</ul>
<h4 id="四、黑盒测试"><a href="#四、黑盒测试" class="headerlink" title="四、黑盒测试"></a>四、黑盒测试</h4><h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h5><blockquote>
<p>黑盒写实也称功能测试或数据驱动测试，它是在已知产品所有具有的功能，通过测试来检测每个功能是否能正常使用</p>
</blockquote>
<h5 id="黑盒测试试图发现以下错误类型"><a href="#黑盒测试试图发现以下错误类型" class="headerlink" title="黑盒测试试图发现以下错误类型"></a>黑盒测试试图发现以下错误类型</h5><ul>
<li>功能不对或遗漏</li>
<li>界面错误</li>
<li>数据结构或者外部数据访问的错误</li>
<li>性能错误</li>
<li>初始化和终止错误</li>
</ul>
<h5 id="事务流测试"><a href="#事务流测试" class="headerlink" title="事务流测试"></a>事务流测试</h5><blockquote>
<p>事务：以用户的角度所见的一个工作单元</p>
</blockquote>
<p>测试步骤</p>
<ul>
<li>获取事务流程图</li>
<li>浏览和复审</li>
<li>用例设计</li>
<li>测试设备开发</li>
<li>测试执行</li>
<li>测试结果比较</li>
</ul>
<h5 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h5><blockquote>
<p>定义：输入域的一个子集，在该子集中，各个输入数据对于揭示程序中的错误都是等效的</p>
</blockquote>
<blockquote>
<p>分类：有效等价类；无效等价类</p>
</blockquote>
<h5 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h5><blockquote>
<p>边界值分析是一种罪常用的黑盒测试技术。通过设计一些测试用例，使程序运行在边界情况附近，这样揭露错误的可能性比较大。</p>
</blockquote>
<h4 id="五、软件测试步骤"><a href="#五、软件测试步骤" class="headerlink" title="五、软件测试步骤"></a>五、软件测试步骤</h4><h5 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h5><ul>
<li>单元测试——往往采用白盒测试，在单元测试中由被测模块调用，用以代替被测模块所调用的子模块被称为桩模块</li>
<li>集成测试——集中于模块的组装</li>
<li>确认测试——通常采用黑盒测试</li>
<li>系统测试——检测整个系统的性能、功能是否达到；功能测试、恢复测试、安全性测试、强度测试、性能测试、可用性测试、部署测试</li>
</ul>
<h3 id="第七章-项目管理"><a href="#第七章-项目管理" class="headerlink" title="第七章 项目管理"></a>第七章 项目管理</h3><h4 id="一、软件项目管理简介"><a href="#一、软件项目管理简介" class="headerlink" title="一、软件项目管理简介"></a>一、软件项目管理简介</h4><h5 id="项目定义"><a href="#项目定义" class="headerlink" title="项目定义"></a>项目定义</h5><blockquote>
<p>为创造一件独特的产品、一项服务或者一种结果而进行的临时性努力</p>
</blockquote>
<h5 id="项目管理发展的产物是"><a href="#项目管理发展的产物是" class="headerlink" title="项目管理发展的产物是"></a>项目管理发展的产物是</h5><ul>
<li>项目管理协会</li>
<li>项目管理知识体系</li>
<li>人才认证</li>
</ul>
<h4 id="二、项目管理框架和要素"><a href="#二、项目管理框架和要素" class="headerlink" title="二、项目管理框架和要素"></a>二、项目管理框架和要素</h4><h5 id="框架图"><a href="#框架图" class="headerlink" title="框架图"></a>框架图</h5><blockquote>
<p>关键要素为项目干系人、项目管理知识领域以及项目管理工具和技术</p>
</blockquote>
<h4 id="项目干系人"><a href="#项目干系人" class="headerlink" title="项目干系人"></a>项目干系人</h4><ul>
<li>项目经理</li>
<li>客户</li>
<li>项目执行组织</li>
<li>项目团队及发起人</li>
<li>项目赞助者、发起人</li>
<li>项目竞争对手</li>
</ul>
<h4 id="九大知识领域"><a href="#九大知识领域" class="headerlink" title="九大知识领域"></a>九大知识领域</h4><ul>
<li>项目管理的四大核心知识领域是指范围、时间、成本和质量</li>
<li>四大项目管理辅助知识领域包括人力资源管理、风险管理、沟通管理、采购管理</li>
</ul>
<h4 id="项目管理工具和技术"><a href="#项目管理工具和技术" class="headerlink" title="项目管理工具和技术"></a>项目管理工具和技术</h4><ul>
<li>WBS</li>
<li>甘特图</li>
<li>网络图示法</li>
<li>净值图</li>
<li>关键路径法</li>
</ul>
<h4 id="项目管理要素"><a href="#项目管理要素" class="headerlink" title="项目管理要素"></a>项目管理要素</h4><ul>
<li>范围</li>
<li>进度</li>
<li>成本</li>
<li>质量</li>
</ul>
<h4 id="三、软件项目管理的概念"><a href="#三、软件项目管理的概念" class="headerlink" title="三、软件项目管理的概念"></a>三、软件项目管理的概念</h4><h5 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h5><blockquote>
<p>软件管理是为了是软件项目能够按照预定的成本、进度、质量顺利完成，而对成本、人员、进度、质量、风险等进行分析和管理的活动。</p>
</blockquote>
<h5 id="项目管理过程"><a href="#项目管理过程" class="headerlink" title="项目管理过程"></a>项目管理过程</h5><ul>
<li>启动过程</li>
<li>计划过程</li>
<li>执行过程</li>
<li>监督和控制过程</li>
<li>收尾过程</li>
</ul>
<h3 id="第八章-CMM"><a href="#第八章-CMM" class="headerlink" title="第八章 CMM"></a>第八章 CMM</h3><p>软件质量三要素：人员、技术、过程</p>
<h4 id="一、CMM概念及发展"><a href="#一、CMM概念及发展" class="headerlink" title="一、CMM概念及发展"></a>一、CMM概念及发展</h4><h5 id="CMM是什么"><a href="#CMM是什么" class="headerlink" title="CMM是什么"></a>CMM是什么</h5><blockquote>
<p>一般指软件能力成熟度模型。</p>
</blockquote>
<h4 id="CMM族"><a href="#CMM族" class="headerlink" title="CMM族"></a>CMM族</h4><ul>
<li>SW-CMM</li>
<li>SE-CMM</li>
<li>SA-CMM</li>
<li>IPD-CMM</li>
<li>P-CMM</li>
</ul>
<h4 id="二、CMM的基本内容"><a href="#二、CMM的基本内容" class="headerlink" title="二、CMM的基本内容"></a>二、CMM的基本内容</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul>
<li>过程和过程能力</li>
<li>过程性能</li>
<li>过程成熟度和组织成熟度</li>
<li>能力成熟度等级</li>
</ul>
<h4 id="三、CMM五级标准"><a href="#三、CMM五级标准" class="headerlink" title="三、CMM五级标准"></a>三、CMM五级标准</h4><h5 id="五级框架"><a href="#五级框架" class="headerlink" title="五级框架"></a>五级框架</h5><ul>
<li>初始级</li>
<li>可重复级</li>
<li>已定义级</li>
<li>已管理级</li>
<li>持续优化级</li>
</ul>
<h4 id="四、ISO-9000"><a href="#四、ISO-9000" class="headerlink" title="四、ISO 9000"></a>四、ISO 9000</h4><h5 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h5><blockquote>
<p>ISO 9000 是一个用于在所有行业建立质量管理体系的国际标准</p>
</blockquote>
<h5 id="ISO-9001核心过程"><a href="#ISO-9001核心过程" class="headerlink" title="ISO 9001核心过程"></a>ISO 9001核心过程</h5><ul>
<li>业务获取</li>
<li>设计和开发</li>
<li>测试</li>
<li>生产和交付</li>
<li>服务和支持</li>
<li>业务管理</li>
<li>供应商管理</li>
<li>库存管理</li>
<li>配置管理</li>
</ul>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核完全注释</title>
    <url>/2020/07/15/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/07/15/UaxEWQ.md.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">万家灯火</div>
</center>


<blockquote>
<p>此文为学习《Linux内核完全注释》所做的笔记</p>
</blockquote>
<a id="more"></a>

<h3 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h3><h4 id="一、如何选择阅读内核代码版本"><a href="#一、如何选择阅读内核代码版本" class="headerlink" title="一、如何选择阅读内核代码版本"></a>一、如何选择阅读内核代码版本</h4><ul>
<li>2.6.0版内核代码行数约592行，极其庞大</li>
<li>0.11版内核不超过2万行代码量，麻雀虽小，五张俱全</li>
</ul>
<p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A/QQ20200715-091523@2x.png" alt></p>
<h4 id="二、Linux的诞生和发展"><a href="#二、Linux的诞生和发展" class="headerlink" title="二、Linux的诞生和发展"></a>二、Linux的诞生和发展</h4><h5 id="1-五个重要的支柱"><a href="#1-五个重要的支柱" class="headerlink" title="1.五个重要的支柱"></a>1.五个重要的支柱</h5><ul>
<li>Unix操作系统:1969年诞生在Bell实验室</li>
<li>MINIX操作系统</li>
<li>GNU计划：旨在开发一个类似于UNIX并且自有免费的完全操作系统</li>
<li>POSIX标准（该标准是基于Unix实践和标准，描述了操作系统的调用服务接口，是Linux前进的灯塔）和Internet网络</li>
</ul>
<h5 id="2-Linux的版本变迁"><a href="#2-Linux的版本变迁" class="headerlink" title="2.Linux的版本变迁"></a>2.Linux的版本变迁</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A/QQ20200715-092504@2x.png" alt><br><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A/QQ20200715-092656@2x.png" alt></p>
<h3 id="第二章-微型计算机组成结构"><a href="#第二章-微型计算机组成结构" class="headerlink" title="第二章 微型计算机组成结构"></a>第二章 微型计算机组成结构</h3><h4 id="一、I-O端口和寻址"><a href="#一、I-O端口和寻址" class="headerlink" title="一、I/O端口和寻址"></a>一、I/O端口和寻址</h4><ul>
<li>端口地址的设置方法一般有两种：统一编址和独立编址</li>
<li>统一编址：原理是把I/O控制器中的端口地址归入存储器寻址空间范围内</li>
<li>独立编址：采用一个独立的I/O地址空间对沈北中的寄存器进行寻址和访问</li>
</ul>
<h4 id="二、接口访问控制"><a href="#二、接口访问控制" class="headerlink" title="二、接口访问控制"></a>二、接口访问控制</h4><ul>
<li>程序循环查询方式：指通过CPU在程序循环查询指定设备控制器中的状态来判断是否可以与设备进行数据交换</li>
<li>中断处理方式：I/O设备通过中断向CPU提出请求时，CPU才会暂时中断当前执行的程序转而执行相应的I/O中断处理服务过程。Linux中大多数设备I/O控制都采用中断处理方式</li>
<li>DMA传输方式：用于I/O设备与系统内存之间进行批量数据传送，整个操作过程需要专门的DMA控制器进行而无需CPU插手</li>
</ul>
<h3 id="第三章-内核编程语言和环境"><a href="#第三章-内核编程语言和环境" class="headerlink" title="第三章 内核编程语言和环境"></a>第三章 内核编程语言和环境</h3><h4 id="一、阅读boot-s"><a href="#一、阅读boot-s" class="headerlink" title="一、阅读boot.s"></a>一、阅读boot.s</h4><ul>
<li>.globl是汇编指示符，在编译时不会产生任何代码</li>
<li>.text——正文段、.data——用于标识数据段的开始位置、.bss段——用于标识一个未初始化数据段的开始</li>
<li>立即数前一定要加“#”，否则将作为内存地址使用</li>
</ul>
<h4 id="二、AT-amp-T语法和Intel汇编语法的区别"><a href="#二、AT-amp-T语法和Intel汇编语法的区别" class="headerlink" title="二、AT&amp;T语法和Intel汇编语法的区别"></a>二、AT&amp;T语法和Intel汇编语法的区别</h4><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A/QQ20200715-111246@2x.png" alt></p>
<h4 id="三、内联函数"><a href="#三、内联函数" class="headerlink" title="三、内联函数"></a>三、内联函数</h4><ul>
<li>内联函数让gcc把函数的代码集成到调用该函数的代码中去</li>
<li>可以去掉函数调用时进入、退出的时间开销</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核分析与应用</title>
    <url>/2020/07/02/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/07/02/Nb2m3F.png">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">她</div>
</center>

<blockquote>
<p>此文为学习Linux内核所做的笔记</p>
</blockquote>
<a id="more"></a>

<h3 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h3><h4 id="一、Linux操作系统概述"><a href="#一、Linux操作系统概述" class="headerlink" title="一、Linux操作系统概述"></a>一、Linux操作系统概述</h4><h5 id="1-Linux系统整体结构"><a href="#1-Linux系统整体结构" class="headerlink" title="1.Linux系统整体结构"></a>1.Linux系统整体结构</h5><ul>
<li>应用软件</li>
<li>系统调用</li>
<li>内核：进程间通信、进程调度、网络、内存管理、文件系统</li>
<li>模块</li>
<li>硬件</li>
</ul>
<h5 id="2-机制与策略分离"><a href="#2-机制与策略分离" class="headerlink" title="2.机制与策略分离"></a>2.机制与策略分离</h5><ul>
<li>机制——提供什么样的功能</li>
<li>策略——如何使用这些功能</li>
</ul>
<h4 id="二、Linux的内核结构及内核模块"><a href="#二、Linux的内核结构及内核模块" class="headerlink" title="二、Linux的内核结构及内核模块"></a>二、Linux的内核结构及内核模块</h4><h5 id="1-Linux内核源码目录"><a href="#1-Linux内核源码目录" class="headerlink" title="1.Linux内核源码目录"></a>1.Linux内核源码目录</h5><p><img src="/images/loading/loading.gif" data-original="././Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200702-152213@2x.png" alt></p>
<h5 id="2-Linux内核模块编程入门"><a href="#2-Linux内核模块编程入门" class="headerlink" title="2.Linux内核模块编程入门"></a>2.Linux内核模块编程入门</h5><ul>
<li>任何模块都要包含三个头文件：&lt;linux/module.h&gt;、&lt;linux/kernel.h&gt;、&lt;linux/init.h&gt;</li>
<li>&lt;linux/module.h&gt;:包含了对模块版本控制</li>
<li>&lt;linux/kernel.h&gt;:包含了常用的内核函数</li>
<li>&lt;linux/init.h&gt;:包含了_init和_exit，宏_init告诉编译程序相关的函数和变量仅用于初始化，编译程序将标有_init的所有代码存储到特殊的内存段中，初始化结束就释放这段内存</li>
<li>入口函数：module_init()</li>
<li>出口函数：module_cleanup()</li>
</ul>
<h5 id="3-相关命令"><a href="#3-相关命令" class="headerlink" title="3.相关命令"></a>3.相关命令</h5><ul>
<li>插入模块：insmod modele_example.ko</li>
<li>删除模块：rmmod modele_example.ko</li>
<li>查看模块信息：dmesg </li>
<li>调试：kdbug、kdb、kgdb</li>
</ul>
<h4 id="三、内核源码入门"><a href="#三、内核源码入门" class="headerlink" title="三、内核源码入门"></a>三、内核源码入门</h4><h5 id="1-链表的演化"><a href="#1-链表的演化" class="headerlink" title="1.链表的演化"></a>1.链表的演化</h5><ul>
<li>如果减少一个指针域，就退化成单链表</li>
<li>如果只能对链表的首尾进行插入或删除操作，就演变为队结<br>构</li>
<li>如果只能对链表的头进行插入或删除操作，就退化为栈结构</li>
<li>如果前驱和后继表示左右孩子，则演变为一颗二叉树</li>
</ul>
<h4 id="2-Linux内核中链表的定义和使用"><a href="#2-Linux内核中链表的定义和使用" class="headerlink" title="2.Linux内核中链表的定义和使用"></a>2.Linux内核中链表的定义和使用</h4><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200702-153709@2x.png" alt></p>
<h3 id="第二章-内存寻址"><a href="#第二章-内存寻址" class="headerlink" title="第二章 内存寻址"></a>第二章 内存寻址</h3><h4 id="一、内存寻址概述"><a href="#一、内存寻址概述" class="headerlink" title="一、内存寻址概述"></a>一、内存寻址概述</h4><h5 id="1-图灵机和冯-诺依曼体系结构"><a href="#1-图灵机和冯-诺依曼体系结构" class="headerlink" title="1.图灵机和冯.诺依曼体系结构"></a>1.图灵机和冯.诺依曼体系结构</h5><ul>
<li>冯诺依曼结构——IntelX86，AMD</li>
<li>哈佛结构——ARM</li>
</ul>
<h5 id="2-X86内存寻址的不同时期"><a href="#2-X86内存寻址的不同时期" class="headerlink" title="2.X86内存寻址的不同时期"></a>2.X86内存寻址的不同时期</h5><ul>
<li>8位：没有段的概念，访问内存都要通过绝对地址，因此程序中的地址必须进行硬编码、（也就是给出具体地址），而且也难以重定位。</li>
<li>16位：“段”的引入，段描述了一块有限的内存区域，区域的起始位置存在专门的寄存器（也就是段寄存器中）。</li>
<li>24位：286地址总线位数增加到了24位；从此开始引进了一个全新理念—保护模式；访问内存时不能直接从段寄存器中获得段的起始地址了，而需要经过额外转换和检查 。</li>
<li>32位或64位：386是一个32位的CPU，其寻址能力达到4GB，把80386以后的处理器统称为x86</li>
</ul>
<h5 id="3-为什么引入保护模式？"><a href="#3-为什么引入保护模式？" class="headerlink" title="3.为什么引入保护模式？"></a>3.为什么引入保护模式？</h5><blockquote>
<p>从物理上来看，应该是保护存储器，从逻辑上来看，保护的是操作系统。正式因为实模式的分段机制可以让内存被随意修改，操作系统得不到保护，所以出现了保护模式。</p>
</blockquote>
<h4 id="二、保护模式之段机制"><a href="#二、保护模式之段机制" class="headerlink" title="二、保护模式之段机制"></a>二、保护模式之段机制</h4><h5 id="1-程序的编译过程"><a href="#1-程序的编译过程" class="headerlink" title="1.程序的编译过程"></a>1.程序的编译过程</h5><p>编译（GCC）-&gt;汇编（GAS）-&gt;链接（ld）-&gt;装载并执行</p>
<h5 id="2-保护模式下的寻址"><a href="#2-保护模式下的寻址" class="headerlink" title="2.保护模式下的寻址"></a>2.保护模式下的寻址</h5><ul>
<li>CPU把虚地址送给MMU</li>
<li>MMU把物理地址送给存储器</li>
</ul>
<h5 id="3-MMU的地址转换"><a href="#3-MMU的地址转换" class="headerlink" title="3.MMU的地址转换"></a>3.MMU的地址转换</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200702-162916@2x.png" alt></p>
<h5 id="4-段描述符表——段表"><a href="#4-段描述符表——段表" class="headerlink" title="4.段描述符表——段表"></a>4.段描述符表——段表</h5><ul>
<li>组成：段号、基地址、界限、属性</li>
<li>段号描述虚拟地址空间段的编号</li>
<li>基地址是线性地址空间段的起始地址</li>
<li>段描述符表中的每一个表项叫做段描述符</li>
</ul>
<h5 id="5-保护模式下段寄存器中存放什么"><a href="#5-保护模式下段寄存器中存放什么" class="headerlink" title="5.保护模式下段寄存器中存放什么"></a>5.保护模式下段寄存器中存放什么</h5><ul>
<li>存放索引或叫段号，因此，这里的段寄存器也叫选择符，即从描述符表中选择某个段。</li>
<li>RPL表示请求者的特权级（Requestor Privilege Level） </li>
<li>TI（Table Index）</li>
</ul>
<h5 id="6-保护模式下的特权级"><a href="#6-保护模式下的特权级" class="headerlink" title="6.保护模式下的特权级"></a>6.保护模式下的特权级</h5><ul>
<li>保护模式提供了四个特权级，用0~3四个数字表示</li>
<li>很多操作系统（包括Linux,Windwos）只使用了其中的最低和最高两个，即0表示最高特权级，对应内核态；3表示最低特权级，对应用户态。</li>
<li>保护模式规定，高特权级可以访问低特权级，而低特权级不能随便访问高特权级。</li>
</ul>
<h5 id="7-保护模式下的描述符"><a href="#7-保护模式下的描述符" class="headerlink" title="7.保护模式下的描述符"></a>7.保护模式下的描述符</h5><ul>
<li>全局描述符表GDT（Gloabal Descriptor Table） </li>
<li>中断描述符表IDT（Interrupt Descriptor Table） </li>
<li>局部描述符表LDT（Local Descriptor Table）</li>
</ul>
<h4 id="三、分页机制"><a href="#三、分页机制" class="headerlink" title="三、分页机制"></a>三、分页机制</h4><h5 id="1-分页机制中的页"><a href="#1-分页机制中的页" class="headerlink" title="1.分页机制中的页"></a>1.分页机制中的页</h5><ul>
<li>所谓分页，就是将虚拟地址空间或线性地址空间划分成若干大小相等的片，称为页（Page） </li>
<li>对物理地址空间分成与页大小相等的存储块，称为块或页面（Page Frame）</li>
<li>IA-32页的大小: 4KB, 2MB 和4MB</li>
<li>IA-64页的大小: 4KB, 8KB, 64KB, 256KB, 1MB, 4MB, 16MB 和256MB.</li>
</ul>
<h5 id="2-分页原理是什么"><a href="#2-分页原理是什么" class="headerlink" title="2.分页原理是什么"></a>2.分页原理是什么</h5><ul>
<li>使得每个进程可以拥有自己独立的虚拟内存空间。为了达到这个目的，CPU在访存的时候就需要进行一次地址变换，也就是把虚地址转换为物理地址，于是我们给出映射函数： Pa=f(va)，这种转换在时间和空间上都要付出代价，因此必须进行优化。</li>
<li>时间的优化。因为访存很频繁，因此，映射函数f一定要简单，否则会效率很低，所以需要简单查表算法，这也就是页表引入的原因。 </li>
<li>空间的优化。因为内存空间是按字节编址的，地址一一进行映射的话，效率也很低，于是要按照一定的粒度（也就是页）进行映射，这样，粒度内的相对地址（也就是页内偏移量）在映射时保持不变。</li>
</ul>
<h5 id="3-页表"><a href="#3-页表" class="headerlink" title="3.页表"></a>3.页表</h5><ul>
<li>页表是一种映射机制，存放的是虚拟地址空间与物理空间地址空间的映射关系</li>
<li>页号对应块号</li>
</ul>
<h5 id="4-单级页表结构"><a href="#4-单级页表结构" class="headerlink" title="4.单级页表结构"></a>4.单级页表结构</h5><ul>
<li>在32位的地址空间，通常页的大小为4KB</li>
<li>每页起始地址的低12位表示页的属性</li>
<li>每页的高20位表示页的起始地址</li>
</ul>
<h5 id="5-两级页表"><a href="#5-两级页表" class="headerlink" title="5.两级页表"></a>5.两级页表</h5><ul>
<li>如果只用以及页表，因为每个页表最大可占4MB的空间，而且必须是连续的，这就为内存的分配带来困难</li>
<li>采用分而治之的原则，将高20位分为两部分，分别占十位，形成两级页表</li>
</ul>
<h5 id="6-地址转换过程"><a href="#6-地址转换过程" class="headerlink" title="6.地址转换过程"></a>6.地址转换过程</h5><ul>
<li>第一步，用最高10位作为页目录项的索引，将它乘以4，与CR3中的页目录的起始地址相加，获得相应目录项在内存的地址。</li>
<li>第二步，从这个地址开始读取32位页目录项，取出其高20位，再给低12位补0，形成页表在内存的起始地址。</li>
<li>第三步，用中间的10位作为页表中页表项的索引，将它乘以4，与页表的起始地址相加，获得相应页表项在内存的地址。</li>
<li>第四步，从这个地址开始读取32位页表项，取出其高20位，再将线性地址的第11~0位放在低12位，形成最终32位页面物理地址。</li>
</ul>
<p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200703-092339@2x.png" alt></p>
<h5 id="7-页面高速缓存"><a href="#7-页面高速缓存" class="headerlink" title="7.页面高速缓存"></a>7.页面高速缓存</h5><ul>
<li>页表放在内存中，这使得CPU在每次存取一个数据时，都要至少两次访问，从而大大降低了访问的速度</li>
<li>引入TLB，在访问某个地址空间时，先访问高速缓存区，如果未命中，再访问内存</li>
</ul>
<h4 id="8-Linux中的分页"><a href="#8-Linux中的分页" class="headerlink" title="8.Linux中的分页"></a>8.Linux中的分页</h4><ul>
<li>Linux主要采用分页机制来实现虚拟存储器管理</li>
<li>页总目录PGD（Page Global Directory） </li>
<li>页上级目录PUD（Page Upper Directory） </li>
<li>页中间目录PMD（Page Middle Derectory） </li>
<li>页表PT（Page table）</li>
</ul>
<h3 id="三、进程管理"><a href="#三、进程管理" class="headerlink" title="三、进程管理"></a>三、进程管理</h3><h4 id="一、进程概述"><a href="#一、进程概述" class="headerlink" title="一、进程概述"></a>一、进程概述</h4><h5 id="1-进程家族"><a href="#1-进程家族" class="headerlink" title="1.进程家族"></a>1.进程家族</h5><ul>
<li>进程是一个动态的实体，它具有生命周期</li>
<li>在Linux中，通过调用fork系统调用来创建一个新的进程</li>
<li>Linux系统启动以后形成了一棵树</li>
<li>swaspper init_task -&gt; init -&gt; login -&gt; bash -&gt; insmod</li>
</ul>
<h5 id="2-进程控制块－信息分类"><a href="#2-进程控制块－信息分类" class="headerlink" title="2.进程控制块－信息分类"></a>2.进程控制块－信息分类</h5><ul>
<li>状态信息－描述进程动态的变化。</li>
<li>链接信息－描述进程的父／子关系。</li>
<li>各种标识符－用简单数字对进程进行标识。</li>
<li>进程间通信信息－描述多个进程在同一任务上协作工作。</li>
<li>时间和定时器信息－描述进程在生存周期内使用CPU时间的统计、计费等信息。</li>
<li>调度信息－描述进程优先级、调度策略等信息。</li>
<li>文件系统信息－对进程使用文件情况进行记录。</li>
<li>虚拟内存信息－描述每个进程拥有的地址空间。</li>
<li>处理器环境信息－描述进程的执行环境(处理器的寄存器及堆栈等)</li>
</ul>
<h5 id="3-进程控制块——Linux进程状态及转换"><a href="#3-进程控制块——Linux进程状态及转换" class="headerlink" title="3.进程控制块——Linux进程状态及转换"></a>3.进程控制块——Linux进程状态及转换</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200703-100956@2x.png" alt></p>
<h5 id="4-进程控制快——如何存放"><a href="#4-进程控制快——如何存放" class="headerlink" title="4.进程控制快——如何存放"></a>4.进程控制快——如何存放</h5><ul>
<li>进程的PCB所占的内存是由内核动态分配的，更确切地说，内核根本不给PCB分配内存，而仅仅给内核栈分配8K的内存，并把其中的一部分让给PCB使用。</li>
<li>随着Linux版本的变化，进程控制块的内容越来越多，因此把部分进程控制块的内容移出这个空间，只保留访问频繁的thread_info。</li>
</ul>
<h5 id="5-从进程到容器"><a href="#5-从进程到容器" class="headerlink" title="5.从进程到容器"></a>5.从进程到容器</h5><ul>
<li>对于进程来说，它的静态表现就是程序，平常都安安静静地待在磁盘上；而一旦运行起来，它就变成了计算机里的数据和状态的总和，这就是它的动态表现。</li>
<li>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。</li>
</ul>
<h4 id="二、进程的调度"><a href="#二、进程的调度" class="headerlink" title="二、进程的调度"></a>二、进程的调度</h4><h5 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h5><ul>
<li>进程是系统资源分配的基本单位，线程是独立运行的基本单位。</li>
<li>进程和线程几乎共享所有的资源，包括代码，数据，进程空间，打开的文件等</li>
<li>线程只拥有自己的寄存器和栈。</li>
</ul>
<h5 id="2-进程的API实现"><a href="#2-进程的API实现" class="headerlink" title="2.进程的API实现"></a>2.进程的API实现</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200703-104555@2x.png" alt></p>
<h5 id="3-fork的实现"><a href="#3-fork的实现" class="headerlink" title="3.fork的实现"></a>3.fork的实现</h5><ul>
<li>fork调用的do_fork，除了SIGCHLD参数外，有三个参数就是空手而来，有两个参数似乎也没有明确的目标。</li>
<li>作为子进程，它完全有自己的个性的，根本不想共享父进程的任何资源，而是让父亲把他所有资源给自己复制一份</li>
<li>老爸没有那么傻，而是假装复制了一下，也就是用一个指针指过去而已</li>
<li>要写一个页面时，写时复制技术就登场了</li>
</ul>
<h5 id="4-vfork的实现"><a href="#4-vfork的实现" class="headerlink" title="4.vfork的实现"></a>4.vfork的实现</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200703-105539@2x.png" alt></p>
<h5 id="5-clone的实现"><a href="#5-clone的实现" class="headerlink" title="5.clone的实现"></a>5.clone的实现</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200703-105716@2x.png" alt></p>
<h5 id="6-内核线程的创建"><a href="#6-内核线程的创建" class="headerlink" title="6.内核线程的创建"></a>6.内核线程的创建</h5><ul>
<li>早期内核中创建内核线程是通过kernel_thread()而创建的</li>
<li>目前内核中调用 kthread_create()创建的，其本质也是向do_fork()提供特定的flags标志而创建的。</li>
</ul>
<h5 id="7-copy-process-代码流程图"><a href="#7-copy-process-代码流程图" class="headerlink" title="7.copy_process()代码流程图"></a>7.copy_process()代码流程图</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200703-110810@2x.png" alt></p>
<h4 id="三、进程调度"><a href="#三、进程调度" class="headerlink" title="三、进程调度"></a>三、进程调度</h4><h5 id="1-调度模型"><a href="#1-调度模型" class="headerlink" title="1.调度模型"></a>1.调度模型</h5><ul>
<li>调度就是总就绪队列中选择一个进程投入CPU运行</li>
<li>调度的主战场是就绪队列，核心是调度算法，实质性的动作是进程切换，对于以时间片调度为主的调度，时钟中断是驱动力，确保每个进程在CPU上运行一定的时间</li>
</ul>
<h5 id="2-进程调度-进程的优先级"><a href="#2-进程调度-进程的优先级" class="headerlink" title="2.进程调度-进程的优先级"></a>2.进程调度-进程的优先级</h5><p>用户空间</p>
<ul>
<li>普通优先级（nice ）：从-20～19，数字越小，优先级越高，通过修改这个值可以改变普通进程获取cpu资源的比例。</li>
<li>调度优先级（scheduling priority）。从1（最低）~99（最高），这是实时进程的优先级。当然，普通进程也有调度优先级（scheduling priority），被设定为0。</li>
</ul>
<p>内核空间</p>
<ul>
<li>动态优先级（prio）</li>
<li>静态优先级（static_prio）</li>
<li>归一化优先级（normal_prio）</li>
<li>实时优先级（rt_priorit）</li>
</ul>
<h5 id="3-进程调度-O-1-调度"><a href="#3-进程调度-O-1-调度" class="headerlink" title="3.进程调度-O(1)调度"></a>3.进程调度-O(1)调度</h5><ul>
<li>基本优化思路就是把原来就绪队列上的单链表变成多个链表，即每一个优先级的进程被挂入不同链表中。</li>
<li>在O（1）调度器中，实时进程和普通进程被区分开了，普通进程根本不会影响实时进程的调度。</li>
<li>把CPU资源分成一个个的时间片，分配给每一个就绪的进程。</li>
<li>主调度器（就是schedule函数）的主要功能是从该CPU的就绪队列中找到一个最合适的进程调度执行。</li>
</ul>
<h5 id="4-完全公平调度-CFS"><a href="#4-完全公平调度-CFS" class="headerlink" title="4.完全公平调度-CFS"></a>4.完全公平调度-CFS</h5><ul>
<li>CFS调度器的目标是保证每一个进程的完全公平调度。</li>
<li>CFS调度器和以往的调度器不同之处在于没有时间片的概念，而是分配cpu使用时间的比例。</li>
<li>CFS为了实现公平，必须惩罚当前正在运行的进程，以使那些正在等待的进程下次被调度。</li>
<li>CFS通过每个进程的虚拟运行时间（vruntime）来衡量哪个进程最值得被调度。</li>
<li>CFS中的就绪队列是一棵以虚拟时间为键值的红黑树，虚拟时间越小的进程越靠近整个红黑树的最左端。</li>
</ul>
<h3 id="第四章-内存管理"><a href="#第四章-内存管理" class="headerlink" title="第四章 内存管理"></a>第四章 内存管理</h3><h4 id="一、内存管理机制"><a href="#一、内存管理机制" class="headerlink" title="一、内存管理机制"></a>一、内存管理机制</h4><h5 id="1-CPU的Cache"><a href="#1-CPU的Cache" class="headerlink" title="1.CPU的Cache"></a>1.CPU的Cache</h5><ul>
<li>lscpu查看内存的结构层次</li>
<li>L1d和L1i分别表示一级数据很指令Cache</li>
</ul>
<p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200703-115407@2x.png" alt></p>
<h5 id="2-虚拟内存实现机制"><a href="#2-虚拟内存实现机制" class="headerlink" title="2.虚拟内存实现机制"></a>2.虚拟内存实现机制</h5><ul>
<li>地址映射机制</li>
<li>内存分配机制</li>
<li>缓存和刷新机制</li>
<li>交换机制</li>
<li>请页机制</li>
</ul>
<h5 id="3-虚拟内存实现机制关系图"><a href="#3-虚拟内存实现机制关系图" class="headerlink" title="3.虚拟内存实现机制关系图"></a>3.虚拟内存实现机制关系图</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200703-152646@2x.png" alt></p>
<blockquote>
<p>首先内核通过映射机制把进程从磁盘映射到虚拟地址空间，当进程执行时，如果发现要访问的页没有在物理<br>内存时，就发出了页请求如图①；如果有空闲的内存可<br>供分配，就请求分配内存如图②（于是用到了内存的分<br>配和回收机制），并把正在使用的页记录在页缓存中如 图③（于是就使用了缓存机制）。如果没有足够的内存<br>可供分配，那么就调用交换机制，腾出一部分内存如图<br>④⑤。另外在地址映射中要通过TLB来加速物理页的寻找<br>如图⑧；交换机制中也要用到交换缓存如图⑥，并且把<br>物理页内容交换到交换文件中后也要通过修改页表来映<br>射文件地址如图⑦。</p>
</blockquote>
<h5 id="4-进程虚拟地址空间"><a href="#4-进程虚拟地址空间" class="headerlink" title="4.进程虚拟地址空间"></a>4.进程虚拟地址空间</h5><ul>
<li>每个进程通过系统调用进入内核，Linux内核空间由系统内的所有进程共享</li>
<li>每个进程拥有4G的虚拟地址空间，每个进程有各自的私有用户空间</li>
<li>进程地址空间：kernel space -&gt; Stack -&gt; Memory Mapping Region -&gt; Heap -&gt; Bss  -&gt; Data -&gt; Text</li>
</ul>
<h5 id="5-用数据结构描述进程的用户空间"><a href="#5-用数据结构描述进程的用户空间" class="headerlink" title="5.用数据结构描述进程的用户空间"></a>5.用数据结构描述进程的用户空间</h5><ul>
<li>mm_struct结构对金成整个用户空间进行描述</li>
<li>vm_area_structs结构对用户空间中各个内存区进行描述</li>
</ul>
<h5 id="6-mm-struct如何描述地址空间"><a href="#6-mm-struct如何描述地址空间" class="headerlink" title="6.mm_struct如何描述地址空间"></a>6.mm_struct如何描述地址空间</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200703-154202@2x.png" alt></p>
<h4 id="二、用户空间的创建"><a href="#二、用户空间的创建" class="headerlink" title="二、用户空间的创建"></a>二、用户空间的创建</h4><h5 id="1-创建进程用户空间"><a href="#1-创建进程用户空间" class="headerlink" title="1.创建进程用户空间"></a>1.创建进程用户空间</h5><ul>
<li>当fork()系统调用在创建新进程时也为该进程创建完整的用户空间</li>
<li>通过拷贝或共享父进程的用户空间来实现的，即内核调用copy_mm()函数，为新进程建立所有页表和mm_struct结构（通常，每个进程都有自己的用户空间，但是调用clone()函数创建的内核线程时共享父进程的用户空间）</li>
</ul>
<h5 id="2-虚存映射"><a href="#2-虚存映射" class="headerlink" title="2.虚存映射"></a>2.虚存映射</h5><ul>
<li>当调用exec()系统调用开始执行一个进程时，进程的可执行映像（包括代码段、数据段，堆和栈等）必须装入到进程的用户地址空间。</li>
<li>如果该进程用到了任何一个共享库，则共享库也必须装入到进程的用户空间。</li>
<li>Linux并不将映像装入到物理内存，相反，可执行文件只是被映射到进程的用户空间中。这种将可以执行文件映像映射到进程用户空间的方法被称为“虚存映射”。</li>
<li>分类：共享的、私有的、匿名的</li>
</ul>
<h5 id="3-VMA的创建方式"><a href="#3-VMA的创建方式" class="headerlink" title="3.VMA的创建方式"></a>3.VMA的创建方式</h5><ul>
<li>在用户空间通过mmap()系统调用获取do_mmap()的功能</li>
<li>在内核空间，可以直接调用do_mmap()创建一个新的虚拟内存</li>
</ul>
<h5 id="4-请页机制"><a href="#4-请页机制" class="headerlink" title="4.请页机制"></a>4.请页机制</h5><ul>
<li>进程运行时，CPU访问的是用户空间的虚地址。</li>
<li>Linux仅把当前要使用的少量页面装入内存，需要时再通过请页机制将特定的页面调入内存。</li>
<li>当要访问的页不在内存时，产生一个页故障并报告故障原因。</li>
</ul>
<h5 id="5-缺页异常处理"><a href="#5-缺页异常处理" class="headerlink" title="5.缺页异常处理"></a>5.缺页异常处理</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200703-161335@2x.png" alt></p>
<h4 id="三、内存分配与回收机制"><a href="#三、内存分配与回收机制" class="headerlink" title="三、内存分配与回收机制"></a>三、内存分配与回收机制</h4><h5 id="1-程序的装载过程"><a href="#1-程序的装载过程" class="headerlink" title="1.程序的装载过程"></a>1.程序的装载过程</h5><ul>
<li>程序在装载时，并没有把指令和数据加载进物理内存，知识通过ELF文件头部信息建立起可执行文件与虚拟地址空间的映射关系而已</li>
<li>真正的加载过程发生在缺页异常处理时</li>
<li>内核根据建立的映射关系，在可执行文件中找到所需的内容</li>
<li>分配一个物理内存页面，并将可执行文件内容加载到改内存中</li>
<li>建立该物理内存和虚拟地址空间的映射关系，即填充页表，然后把控制权移交给进程</li>
</ul>
<h5 id="2-内核空间的划分"><a href="#2-内核空间的划分" class="headerlink" title="2.内核空间的划分"></a>2.内核空间的划分</h5><ul>
<li>0M到high_memory的物理内存称为地段内存，大于high_memory的物理内存称为高端内存</li>
<li>高端内存映射到内核空间的方式：永久映射、固定映射、vmalloc机制</li>
</ul>
<h5 id="3-物理内存管理机制"><a href="#3-物理内存管理机制" class="headerlink" title="3.物理内存管理机制"></a>3.物理内存管理机制</h5><ul>
<li>伙伴算法：负责大块连续物理内存的分配和释放，以页框为基本单位。可以避免外部碎片</li>
<li>per-CPU页框高速缓存：内核经常请求和释放单个页框，该缓存包含预先分配的页框，用于满足本地CPU发出的单一页框请求</li>
<li>slab缓存：负责小块内存的分配，并且它也作为高速缓存，主要针对内核中经常分配并释放的对象</li>
<li>vmalloc机制：vmalloc机制使得内核通过连续的线性地址来访问非连续的物理页框，这样可以最大限度的使用高端物理内存。</li>
</ul>
<h5 id="4-Slab分配机制"><a href="#4-Slab分配机制" class="headerlink" title="4.Slab分配机制"></a>4.Slab分配机制</h5><ul>
<li>slab通用缓存：通用缓存针对一般情况，使用分配任意大小的物理内存，其接口为kmalloc()</li>
<li>slab专用缓存：专用缓存是对特定的对象，比如为进程控制块创建高速缓存task_struct_cachep</li>
</ul>
<h5 id="5-vmalloc和kmalloc之间的区别"><a href="#5-vmalloc和kmalloc之间的区别" class="headerlink" title="5.vmalloc和kmalloc之间的区别"></a>5.vmalloc和kmalloc之间的区别</h5><ul>
<li>vmalloc分配的物理地址无需连续，分配在VMALLOC_START~VMALLOC_END之间</li>
<li>kmacloc确保页在物理上是连续的，分配的内存处于3GB~high_memory之间，这段内核空间与物理空间一一对应</li>
</ul>
<p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200703-201653@2x.png" alt></p>
<h5 id="6-伙伴算法概述"><a href="#6-伙伴算法概述" class="headerlink" title="6.伙伴算法概述"></a>6.伙伴算法概述</h5><ul>
<li>大小相同、物理地址连续的两个页块被称为伙伴。</li>
<li>Linux的伙伴算法把所有的空闲页面分为多个块链表（该默认大小为11）个，每个链表中的一个块含有2的幂次个页面，即页块或简称块。</li>
<li>伙伴算法的分配原理是，如果分配阶为n的页框块，那么先从第n条页框块链表中查找是否存在这么大小的空闲页块。如果有则分配，否则在第n+1条链表中继续查找，直到找到为止。</li>
</ul>
<h5 id="7-物理内存分配器"><a href="#7-物理内存分配器" class="headerlink" title="7.物理内存分配器"></a>7.物理内存分配器</h5><blockquote>
<p>基于伙伴算法、每CPU高速缓存和slab高速缓存形成两种<br>内存分配器。</p>
</blockquote>
<ul>
<li>第一种是分区页框分配器（zoned page frame allocator），处理对连续页框的内存分配请求。</li>
<li>第二种是slab分配器，它将各种分配对象分组放进高速缓存，即每个高速缓存都对同类型分配对象的一种“储备”。</li>
</ul>
<h5 id="8-从用户态到内核态的内存分配"><a href="#8-从用户态到内核态的内存分配" class="headerlink" title="8.从用户态到内核态的内存分配"></a>8.从用户态到内核态的内存分配</h5><ul>
<li>首先进入内核，建立虚拟地址空间的映射，获得一块虚拟内存区VMA。</li>
<li>当进程对这块虚存区进行访问时，如果物理内存尚未分配，那么此时发生一个缺页异常，通过get_free_pages 申请一个或多个物理页面</li>
<li>再将此物理内存和虚拟内存的映射关系写入页表。</li>
</ul>
<h3 id="第五章-中断"><a href="#第五章-中断" class="headerlink" title="第五章 中断"></a>第五章 中断</h3><h4 id="一、中断概述"><a href="#一、中断概述" class="headerlink" title="一、中断概述"></a>一、中断概述</h4><h5 id="1-中断简介"><a href="#1-中断简介" class="headerlink" title="1.中断简介"></a>1.中断简介</h5><ul>
<li>中断是CPU对系统发生的某个事件做出的一种反应</li>
<li>引入中断，是为了支持CPU和设备之间的并行操作</li>
<li>CPU接收到中断信号，并不会立即响应，而是在执行每条指令周期的最后一个时钟周期，一旦检测到中断信号有效，cpu才在当前指令执行完后转入中断响应周期</li>
</ul>
<h5 id="2-高级可编程中断控制器（APIC）"><a href="#2-高级可编程中断控制器（APIC）" class="headerlink" title="2.高级可编程中断控制器（APIC）"></a>2.高级可编程中断控制器（APIC）</h5><ul>
<li>每个x86的核有一个本地APIC，这些本地APIC通过中断控制器通信总线连接到IO APIC上</li>
<li>IO APIC手机各个外设的中断，并翻译成总线上的信息，传递给某个CPU上的本地APIC</li>
</ul>
<h5 id="3-中断子系统分成4个部分"><a href="#3-中断子系统分成4个部分" class="headerlink" title="3.中断子系统分成4个部分"></a>3.中断子系统分成4个部分</h5><ul>
<li>硬件无关的代码，称之为Linux内核通用中断处理模块</li>
<li>CPU体系结构相关的中断处理。</li>
<li>中断控制器的驱动代码，和系统使用的中断控制器相关</li>
<li>普通外设的驱动。这些驱动使用Linux内核通用中断处理模块的API来实现自己的驱动逻辑</li>
</ul>
<h5 id="4-中断向量——中断源"><a href="#4-中断向量——中断源" class="headerlink" title="4.中断向量——中断源"></a>4.中断向量——中断源</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200703-231850@2x.png" alt></p>
<h5 id="5-中断描述符表中门"><a href="#5-中断描述符表中门" class="headerlink" title="5.中断描述符表中门"></a>5.中断描述符表中门</h5><blockquote>
<p>“门”的含义是当中断发生时必须先通过这些门，然后才<br>能进入相应的处理程序。</p>
</blockquote>
<ul>
<li>中断门：用户态的进程不能访问Intel的中断门。所有的中断处理程序<br>都由中断门激活，并全部限制在内核态。</li>
<li>陷阱门：控制权通过陷阱门进入处理程序时维持中断标志位（IF）不变，也就是说，不关中断。</li>
<li>系统门：这是Linux内核特别设置的，用来让用户态的进程访问Intel的陷阱门，因此，门描述符的DPL为3。系统调用就是通过系统门进入内核的。</li>
</ul>
<h4 id="一、中断处理机制"><a href="#一、中断处理机制" class="headerlink" title="一、中断处理机制"></a>一、中断处理机制</h4><h5 id="1-初始化中断描述符"><a href="#1-初始化中断描述符" class="headerlink" title="1.初始化中断描述符"></a>1.初始化中断描述符</h5><ul>
<li>Linux内核在系统的初始化阶段要初始化可编程控制器</li>
<li>将中断描述符表的起始地址装入中段描述符表寄存器，并初始化表中的每一项，当计算机运行在实模式时，中断秒适度表被初始化，并由BIOS使用</li>
<li>真正进入了Linux内核，中断描述符就被移到内存的另一个区域，并为进入保护模式进行初始化</li>
</ul>
<h5 id="2-中断门的设置"><a href="#2-中断门的设置" class="headerlink" title="2.中断门的设置"></a>2.中断门的设置</h5><ul>
<li>中断门的设置是由init_IRQ()函数中的一段代码完成的</li>
<li>设置时必须跳过用于系统调用的向量0x80 </li>
<li>中断处理程序的入口地址是一个数组interrupt[]，数组中的每个元素是指向中断处理例程（ISR）的指针。 </li>
<li>每个中断处理例程属于内核中的代码段，其段基地址存放于全局描述表（GDT）中</li>
</ul>
<h5 id="3-中断处理过程"><a href="#3-中断处理过程" class="headerlink" title="3.中断处理过程"></a>3.中断处理过程</h5><ul>
<li>中断和异常的硬件处理</li>
<li>中断请求队列的建立</li>
<li>中断处理程序的执行</li>
<li>从中断返回</li>
</ul>
<h5 id="4-X86的中断处理"><a href="#4-X86的中断处理" class="headerlink" title="4.X86的中断处理"></a>4.X86的中断处理</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200705-101105@2x.png" alt></p>
<h5 id="5-中断描述符——IRQ数据结构"><a href="#5-中断描述符——IRQ数据结构" class="headerlink" title="5.中断描述符——IRQ数据结构"></a>5.中断描述符——IRQ数据结构</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200705-104955@2x.png" alt></p>
<h5 id="6-从中断-异常-系统调用返回"><a href="#6-从中断-异常-系统调用返回" class="headerlink" title="6.从中断/异常/系统调用返回"></a>6.从中断/异常/系统调用返回</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200705-105552@2x.png" alt></p>
<h4 id="三、中断的下半部"><a href="#三、中断的下半部" class="headerlink" title="三、中断的下半部"></a>三、中断的下半部</h4><h5 id="1-中断的下半部"><a href="#1-中断的下半部" class="headerlink" title="1.中断的下半部"></a>1.中断的下半部</h5><ul>
<li>随着系统的不断复杂，中断处理函数要做的事情也越来越多，多到都来不及接收新的中断了，于是发生了中断丢失</li>
<li>内核把中断处理分为两部分：上半部（top half）不可中断和下半部（bottom half）可中断，上半部（也就是中断服务程序）内核立即执行，而下半部（就是一些内核函数）留着稍后处理</li>
</ul>
<h5 id="2-软中断机制"><a href="#2-软中断机制" class="headerlink" title="2.软中断机制"></a>2.软中断机制</h5><ul>
<li>中断的上半部、下半部是一种概念，实际上是内核中的一个函数，这些函数写好后，什么时候执行，如何执行，必须由内核管理</li>
<li>中断注册函数request_irq()把中断服务历程添加到中断请求队列中</li>
<li>执行由do_IRQ完成</li>
</ul>
<p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200705-122047@2x.png" alt></p>
<h5 id="3-软中断类型"><a href="#3-软中断类型" class="headerlink" title="3.软中断类型"></a>3.软中断类型</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200705-122146@2x.png" alt></p>
<h5 id="4-何时使用哪种中断机制"><a href="#4-何时使用哪种中断机制" class="headerlink" title="4.何时使用哪种中断机制"></a>4.何时使用哪种中断机制</h5><ul>
<li>软中断的使用原则很简单，最好不用。它甚至都不算是一种真正的中断处理机制，只是tasklet的实现基础。</li>
<li>工作队列也要少用，如果不是必须要用到线程才能用的某些机制，就不要使用工作队列</li>
<li>对于中断来说，只是对中断进行简单的处理，大部分工作是在驱动程序中完成的</li>
<li>除了上述情况，一般都使用小任务tasklet。</li>
</ul>
<h4 id="三、Linux的时间系统"><a href="#三、Linux的时间系统" class="headerlink" title="三、Linux的时间系统"></a>三、Linux的时间系统</h4><h5 id="1-时钟中断的作用"><a href="#1-时钟中断的作用" class="headerlink" title="1.时钟中断的作用"></a>1.时钟中断的作用</h5><ul>
<li>维持系统时间</li>
<li>促进进程的转换</li>
<li>保证所有进程共享CPU</li>
<li>利用时钟中断进行记账、系统监督工作以及确定未来的调度优先级等工作</li>
</ul>
<h5 id="2-基本时钟硬件"><a href="#2-基本时钟硬件" class="headerlink" title="2.基本时钟硬件"></a>2.基本时钟硬件</h5><ul>
<li>编程定时/计数器产生脉冲，由此引发中断请求信号</li>
<li>从本质上说，时钟中断知识一个周期性地信号，完全是硬件行为</li>
</ul>
<h5 id="3-与时钟有关的硬件"><a href="#3-与时钟有关的硬件" class="headerlink" title="3.与时钟有关的硬件"></a>3.与时钟有关的硬件</h5><ul>
<li>实时时钟RTC</li>
<li>可编程间隔器PIT</li>
<li>时间戳计数器</li>
<li>高精度计时器</li>
<li>CPU本地定时器</li>
<li>高精度定时器</li>
</ul>
<h5 id="4-基本时钟运行机制"><a href="#4-基本时钟运行机制" class="headerlink" title="4.基本时钟运行机制"></a>4.基本时钟运行机制</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200705-161459@2x.png" alt></p>
<h5 id="5-Linux时钟框架"><a href="#5-Linux时钟框架" class="headerlink" title="5.Linux时钟框架"></a>5.Linux时钟框架</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200705-162129@2x.png" alt></p>
<ul>
<li>在软件架构上看，时钟事件设备（clock_event_device）被分为了两层，与硬件相关的被放在了machine层，而与硬件无关的通用代码则被集中到了通用时间框架层</li>
<li>tick_device起什么作用？它是基于时钟事件设备的进一步封装，用于代替原有的时钟滴答中断，给内核提供节拍事件，以完成进程的调度和进程信息统计，负载平衡和时间更新等操作。</li>
<li>高分辨率定时器的代码实现时，内核的开发者考察了多种数据结构，例如基数树、哈希表等等，最终选择了红黑树（rbtree）来组织hrtimer。hrtimer不停地被创建和销毁，新的hrtimer按顺序被插入到红黑树中，树的最左边的节点就是最快到期的定时器。</li>
</ul>
<h5 id="6-定时器的使用"><a href="#6-定时器的使用" class="headerlink" title="6.定时器的使用"></a>6.定时器的使用</h5><ul>
<li>定义定时器</li>
<li>struct timer_list my_timer; </li>
<li>初始化定时器，填充定时器的结构</li>
<li>init_timer(&amp;my_timer); </li>
<li>激活定时器：add_timer(&amp;my_timer);</li>
<li>如果需要修改修改定时器，则调用 mod_timer(&amp;my_timer) </li>
<li>如果需要在定时器到期前停止定时器，可以使用</li>
<li>del_timer(&amp;my_timer)函数：</li>
</ul>
<h3 id="第六章-系统调用"><a href="#第六章-系统调用" class="headerlink" title="第六章 系统调用"></a>第六章 系统调用</h3><h4 id="一、Linux中各种接口"><a href="#一、Linux中各种接口" class="headerlink" title="一、Linux中各种接口"></a>一、Linux中各种接口</h4><h5 id="1-Linux-API"><a href="#1-Linux-API" class="headerlink" title="1. Linux API"></a>1. Linux API</h5><ul>
<li>Linux内核的系统调用接口和GNU C库（glibc）中的例程。</li>
<li>Linux内核系统调用接口系统调用接口是内核中所有已实现和可用系统调用的集合</li>
<li>GNU C标准库是Linux内核系统调用接口的封装</li>
</ul>
<h5 id="2-POSIX标准"><a href="#2-POSIX标准" class="headerlink" title="2.POSIX标准"></a>2.POSIX标准</h5><ul>
<li>POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ）</li>
<li>POSIX标准定义了操作系统应该为程序提供的标准接口</li>
</ul>
<h5 id="3-Linux-ABI内容"><a href="#3-Linux-ABI内容" class="headerlink" title="3.Linux ABI内容"></a>3.Linux ABI内容</h5><ul>
<li>一个特定的处理器指令集</li>
<li>函数调用惯例</li>
<li>系统调用方式 </li>
<li>可执行文件的格式(ELF,PE)</li>
</ul>
<h4 id="二、系统调用机制"><a href="#二、系统调用机制" class="headerlink" title="二、系统调用机制"></a>二、系统调用机制</h4><h5 id="1-跟踪进程所调用的系统调用"><a href="#1-跟踪进程所调用的系统调用" class="headerlink" title="1.跟踪进程所调用的系统调用"></a>1.跟踪进程所调用的系统调用</h5><blockquote>
<p>strace ls</p>
</blockquote>
<h5 id="2-中断、异常和系统调用比较"><a href="#2-中断、异常和系统调用比较" class="headerlink" title="2.中断、异常和系统调用比较"></a>2.中断、异常和系统调用比较</h5><ul>
<li>中断：外设发出的请求</li>
<li>异常：应用程序意想不到的行为</li>
<li>系统调用：应用程序请求OS提供服务 </li>
<li>响应方式<blockquote>
<p>中断是异步的，异常是同步的，而系统调用既可以是异步，也可以是同步。</p>
</blockquote>
</li>
<li>处理机制<blockquote>
<p>中断服务程序在内核态下运行，对用户是透明的。异常出现时，或者杀死进程，或者重新执行引起异常的指令。系统调用，用户发出请求后等待OS的服务。</p>
</blockquote>
</li>
</ul>
<h5 id="3-系统调用的基本概念"><a href="#3-系统调用的基本概念" class="headerlink" title="3.系统调用的基本概念"></a>3.系统调用的基本概念</h5><ul>
<li>系统调用标识号：用来唯一标识每个系统调用</li>
<li>系统调用表：是用来把系统调用号和相应的服务例程关联起来。该表存放在sys_call_table数组中</li>
</ul>
<h3 id="第七章-内核同步"><a href="#第七章-内核同步" class="headerlink" title="第七章 内核同步"></a>第七章 内核同步</h3><h4 id="一、内核同步机制概述"><a href="#一、内核同步机制概述" class="headerlink" title="一、内核同步机制概述"></a>一、内核同步机制概述</h4><h5 id="1-并发执行的原因"><a href="#1-并发执行的原因" class="headerlink" title="1.并发执行的原因"></a>1.并发执行的原因</h5><ul>
<li>中断</li>
<li>睡眠</li>
<li>内核抢占</li>
<li>对称多处理</li>
</ul>
<h5 id="2-竞争条件"><a href="#2-竞争条件" class="headerlink" title="2.竞争条件"></a>2.竞争条件</h5><ul>
<li>至少有两个可执行上下文“并行执行”</li>
<li>可执行上下文对共享内训变量执行“读写”访问</li>
</ul>
<h5 id="3-临界区"><a href="#3-临界区" class="headerlink" title="3.临界区"></a>3.临界区</h5><ul>
<li>访问和操作共享数据的代码段叫做临界区</li>
<li>多个内核任务并发访问同一个资源通常是不安全的。为了避免对临界区进行并发访问，编程者必须保证临界区代码被原子地执行。</li>
</ul>
<h5 id="4-保护临界区的措施"><a href="#4-保护临界区的措施" class="headerlink" title="4.保护临界区的措施"></a>4.保护临界区的措施</h5><ul>
<li>使临界区的操作原子进行</li>
<li>进入临界区后禁止抢占</li>
<li>串行地访问临界区</li>
</ul>
<h5 id="5-原子操作"><a href="#5-原子操作" class="headerlink" title="5.原子操作"></a>5.原子操作</h5><blockquote>
<p>对于由多个内核任务进行共享的变量，其load-modify-store必须是原子地进行的，不能分割</p>
</blockquote>
<h5 id="6-共享队列和加锁"><a href="#6-共享队列和加锁" class="headerlink" title="6.共享队列和加锁"></a>6.共享队列和加锁</h5><ul>
<li>当共享资源是一个复杂的数据结构时，竞争状态往往会使该数据结构遭到破坏。</li>
<li>访问队列必须加锁</li>
</ul>
<h5 id="7-死锁的避免"><a href="#7-死锁的避免" class="headerlink" title="7.死锁的避免"></a>7.死锁的避免</h5><blockquote>
<p>所有任务都在相互等待，但它们永远不会释放已经占有的资源，于是任何任务都无法继续，这种情况就是死锁。</p>
</blockquote>
<ul>
<li>加锁的顺序是关键。</li>
<li>防止发生饥饿</li>
<li>不要重复请求同一个锁</li>
<li>越复杂的加锁方案越有可能造成死锁</li>
</ul>
<h4 id="二、内核同步措施"><a href="#二、内核同步措施" class="headerlink" title="二、内核同步措施"></a>二、内核同步措施</h4><blockquote>
<p>内核同步措施主要有中断屏蔽、原子操作、自旋锁、信号量</p>
</blockquote>
<h5 id="1-中断屏蔽"><a href="#1-中断屏蔽" class="headerlink" title="1.中断屏蔽"></a>1.中断屏蔽</h5><ul>
<li>在进入临界区之前屏蔽系统的中断，从而保证正在执行的内核任务不被中断处理程序锁抢断，防止某些静态条件的发生，在退出临界区后，重新打开中断</li>
<li>中断屏蔽的缺点：1.不能解决多处理器引发的竞态；2.在屏蔽器件所有的中断无法得到处理</li>
</ul>
<h5 id="2-自旋锁"><a href="#2-自旋锁" class="headerlink" title="2.自旋锁"></a>2.自旋锁</h5><ul>
<li>设计自旋锁的初衷是在短期间内进行轻量级的锁定，所以自旋锁不应该被持有时间过长。</li>
<li>自旋锁在内核中主要用来防止多处理器中并发访问临界区，防止内核抢占造成的竞争</li>
<li>自旋锁不允许任务睡眠，持有自旋锁的任务睡眠会造成自死锁，因此自旋锁能够在中断上下文中使用。</li>
</ul>
<h5 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3.信号量"></a>3.信号量</h5><ul>
<li>Linux中的信号量是一种睡眠锁</li>
<li>若有一个任务试图获得一个已被持有的信号量时，信号量会将其推入等待队列，然后让其睡眠。</li>
<li>信号量具有睡眠特性，适用于锁会被长时间持有的情况，只能在进程上下文中使用。</li>
</ul>
<h5 id="4-信号量与自旋锁的比较"><a href="#4-信号量与自旋锁的比较" class="headerlink" title="4.信号量与自旋锁的比较"></a>4.信号量与自旋锁的比较</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200705-231325@2x.png" alt></p>
<h5 id="5-内核其他的同步措施"><a href="#5-内核其他的同步措施" class="headerlink" title="5.内核其他的同步措施"></a>5.内核其他的同步措施</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200705-231439@2x.png" alt></p>
<h3 id="第八章-文件系统"><a href="#第八章-文件系统" class="headerlink" title="第八章 文件系统"></a>第八章 文件系统</h3><h4 id="一、虚拟文件系统的引入"><a href="#一、虚拟文件系统的引入" class="headerlink" title="一、虚拟文件系统的引入"></a>一、虚拟文件系统的引入</h4><h5 id="1-Linux文件系统"><a href="#1-Linux文件系统" class="headerlink" title="1.Linux文件系统"></a>1.Linux文件系统</h5><ul>
<li>文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构</li>
<li>操作系统文件信息的软件机构称为文件管理系统</li>
<li>Linux常见的文件系统有ext2,3,4,NTFS,JFS,XFS等</li>
</ul>
<h5 id="2-Linux的文件结构"><a href="#2-Linux的文件结构" class="headerlink" title="2.Linux的文件结构"></a>2.Linux的文件结构</h5><blockquote>
<p>Linux采用标准的目录结构—树型结构，无论操作系统管理几个磁盘分区，这样的目录树只有一个。</p>
</blockquote>
<h5 id="3-Linux文件系统之索引点"><a href="#3-Linux文件系统之索引点" class="headerlink" title="3.Linux文件系统之索引点"></a>3.Linux文件系统之索引点</h5><ul>
<li>Linux文件系统使用索引节点来记录文件信息</li>
<li>系统给每个索引节点分配一个号码，称为索引节点</li>
<li>文件系统就是靠这个索引节点号识别一个文件</li>
</ul>
<h5 id="4-文件系统类型"><a href="#4-文件系统类型" class="headerlink" title="4.文件系统类型"></a>4.文件系统类型</h5><ul>
<li>ext2具有极快的速度和极小的CPU占用率，可用于硬盘和移动存储设备</li>
<li>ext3增加日志功能，可回溯追踪</li>
<li>ext4日志式文件系统，支持1EB（1024*1024TB），最大单文件16TB，支持连续写入可减少文件碎片。</li>
<li>xfs可以管理500T的硬盘，</li>
<li>brtfs文件系统针对固态盘做优化等等</li>
</ul>
<h5 id="5-文件系统的安装"><a href="#5-文件系统的安装" class="headerlink" title="5.文件系统的安装"></a>5.文件系统的安装</h5><blockquote>
<p>将一个文件系统的顶层目录挂到另一个文件系统的子目录上，使他们成为一个整体，称为“安装（mount）”。把该子目录称为“安装点（mount point）”</p>
</blockquote>
<h5 id="6-虚拟文件系统（VFS）框架"><a href="#6-虚拟文件系统（VFS）框架" class="headerlink" title="6.虚拟文件系统（VFS）框架"></a>6.虚拟文件系统（VFS）框架</h5><blockquote>
<p>虚拟文件系统所提供的抽象界面主要由一组标准的、抽象的操作构成，例如open(),read()、write()等，这些函数以系统调用的形式供用户程序调用。</p>
</blockquote>
<p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200706-110931@2x.png" alt></p>
<ul>
<li>Linux内核采用VFS框架来组织文件系统，每个文件系统用一个超级块数据结构来描述</li>
<li>一个文件系统如果想加入VFS，就得先在VFS进行注册</li>
</ul>
<h4 id="二、VFS的数据结构"><a href="#二、VFS的数据结构" class="headerlink" title="二、VFS的数据结构"></a>二、VFS的数据结构</h4><h5 id="1-VFS共性对象的抽象"><a href="#1-VFS共性对象的抽象" class="headerlink" title="1.VFS共性对象的抽象"></a>1.VFS共性对象的抽象</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200706-112514@2x.png" alt></p>
<h5 id="2-索引节点对象-描述文件属性"><a href="#2-索引节点对象-描述文件属性" class="headerlink" title="2.索引节点对象-描述文件属性"></a>2.索引节点对象-描述文件属性</h5><blockquote>
<p>索引节点对象存储了文件的相关信息，代表了存储设备上的一个实际的物理文件。当一个 文件首次被访问时，内核会在内存中组装相应的索引节点对象，以便向内核提供对一个文件进行操 作时所必需的全部信息；这些信息一部分存储在磁盘特定位置，另外一部分是在加载时动态填充的。</p>
</blockquote>
<h5 id="3-目录项对象——描述文件的路径"><a href="#3-目录项对象——描述文件的路径" class="headerlink" title="3.目录项对象——描述文件的路径"></a>3.目录项对象——描述文件的路径</h5><ul>
<li>引入目录项的概念主要是出于方便查找文件的目的。</li>
<li>一个路径的各个组成部分，不管是目录还是普通的文件，都是一个目录项对象。</li>
<li>不同于前面的两个对象，目录项对象没有对应的磁盘数据结构，VFS在遍历路径名的过程中现场将它们逐个地解析成目录项对象。</li>
</ul>
<h5 id="4-文件对象"><a href="#4-文件对象" class="headerlink" title="4.文件对象"></a>4.文件对象</h5><blockquote>
<p>文件对象是已打开的文件在内存中的表示，主要用于建立进程和磁盘上的文件的对应关系。它由sys_open()现场创建，由sys_close()销毁。</p>
</blockquote>
<h5 id="5-与进程相关的文件结构"><a href="#5-与进程相关的文件结构" class="headerlink" title="5.与进程相关的文件结构"></a>5.与进程相关的文件结构</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200706-114147@2x.png" alt></p>
<h4 id="三、文件系统的缓冲区"><a href="#三、文件系统的缓冲区" class="headerlink" title="三、文件系统的缓冲区"></a>三、文件系统的缓冲区</h4><h5 id="1-文件系统中的缓冲区"><a href="#1-文件系统中的缓冲区" class="headerlink" title="1.文件系统中的缓冲区"></a>1.文件系统中的缓冲区</h5><blockquote>
<p>缓冲区(buffer)，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。</p>
</blockquote>
<h5 id="2-buffer和cache有何不同"><a href="#2-buffer和cache有何不同" class="headerlink" title="2.buffer和cache有何不同"></a>2.buffer和cache有何不同</h5><blockquote>
<p>buffer，内存缓冲区，是各进程产生的文件临时存放区，一定时间段内统一写入磁盘，减少磁盘碎片和 硬盘的反复寻道，从而提高系统性能；简单来说，buffer就是存放要写入磁盘的数据。</p>
</blockquote>
<blockquote>
<p>cache，内存缓存区，经常被用在磁盘的I/O请求上，如果有文件频繁被访问到，系统会将文件缓存在cache区，供CPU、进程等访问；简单来说cache中的数据就是存放磁盘中读出来的数据。</p>
</blockquote>
<h5 id="3-Buffer-Cache和-Page-Cache有何不同？"><a href="#3-Buffer-Cache和-Page-Cache有何不同？" class="headerlink" title="3.Buffer Cache和 Page Cache有何不同？"></a>3.Buffer Cache和 Page Cache有何不同？</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200706-120555@2x.png" alt></p>
<h4 id="四、页高速缓存以及读写"><a href="#四、页高速缓存以及读写" class="headerlink" title="四、页高速缓存以及读写"></a>四、页高速缓存以及读写</h4><h5 id="1-文件系统的读写单位"><a href="#1-文件系统的读写单位" class="headerlink" title="1.文件系统的读写单位"></a>1.文件系统的读写单位</h5><blockquote>
<p>文件系统的读写单位是块，一个块的大小是2的n次方个扇区，比如1k，2k, 4k, 4M 等</p>
</blockquote>
<h5 id="2-从Buffer-Cache到Page-Cache"><a href="#2-从Buffer-Cache到Page-Cache" class="headerlink" title="2.从Buffer Cache到Page Cache"></a>2.从Buffer Cache到Page Cache</h5><ul>
<li>buffer cache是面向底层块设备的，所以它的粒度是文件系统的块，块设备和系统采用块进行交互。</li>
<li>块再转换成磁盘的基本物理结构扇区。</li>
<li>内核的内存管理组件采用了比文件系统的块更高级别的抽象-页(page)，页的大小一般从4KB到2MB,粒度更大，处理的性能更高。</li>
</ul>
<h5 id="3-索引节点、页和页缓存之间的关系"><a href="#3-索引节点、页和页缓存之间的关系" class="headerlink" title="3.索引节点、页和页缓存之间的关系"></a>3.索引节点、页和页缓存之间的关系</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200706-142807@2x.png" alt></p>
<h5 id="4-如何读取一个文件"><a href="#4-如何读取一个文件" class="headerlink" title="4.如何读取一个文件"></a>4.如何读取一个文件</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200706-143501@2x.png" alt></p>
<h5 id="5-如何写入文件"><a href="#5-如何写入文件" class="headerlink" title="5.如何写入文件"></a>5.如何写入文件</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200706-143926@2x.png" alt></p>
<h3 id="第九章-设备驱动"><a href="#第九章-设备驱动" class="headerlink" title="第九章 设备驱动"></a>第九章 设备驱动</h3><h4 id="一、设备驱动概述"><a href="#一、设备驱动概述" class="headerlink" title="一、设备驱动概述"></a>一、设备驱动概述</h4><h5 id="1-如何表示设备"><a href="#1-如何表示设备" class="headerlink" title="1.如何表示设备"></a>1.如何表示设备</h5><ul>
<li>索引节点</li>
<li>主设备号</li>
<li>次设备号</li>
</ul>
<h5 id="2-设备的分类"><a href="#2-设备的分类" class="headerlink" title="2.设备的分类"></a>2.设备的分类</h5><ul>
<li>块设备</li>
<li>字符设备</li>
<li>网络设备</li>
</ul>
<h5 id="3-不同设备的类型的差异性"><a href="#3-不同设备的类型的差异性" class="headerlink" title="3.不同设备的类型的差异性"></a>3.不同设备的类型的差异性</h5><ul>
<li>字符设备和块设备对应/dev下的一个设备文件。而网络设备不存在这样的设备文件。网络设备使用套接字socket访问，虽然也使用read,write系统调用，但这些调用只作用于软件对象。</li>
<li>块设备只响应来自内核的请求，而网络驱动程序异步接收来自外部世界的数据包，并发送到内核。</li>
<li>文件系统通常都建立在块设备上，也有很多文件系统放在内存，比如/proc，不需要驱动程序。</li>
</ul>
<h5 id="4-设备驱动程序在应用开发中的位置"><a href="#4-设备驱动程序在应用开发中的位置" class="headerlink" title="4.设备驱动程序在应用开发中的位置"></a>4.设备驱动程序在应用开发中的位置</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200706-150652@2x.png" alt></p>
<h5 id="5-内核配置选项及驱动程序编译"><a href="#5-内核配置选项及驱动程序编译" class="headerlink" title="5.内核配置选项及驱动程序编译"></a>5.内核配置选项及驱动程序编译</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200706-150948@2x.png" alt></p>
<h4 id="二、IO空间的管理"><a href="#二、IO空间的管理" class="headerlink" title="二、IO空间的管理"></a>二、IO空间的管理</h4><h5 id="1-I-O端口"><a href="#1-I-O端口" class="headerlink" title="1.I/O端口"></a>1.I/O端口</h5><ul>
<li>设备驱动程序要直接访问外设或其接口卡上的物理电路，通常以寄存器的形式出现访问；</li>
<li>外设寄存器也称为I/O端口，通常包括控制寄存器、状态寄存器和数据寄存器三类。</li>
</ul>
<h5 id="2-I-O资源管理"><a href="#2-I-O资源管理" class="headerlink" title="2.I/O资源管理"></a>2.I/O资源管理</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200706-152040@2x.png" alt></p>
<h4 id="三、设备驱动模型"><a href="#三、设备驱动模型" class="headerlink" title="三、设备驱动模型"></a>三、设备驱动模型</h4><h5 id="1-Linux设备驱动模型引入的目的"><a href="#1-Linux设备驱动模型引入的目的" class="headerlink" title="1.Linux设备驱动模型引入的目的"></a>1.Linux设备驱动模型引入的目的</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200706-153901@2x.png" alt></p>
<h5 id="2-核心对象之kobject"><a href="#2-核心对象之kobject" class="headerlink" title="2.核心对象之kobject"></a>2.核心对象之kobject</h5><ul>
<li>kobject结构体是设备驱动模型底层的一个结构体，这个结构体是设备驱动模型下的所有对象的一个基本单元，它是对设备驱动模型下所有对象抽象出来的共有的部分；</li>
<li>kobject结构体提供了一些公共型的服务：对象引用计数、维护对象链表、对象上锁、对用户空间的表示。</li>
<li>设备驱动模型中的各种对象其内部都会包含一个kobject，地位相当于面向对象思想中的总基类。</li>
</ul>
<h4 id="三、字符设备驱动程序"><a href="#三、字符设备驱动程序" class="headerlink" title="三、字符设备驱动程序"></a>三、字符设备驱动程序</h4><h5 id="1-字符设备基础"><a href="#1-字符设备基础" class="headerlink" title="1.字符设备基础"></a>1.字符设备基础</h5><ul>
<li>字符设备是指只能一个字节一个字节进行读写操作的设备，不能随机读取设备中的某一数据，读取数据要按照先后顺序</li>
<li>字符设备是面向流的设备，常见的字符设备有鼠标、键盘、串口、控制台和LED等</li>
<li>一般每个字符设备或者块设备会在/dev目录下对应一个设备文件</li>
</ul>
<h5 id="2-编写字符设备驱动的步骤"><a href="#2-编写字符设备驱动的步骤" class="headerlink" title="2.编写字符设备驱动的步骤"></a>2.编写字符设备驱动的步骤</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200706-155434@2x.png" alt></p>
<h5 id="3-设备号的申请和释放"><a href="#3-设备号的申请和释放" class="headerlink" title="3.设备号的申请和释放"></a>3.设备号的申请和释放</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200706-155651@2x.png" alt></p>
<h4 id="五、块设备驱动程序"><a href="#五、块设备驱动程序" class="headerlink" title="五、块设备驱动程序"></a>五、块设备驱动程序</h4><h5 id="1-块设备和字符设备的区别"><a href="#1-块设备和字符设备的区别" class="headerlink" title="1.块设备和字符设备的区别"></a>1.块设备和字符设备的区别</h5><ul>
<li>块设备上可以mount文件系统，而字符设备是不可以的；</li>
<li>数据经过块设备相比操作字符设备需要多经历一个数据缓冲层（buffer cache）机制。</li>
</ul>
<h5 id="2-I-O调度算法"><a href="#2-I-O调度算法" class="headerlink" title="2.I/O调度算法"></a>2.I/O调度算法</h5><p><img src="/images/loading/loading.gif" data-original="./Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/QQ20200706-160058@2x.png" alt></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux实验</title>
    <url>/2020/07/06/Linux%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/07/06/UPgae1.md.png">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">白发少女</div>
</center>


<blockquote>
<p>此文为学习《奔跑吧Linux内核》所做实验做的笔记</p>
</blockquote>
<a id="more"></a>
<h3 id="第一章-Linux系统入门"><a href="#第一章-Linux系统入门" class="headerlink" title="第一章 Linux系统入门"></a>第一章 Linux系统入门</h3><h4 id="1-阅读服务器系统信息"><a href="#1-阅读服务器系统信息" class="headerlink" title="1.阅读服务器系统信息"></a>1.阅读服务器系统信息</h4><p>cat /proc/cpuinfo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vendor_id　：CPU制造商     </span><br><span class="line">cpu family　：CPU产品系列代号</span><br><span class="line">model　　　：CPU属于其系列中的哪一代的代号</span><br><span class="line">model name：CPU属于的名字及其编号、标称主频</span><br><span class="line">stepping　  ：CPU属于制作更新版本</span><br><span class="line">cpu MHz　  ：CPU的实际使用主频</span><br><span class="line">cache size   ：CPU二级缓存大小</span><br><span class="line">physical id   ：单个CPU的标号</span><br><span class="line">siblings       ：单个CPU逻辑物理核数</span><br><span class="line">core id        ：当前物理核在其所处CPU中的编号，这个编号不一定连续</span><br><span class="line">cpu cores    ：该逻辑核所处CPU的物理核数</span><br><span class="line">apicid          ：用来区分不同逻辑核的编号，系统中每个逻辑核的此编号必然不同，此编号不一定连续</span><br><span class="line">fpu             ：是否具有浮点运算单元（Floating Point Unit）</span><br><span class="line">fpu_exception  ：是否支持浮点计算异常</span><br><span class="line">cpuid level   ：执行cpuid指令前，eax寄存器中的值，根据不同的值cpuid指令会返回不同的内容</span><br><span class="line">wp             ：表明当前CPU是否在内核态支持对用户空间的写保护（Write Protection）</span><br><span class="line">flags          ：当前CPU支持的功能</span><br><span class="line">bogomips   ：在系统内核启动时粗略测算的CPU速度（Million Instructions Per Second）</span><br><span class="line">clflush size  ：每次刷新缓存的大小单位</span><br><span class="line">cache_alignment ：缓存地址对齐单位</span><br><span class="line">address sizes     ：可访问地址空间位数</span><br><span class="line">power management ：对能源管理的支持，有以下几个可选支持功能</span><br></pre></td></tr></table></figure>

<h3 id="第二章-Linux内核基础知识"><a href="#第二章-Linux内核基础知识" class="headerlink" title="第二章 Linux内核基础知识"></a>第二章 Linux内核基础知识</h3><h4 id="一、C文件编译"><a href="#一、C文件编译" class="headerlink" title="一、C文件编译"></a>一、C文件编译</h4><p>vi test.c添加一下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define PAGE_SIZE 4096</span><br><span class="line">#define MAX_SIZE 100*PAGE_SIZE</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        char *buf &#x3D; (char *)malloc(MAX_SIZE);</span><br><span class="line">        memset(buf, 0, MAX_SIZE);</span><br><span class="line">        printf(&quot;buffer adress &#x3D; 0x%p\n&quot;, buf);</span><br><span class="line">        free(buf);</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预处理 GCC的“-E”选项可以让预处理阶段就结束，-o指定输出文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>
<p>编译 “-S”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc test.i -o test.s</span><br></pre></td></tr></table></figure>
<p>汇编 “-c”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure>
<p>链接 “–static”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc  test.o -o test --static</span><br></pre></td></tr></table></figure>
<p>写个Makefile来编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc &#x3D; arm-linux-gnueabi-gcc</span><br><span class="line">prom &#x3D; test </span><br><span class="line">obj &#x3D; test.o</span><br><span class="line">CFLAGS &#x3D; -static</span><br><span class="line"></span><br><span class="line">$(prom) : $(obj)</span><br><span class="line">        $(cc) -o $(prom) $(obj) $(CFLAGS)</span><br><span class="line"></span><br><span class="line">%.o: %.c</span><br><span class="line">        $(cc) -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -rf $(obj) $(prom)</span><br></pre></td></tr></table></figure>

<h4 id="二、把Vim打造成一个强大的IDE编辑器"><a href="#二、把Vim打造成一个强大的IDE编辑器" class="headerlink" title="二、把Vim打造成一个强大的IDE编辑器"></a>二、把Vim打造成一个强大的IDE编辑器</h4><h5 id="下载Vundle"><a href="#下载Vundle" class="headerlink" title="下载Vundle"></a>下载Vundle</h5><p>（1）下载插件管理器Vundle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;VundleVim&#x2F;Vundle.vim.git ~&#x2F;.vim&#x2F;bundle&#x2F;Vundle.vim</span><br></pre></td></tr></table></figure>
<p>（2）配置Vundle，编辑Vim的配置文件vimrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim .vimrc</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set nocompatible              &quot; be iMproved, required</span><br><span class="line">filetype off                  &quot; required</span><br><span class="line"></span><br><span class="line">&quot; 启用vundle来管理vim插件</span><br><span class="line">set rtp+&#x3D;~&#x2F;.vim&#x2F;bundle&#x2F;Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">&quot; 安装插件写在这之后</span><br><span class="line"></span><br><span class="line">&quot; let Vundle manage Vundle, required</span><br><span class="line">Plugin &#39;VundleVim&#x2F;Vundle.vim&#39;</span><br><span class="line"></span><br><span class="line">&quot; 安装插件写在这之前</span><br><span class="line">call vundle#end()            &quot; required</span><br><span class="line">filetype plugin on    &quot; required</span><br><span class="line"></span><br><span class="line">&quot; 常用命令</span><br><span class="line">&quot; :PluginList       - 查看已经安装的插件</span><br><span class="line">&quot; :PluginInstall    - 安装插件</span><br><span class="line">&quot; :PluginUpdate     - 更新插件</span><br><span class="line">&quot; :PluginSearch     - 搜索插件，例如 :PluginSearch xml就能搜到xml相关的插件</span><br><span class="line">&quot; :PluginClean      - 删除插件，把安装插件对应行删除，然后执行这个命令即可</span><br></pre></td></tr></table></figure>
<p>（3）安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:PluginInstall</span><br></pre></td></tr></table></figure>

<h5 id="ctags工具"><a href="#ctags工具" class="headerlink" title="ctags工具"></a>ctags工具</h5><blockquote>
<p>ctags的功能：扫描指定的源文件，找出其中所包含的语法元素，并将找到的相关内容记录下来</p>
</blockquote>
<p>下载ctags</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ctags</span><br></pre></td></tr></table></figure>
<p>递归扫描源代码根目录和子目录的文件并且生成索引文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctags -R</span><br></pre></td></tr></table></figure>
<p>进入vim加载这个tags文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:set tags&#x3D;tags</span><br></pre></td></tr></table></figure>

<h5 id="Tagbar插件"><a href="#Tagbar插件" class="headerlink" title="Tagbar插件"></a>Tagbar插件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.vimrc</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Plugin &#39;majutsushi&#x2F;tagbar&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:PluginInstall</span><br></pre></td></tr></table></figure>

<h5 id="NerdTree插件"><a href="#NerdTree插件" class="headerlink" title="NerdTree插件"></a>NerdTree插件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.vimrc</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Plugin &#39;scrooloose&#x2F;nerdtree&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:PluginInstall</span><br></pre></td></tr></table></figure>

<h5 id="YouCompleteMe插件"><a href="#YouCompleteMe插件" class="headerlink" title="YouCompleteMe插件"></a>YouCompleteMe插件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.vimrc</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Plugin &#39;valloric&#x2F;YouCompleteMe&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:PluginInstall</span><br></pre></td></tr></table></figure>
<p>插件安装完成以后需要重新编译它，编译之前需要下载如下软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential cmake python-dev python3-dev</span><br></pre></td></tr></table></figure>
<p>进入 YouCompleteMe进行编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.vim&#x2F;bundle&#x2F;YouCompleteMe</span><br><span class="line">.&#x2F;install.py --clang-comleter</span><br></pre></td></tr></table></figure>
<p>拷贝配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp ~&#x2F;.vim&#x2F;bundle&#x2F;YouCompleteMe&#x2F;third_party&#x2F;ycmd&#x2F;examples&#x2F;.ycm_extra_conf.py ~&#x2F;.vim</span><br></pre></td></tr></table></figure>
<p>再在.vimrc配置文件中还需要添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let g:ycm_server_python_interpreter&#x3D;&#39;&#x2F;usr&#x2F;bin&#x2F;python&#39;</span><br><span class="line">let g:ycm_global_ycm_extra_conf&#x3D;&#39;~&#x2F;.vim&#x2F;.ycm_extra_conf.py&#39;</span><br></pre></td></tr></table></figure>

<h4 id="三、在服务器上建立git仓库"><a href="#三、在服务器上建立git仓库" class="headerlink" title="三、在服务器上建立git仓库"></a>三、在服务器上建立git仓库</h4><p>服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir KongoBlog.git</span><br><span class="line">cd KongoBlog.git</span><br><span class="line">git --bare init</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir KongoBlog</span><br><span class="line">cd KongBlog</span><br><span class="line">git init </span><br><span class="line">git remote add origin ssh:&#x2F;&#x2F;root@ip:&#x2F;root&#x2F;KongoBlog.git</span><br></pre></td></tr></table></figure>
<p>推送方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure>
<p>拉取方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone ssh:&#x2F;&#x2F;root@ip:&#x2F;root&#x2F;KongoBlog.git</span><br></pre></td></tr></table></figure>

<h3 id="第三章-内核编译和调试"><a href="#第三章-内核编译和调试" class="headerlink" title="第三章 内核编译和调试"></a>第三章 内核编译和调试</h3><h4 id="一、通过QEMU调试ARM-Linux内核"><a href="#一、通过QEMU调试ARM-Linux内核" class="headerlink" title="一、通过QEMU调试ARM Linux内核"></a>一、通过QEMU调试ARM Linux内核</h4><h5 id="1-下载软件"><a href="#1-下载软件" class="headerlink" title="1.下载软件"></a>1.下载软件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gdb-multiarch</span><br></pre></td></tr></table></figure>
<h5 id="2-内核配置"><a href="#2-内核配置" class="headerlink" title="2.内核配置"></a>2.内核配置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd runninglinuxkernel_4.0</span><br><span class="line">export ARCH&#x3D;arm</span><br><span class="line">export CROSS_COMPILE&#x3D;arm-linux-gnueabi-</span><br><span class="line">make vexpress_defconfig</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p>记得保证编译的内核包含调试信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kernel Hacking  ---&gt;</span><br><span class="line">Compile-time checks and compiler options ---&gt;</span><br><span class="line">  [*] Compile the kernel with debug info</span><br></pre></td></tr></table></figure>
<p>重新编译内核</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make bzImage -j4 </span><br><span class="line">make dtbs</span><br></pre></td></tr></table></figure>
<p>在终端输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-system-arm -nographic -M vexpress-a9 -m 100M -kernel arch&#x2F;arm&#x2F;boot&#x2F;zImage -append &quot;rdinit&#x3D;&#x2F;linuxrc console&#x3D;ttyAMA0 loglevel&#x3D;8&quot; -dtb arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;vexpress-v2p-ca9.dtb -S -s</span><br></pre></td></tr></table></figure>
<p>-S 表示QEMU虚拟机会冻结CPU，直到远程GDB输入相应的控制指令为止<br>-s 表示在1234端口接受GDB的调试连接</p>
<p>在另一中断输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd runninglinuxkernel_4.0</span><br><span class="line">.&#x2F;run.sh arm32 debug</span><br></pre></td></tr></table></figure>
<p>再在另一中断输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd runninglinuxkernel_4.0</span><br><span class="line">gdb-multiarch --tui vmlinux</span><br><span class="line">(gdb) set architecture arm </span><br><span class="line">(gdb) target remote localhost:1234</span><br><span class="line">(gdb) b start_kernel</span><br><span class="line">(gdb) c</span><br></pre></td></tr></table></figure>

<h3 id="第四章-内核模块"><a href="#第四章-内核模块" class="headerlink" title="第四章 内核模块"></a>第四章 内核模块</h3><h4 id="1-编写一个简单的内核模块"><a href="#1-编写一个简单的内核模块" class="headerlink" title="1.编写一个简单的内核模块"></a>1.编写一个简单的内核模块</h4><p>编译内核</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd runninglinuxkernel_4.0</span><br><span class="line">export ARCH&#x3D;arm</span><br><span class="line">export CROSS_COMPILE&#x3D;arm-linux-gnueabi-</span><br><span class="line">make vexpress_defconfig</span><br><span class="line">make </span><br><span class="line">make bzImage -j4</span><br><span class="line">make dtbs</span><br></pre></td></tr></table></figure>
<p>建立文件夹，写好Makefile和my_test.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir simple_module</span><br><span class="line">export BASEINCLUDE&#x3D;&#x2F;root&#x2F;runninglinuxkernel_4.0</span><br><span class="line">vi Makefile</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BASEINCLUDE ?&#x3D; &#x2F;root&#x2F;runninglinuxkernel_4.0</span><br><span class="line"></span><br><span class="line">mytest-objs :&#x3D; my_test.o</span><br><span class="line">obj-m :&#x3D;  my_test.o</span><br><span class="line">path :&#x3D; &#x2F;root&#x2F;simple_module</span><br><span class="line"></span><br><span class="line">all : </span><br><span class="line">	$(MAKE) -C $(BASEINCLUDE) M&#x3D;$(path) modules;</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">	$(MAKE) -C $(BASEINCLUDE) SUBDIR&#x3D;$(PWD) clean;</span><br><span class="line">	rm -f *.ko;</span><br></pre></td></tr></table></figure>
<p>my_test.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;init.h&gt;</span><br><span class="line"></span><br><span class="line">static int __init my_test_init(void)&#123;</span><br><span class="line">    printk(&quot;My first kernel module init.\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit my_test_exit(void)&#123;</span><br><span class="line">    printk(&quot;Goodbye!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_test_init);</span><br><span class="line">module_exit(my_test_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;Kongo&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;Kongo&#39;s first kernel module!&quot;);</span><br><span class="line">MODULE_ALIAS(&quot;mytest&quot;);</span><br></pre></td></tr></table></figure>
<p>编译拷贝ko文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make </span><br><span class="line">cp my_test.ko ..&#x2F;runninglinuxkernel_4.0&#x2F;kmodule</span><br></pre></td></tr></table></figure>
<p>启动qemu</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;run.sh arm32</span><br></pre></td></tr></table></figure>
<p>装载ko</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insmod &#x2F;mnt&#x2F;my_test.ko</span><br></pre></td></tr></table></figure>
<p>卸载ko</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmmod my_test.ko</span><br></pre></td></tr></table></figure>

<h4 id="2-向内核模块传递参数"><a href="#2-向内核模块传递参数" class="headerlink" title="2.向内核模块传递参数"></a>2.向内核模块传递参数</h4><p>实验步骤和实验1相同，源代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;init.h&gt;</span><br><span class="line"></span><br><span class="line">static int debug &#x3D; 1;</span><br><span class="line">module_param(debug, int, 0644);</span><br><span class="line">MODULE_PARM_DESC(debug, &quot;enable debugging information!&quot;);</span><br><span class="line"></span><br><span class="line">#define dprintk(args...) \</span><br><span class="line">    if(debug)&#123; \</span><br><span class="line">        printk(KERN_DEBUG args); \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static int mytest &#x3D; 100;</span><br><span class="line">module_param(mytest, int, 0644);</span><br><span class="line">MODULE_PARM_DESC(mytest, &quot;test for module paramter&quot;);</span><br><span class="line"></span><br><span class="line">static int __init my_test_init(void)&#123;</span><br><span class="line">    dprintk(&quot;My first kernel module init.\n&quot;);</span><br><span class="line">    dprintk(&quot;moduel parameter&#x3D;%d\n&quot;,mytest);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit my_test_exit(void)&#123;</span><br><span class="line">    printk(&quot;Goodbye!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_test_init);</span><br><span class="line">module_exit(my_test_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;Kongo&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;Kongo&#39;s first kernel module!&quot;);</span><br><span class="line">MODULE_ALIAS(&quot;mytest&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><h4 id="1-简单的字符设备"><a href="#1-简单的字符设备" class="headerlink" title="1.简单的字符设备"></a>1.简单的字符设备</h4><p>my_demodev.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;init.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;fs.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;uaccess.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;cdev.h&gt;</span><br><span class="line"></span><br><span class="line">#define DEMO_NAME &quot;my_demo_dev&quot;</span><br><span class="line">static dev_t dev;</span><br><span class="line">static struct cdev *demo_cdev;</span><br><span class="line">static signed count &#x3D; 1;</span><br><span class="line"></span><br><span class="line">static int demodrv_open(struct inode *inode, struct file *file)&#123;</span><br><span class="line"></span><br><span class="line">    int major &#x3D; MAJOR(inode-&gt;i_rdev);</span><br><span class="line">    int minor &#x3D; MINOR(inode-&gt;i_rdev);</span><br><span class="line">    printk(&quot;%s: major&#x3D;%%d, minor&#x3D;%d\n&quot;, __func__, major, minor);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int demodrv_release(struct inode *inode, struct file *file)&#123;</span><br><span class="line">    printk(&quot;Release the dev.\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int demodrv_read(struct file *file, char __user *buf, size_t lbuf, loff_t *ppos)&#123;</span><br><span class="line">    printk(&quot;%s enter\n&quot;, __func__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int demodrv_write(struct file *file, char __user *buf, size_t count, loff_t *f_pos)&#123;</span><br><span class="line">    printk(&quot;%s enter\n&quot;, __func__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct file_operations demodrv_fops &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">    .open &#x3D; demodrv_open,</span><br><span class="line">    .release &#x3D; demodrv_release,</span><br><span class="line">    .read &#x3D; demodrv_read,</span><br><span class="line">    .write &#x3D; demodrv_write</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init simple_char_init(void)&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    ret &#x3D; alloc_chrdev_region(&amp;dev, 0, count, DEMO_NAME);</span><br><span class="line">    if (ret)&#123;</span><br><span class="line">        printk(&quot;Failed to allocate cha device region.\n&quot;);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    demo_cdev &#x3D; cdev_alloc();</span><br><span class="line">    if (!demo_cdev)&#123;</span><br><span class="line">        printk(&quot;Cdev_alloc failed.\n&quot;);</span><br><span class="line">        goto unregister_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cdev_init(demo_cdev, &amp;demodrv_fops);</span><br><span class="line">    ret &#x3D; cdev_add(demo_cdev, dev, count);</span><br><span class="line">    if(ret)&#123;</span><br><span class="line">        printk(&quot;Cdev_add failed\n&quot;);</span><br><span class="line">        goto cdev_fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(&quot;Succeeed register char device: %s\n&quot;, DEMO_NAME);</span><br><span class="line">    printk(&quot;Major number &#x3D; %d, minor number &#x3D; %d\n&quot;, MAJOR(dev), MINOR(dev));</span><br><span class="line"></span><br><span class="line">cdev_fail:</span><br><span class="line">    cdev_del(demo_cdev);</span><br><span class="line"></span><br><span class="line">unregister_chrdev:</span><br><span class="line">    unregister_chrdev_region(dev, count);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit simple_char_exit(void)&#123;</span><br><span class="line">    printk(&quot;Removing device\n&quot;);</span><br><span class="line"></span><br><span class="line">    if (demo_cdev)</span><br><span class="line">        cdev_del(demo_cdev);</span><br><span class="line">    </span><br><span class="line">    unregister_chrdev_region(dev, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(simple_char_init);</span><br><span class="line">module_exit(simple_char_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL v2&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;Kongo&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;Simple charater device!&quot;);</span><br></pre></td></tr></table></figure>

<p>test.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define DEMO_DEV_NAME &quot;&#x2F;dev&#x2F;demo_drv&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    char buffer[64];</span><br><span class="line">    int fd &#x3D; open(DEMO_DEV_NAME, O_RDONLY);</span><br><span class="line">    if (fd&lt;0)&#123;</span><br><span class="line">        printf(&quot;Open devices failed.&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    read(fd, buffer, 64);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第六章-系统调用"><a href="#第六章-系统调用" class="headerlink" title="第六章 系统调用"></a>第六章 系统调用</h3><h4 id="1-在ARM32上新增一个系统调用"><a href="#1-在ARM32上新增一个系统调用" class="headerlink" title="1.在ARM32上新增一个系统调用"></a>1.在ARM32上新增一个系统调用</h4><h5 id="1-添加补丁"><a href="#1-添加补丁" class="headerlink" title="(1)添加补丁"></a>(1)添加补丁</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd runninglinuxkernel_4.0&#x2F;</span><br><span class="line">git am rlk_lab&#x2F;rlk_basic&#x2F;chapter_6&#x2F;lab1&#x2F;0001-arm32-add-a-new-syscall-which-called-getpuid.patch</span><br></pre></td></tr></table></figure>
<ul>
<li>这里我们新添加的系统调用名称为<code>getpuid</code></li>
<li><code>getpuid</code>使用的系统调用号为<code>388</code></li>
</ul>
<p>此命令在arch/arm/include/uapi/unisid.h头文件中的417行添加了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define __NR_getpuid (__NR_SYSCALL_BASE+388)</span><br></pre></td></tr></table></figure>
<p>在arch/arm/include/unistd.h头文件中添加了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define __NR_syscalls (392)</span><br></pre></td></tr></table></figure>

<h5 id="2-编译内核"><a href="#2-编译内核" class="headerlink" title="(2)编译内核"></a>(2)编译内核</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># export ARCH&#x3D;arm</span><br><span class="line"># export CROSS_COMPILE&#x3D;arm-linux-gnueabi-</span><br><span class="line"># make vexpress_defconfig</span><br><span class="line"># make menuconfig</span><br><span class="line"># make bzImage -j4</span><br><span class="line"># make dtbs</span><br></pre></td></tr></table></figure>

<h5 id="3-编写应用程序并编译"><a href="#3-编写应用程序并编译" class="headerlink" title="(3)编写应用程序并编译"></a>(3)编写应用程序并编译</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cp rlk_lab&#x2F;rlk_basic&#x2F;chapter_6&#x2F;lab1&#x2F;test_getpuid_syscall.c kmodules&#x2F;test_getpuid_syscall.c</span><br><span class="line"># cd kmodules&#x2F;</span><br><span class="line"># arm-linux-gnueabi-gcc --static -o test_getpuid_syscall test_getpuid_syscall.c </span><br><span class="line"># cd ..</span><br></pre></td></tr></table></figure>

<h5 id="4-启动内核"><a href="#4-启动内核" class="headerlink" title="(4)启动内核"></a>(4)启动内核</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># .&#x2F;run.sh arm32</span><br></pre></td></tr></table></figure>

<h5 id="5-编写并运行应用程序"><a href="#5-编写并运行应用程序" class="headerlink" title="(5)编写并运行应用程序"></a>(5)编写并运行应用程序</h5><p>```</p>
<h1 id="cd-mnt"><a href="#cd-mnt" class="headerlink" title="cd /mnt"></a>cd /mnt</h1><p>/mnt # ./test_getpuid_syscall<br>call getpuid success, return pid = 809, uid = 0<br>/mnt # ./test_getpuid_syscall<br>call getpuid success, return pid = 810, uid = 0<br>/mnt # </p>
<h3 id="第七章-内存管理"><a href="#第七章-内存管理" class="headerlink" title="第七章 内存管理"></a>第七章 内存管理</h3><ul>
<li>vmalloc和kmalloc的区别</li>
<li>slab缓存的创建</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux内核</tag>
      </tags>
  </entry>
</search>
