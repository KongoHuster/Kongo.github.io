<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>三、Hexo 搭建个人博客系列：主题美化篇</title>
    <url>/2020/06/20/Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E7%AF%87/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/20/Nl8KL8.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">幻彩魔方</div>
</center>

<blockquote>
<p>本文搭建Hexo主要参考<a href="http://yearito.cn/tags/Hexo/" target="_blank" rel="noopener">Yearito’s Blog</a></p>
</blockquote>
<h4 id="一、修改博客字体"><a href="#一、修改博客字体" class="headerlink" title="一、修改博客字体"></a>一、修改博客字体</h4><p>在 Google Fonts 上找到心仪的字体，然后在主题配置文件中为不同的应用场景配置字体：</p>
<a id="more"></a>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # 外链字体库地址，例如 &#x2F;&#x2F;fonts.googleapis.com (默认值)</span><br><span class="line">  host:</span><br><span class="line"></span><br><span class="line">  # 全局字体，应用在 body 元素上</span><br><span class="line">  global:</span><br><span class="line">    external: true</span><br><span class="line">    family: Monda</span><br><span class="line"></span><br><span class="line">  # 标题字体 (h1, h2, h3, h4, h5, h6)</span><br><span class="line">  headings:</span><br><span class="line">    external: true</span><br><span class="line">    family: Roboto Slab</span><br><span class="line"></span><br><span class="line">  # 文章字体</span><br><span class="line">  posts:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line"></span><br><span class="line">  # Logo 字体</span><br><span class="line">  logo:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line"></span><br><span class="line">  # 代码字体，应用于 code 以及代码块</span><br><span class="line">  codes:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br></pre></td></tr></table></figure>

<h4 id="二、文章页末美化"><a href="#二、文章页末美化" class="headerlink" title="二、文章页末美化"></a>二、文章页末美化</h4><h5 id="为标签添加图标"><a href="#为标签添加图标" class="headerlink" title="为标签添加图标"></a>为标签添加图标</h5><p>默认情况下标签前缀是 # 字符，用户可以通过修改主题源码将标签的字符前缀改为图标前缀</p>
<p>在文章布局模板中找到文末标签相关代码段，将 # 换成 <i class="fa fa-tags"></i> 即可：</p>
<blockquote>
<p>themes\next\layout_macro\post.swig</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &lt;footer class&#x3D;&quot;post-footer&quot;&gt;</span><br><span class="line">    &#123;% if post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">      &lt;div class&#x3D;&quot;post-tags&quot;&gt;</span><br><span class="line">        &#123;% for tag in post.tags %&#125;</span><br><span class="line">-          &lt;a href&#x3D;&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel&#x3D;&quot;tag&quot;&gt;# &#123;&#123; tag.name &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">+          &lt;a href&#x3D;&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel&#x3D;&quot;tag&quot;&gt;&lt;i class&#x3D;&quot;fa fa-tags&quot;&gt;&lt;&#x2F;i&gt; &#123;&#123; tag.name &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    ...</span><br><span class="line">  &lt;&#x2F;footer&gt;</span><br></pre></td></tr></table></figure>

<h5 id="添加结束标记"><a href="#添加结束标记" class="headerlink" title="添加结束标记"></a>添加结束标记</h5><p>新建布局模板文件 post-end-tag.swig，添加如下代码：</p>
<blockquote>
<p>themes\next\layout_macro\post-end-tag.swig</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &lt;div style&#x3D;&quot;text-align:center;color:#bfbfbf;font-size:16px;&quot;&gt;</span><br><span class="line">      &lt;span&gt;-------- 本文结束 &lt;&#x2F;span&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;fa fa-&#123;&#123; config.post_end_tag.icon &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">      &lt;span&gt; 感谢阅读 --------&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>在文章布局模板中添加如下代码：</p>
<blockquote>
<p>themes\next\layout_macro\post</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;#####################&#125;</span><br><span class="line">&#123;### END POST BODY ###&#125;</span><br><span class="line">&#123;#####################&#125;</span><br><span class="line"></span><br><span class="line">+ &#123;% if config.post_end_tag.enabled and not is_index %&#125;</span><br><span class="line">+   &lt;div&gt;</span><br><span class="line">+     &#123;% include &#39;post-end-tag.swig&#39; %&#125;</span><br><span class="line">+   &lt;&#x2F;div&gt;</span><br><span class="line">+ &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include &#39;wechat-subscriber.swig&#39; %&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>在站点配置文件末尾添加如下代码：</p>
<blockquote>
<p>_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_end_tag:</span><br><span class="line">  enabled: true  # 是否开启文末的本文结束标记</span><br><span class="line">  icon: paw # 结束标记之间的图标</span><br></pre></td></tr></table></figure>
<p>重启服务器后即可在文末看到结束标记。</p>
<h4 id="三、页面加载进度条"><a href="#三、页面加载进度条" class="headerlink" title="三、页面加载进度条"></a>三、页面加载进度条</h4><p>当网络不好的时候可能会在打开站点或跳转文章时出现短暂的白屏，此时如果能有加载进度提示将会提高用户操作体验。</p>
<p>在根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-pace themes&#x2F;next&#x2F;source&#x2F;lib&#x2F;pace</span><br></pre></td></tr></table></figure>
<p>在主题配置文件中设置 pace: true。</p>
<p>默认提供了多种主题的进度条加载样式，有顶部提示的，有中间提示的，还有全页面遮挡提示的，个人认为默认的进度条效果就恰如其当，既能够在页面空白的时候起到加载作用，也不会因为太过花里胡哨而喧宾夺主，尤其是当你如果使用了不蒜子的站点访问统计的功能的时候，常常会遇到所有资源都加载完毕而不蒜子还在等待响应，如果这个时候在页面较显眼的位置出现一个停滞不前的进度条，很让人抓狂。</p>
<h4 id="四、添加动态背景"><a href="#四、添加动态背景" class="headerlink" title="四、添加动态背景"></a>四、添加动态背景</h4><p>Next 主题可以通过安装插件快速为站点添加不同效果的动态背景。</p>
<p>粒子漂浮聚合</p>
<p>该功能由 theme-next-canvas-nest 插件提供，在根目录下执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest themes&#x2F;next&#x2F;source&#x2F;lib&#x2F;canvas-nest</span><br></pre></td></tr></table></figure>
<p>然后在主题配置文件中设置 canvas_nest: true 即可。</p>
<p>Next v6.5.0 及以上版本支持更多的自定义选项：</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # 是否在移动端显示</span><br><span class="line">  color: &#39;0,0,255&#39; # 动态背景中线条的 RGB 颜色</span><br><span class="line">  opacity: 0.5 # 动态背景中线条透明度</span><br><span class="line">  zIndex: -1 # 动态背景的 z-index 属性值</span><br><span class="line">  count: 99 # 动态背景中线条数量</span><br></pre></td></tr></table></figure>

<h4 id="五、添加看板娘"><a href="#五、添加看板娘" class="headerlink" title="五、添加看板娘"></a>五、添加看板娘</h4><p>在站点根目录下执行以下命令安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure>
<p>在站点配置文件中添加以下下配置项</p>
<blockquote>
<p>_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Live2D</span><br><span class="line"># https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2d</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  pluginRootPath: live2dw&#x2F;</span><br><span class="line">  pluginJsPath: lib&#x2F;</span><br><span class="line">  pluginModelPath: assets&#x2F; Relative)</span><br><span class="line"></span><br><span class="line">  # 脚本加载源</span><br><span class="line">  scriptFrom: local # 默认从本地加载脚本</span><br><span class="line">  # scriptFrom: jsdelivr # 从 jsdelivr CDN 加载脚本</span><br><span class="line">  # scriptFrom: unpkg # 从 unpkg CDN 加载脚本</span><br><span class="line">  # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 从自定义地址加载脚本</span><br><span class="line">  tagMode: false # 只在有 &#123;&#123; live2d() &#125;&#125; 标签的页面上加载 &#x2F; 在所有页面上加载</span><br><span class="line">  log: false # 是否在控制台打印日志</span><br><span class="line"></span><br><span class="line">  # 选择看板娘模型</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-shizuku  # npm package的名字</span><br><span class="line">    # use: wanko # &#x2F;live2d_models&#x2F; 目录下的模型文件夹名称</span><br><span class="line">    # use: .&#x2F;wives&#x2F;wanko # 站点根目录下的模型文件夹名称</span><br><span class="line">    # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 自定义网络数据源</span><br><span class="line">  display:</span><br><span class="line">    position: left # 显示在左边还是右边</span><br><span class="line">    width: 100 # 宽度</span><br><span class="line">    height: 180 # 高度</span><br><span class="line">  mobile:</span><br><span class="line">    show: false</span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 0.7 # 默认透明度</span><br></pre></td></tr></table></figure>

<p>此时重启服务器暂时还看不到看板娘，需要手动下载或安装模型资源。可以从 <a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">hexo live2d</a> 模型预览 里找到你喜欢的角色，然后根据 live2d-widget-models 中提供的方法来下载模型数据.</p>
<p>例如通过以下命令下载模型 shizuku：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install live2d-widget-model-shizuku</span><br></pre></td></tr></table></figure>
<p>因为修改了站点配置文件，所以需要重启服务器才能预览模型效果。</p>
<p>如果设置了 live2d.tagMode: true，则可以在指定页面中插入以下标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; live2d() &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>只有拥有该标签的页面才会渲染 live2d 模型，这样以来就可以精确控制在哪些页面上显示看板娘了。</p>
<p>如果只想在一级菜单页面上显示看板娘，可以在 Header 模板中添加以下代码：</p>
<blockquote>
<p>themes\next\layout_partials\header\index.swig</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ &#123;% if is_index %&#125;</span><br><span class="line">+   &#123;&#123; live2d() &#125;&#125;</span><br><span class="line">+ &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="六、个性化回到顶部"><a href="#六、个性化回到顶部" class="headerlink" title="六、个性化回到顶部"></a>六、个性化回到顶部</h4><p>原理很简单，将 back-to-top 按钮添加图片背景，并添加 CSS3 动效即可。</p>
<p>首先，找到自己喜欢的图片素材放到 source\images\ 目录下。</p>
<p>你可以点击下方按钮下载本站所使用的小猫上吊素材（ 小猫咪这么可爱，当然要多放点孜然啦…）</p>
<p><a href="http://yearito.cn/images/scroll.png" target="_blank" rel="noopener">下载图片</a></p>
<p>然后在自定义样式文件中添加如下代码：</p>
<blockquote>
<p>themes\next\source\css\ _custom\custom.styl</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;自定义回到顶部样式</span><br><span class="line">.back-to-top &#123;</span><br><span class="line">  right: 60px;</span><br><span class="line">  width: 70px;  &#x2F;&#x2F;图片素材宽度</span><br><span class="line">  height: 900px;  &#x2F;&#x2F;图片素材高度</span><br><span class="line">  top: -900px;</span><br><span class="line">  bottom: unset;</span><br><span class="line">  transition: all .5s ease-in-out;</span><br><span class="line">  background: url(&quot;&#x2F;images&#x2F;scroll.png&quot;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;隐藏箭头图标</span><br><span class="line">  &gt; i &#123;</span><br><span class="line">    display: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;.back-to-top-on &#123;</span><br><span class="line">    bottom: unset;</span><br><span class="line">    top: 100vh &lt; (900px + 200px) ? calc( 100vh - 900px - 200px ) : 0px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷新浏览器即可预览效果。</p>
<h4 id="七、鼠标点击特效"><a href="#七、鼠标点击特效" class="headerlink" title="七、鼠标点击特效"></a>七、鼠标点击特效</h4><p>点击下方按钮下载相应的脚本，并置于 themes\next\source\js\cursor\ 目录下：</p>
<p><a href="https://script-1256884783.file.myqcloud.com/cursor/fireworks.js" target="_blank" rel="noopener">下载</a></p>
<p>在主题自定义布局文件中添加以下代码：</p>
<blockquote>
<p>themes\next\layout_custom\custom.swig</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# 鼠标点击特效 #&#125;</span><br><span class="line">&#123;% if theme.cursor_effect &#x3D;&#x3D; &quot;fireworks&quot; %&#125;</span><br><span class="line">  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;fireworks.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect &#x3D;&#x3D; &quot;explosion&quot; %&#125;</span><br><span class="line">  &lt;canvas class&#x3D;&quot;fireworks&quot; style&#x3D;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;animejs&#x2F;2.2.0&#x2F;anime.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;explosion.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect &#x3D;&#x3D; &quot;love&quot; %&#125;</span><br><span class="line">  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;love.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect &#x3D;&#x3D; &quot;text&quot; %&#125;</span><br><span class="line">  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;text.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">themes\next\layout\_layout.swig</span><br><span class="line">      ...</span><br><span class="line">      &#123;% include &#39;_third-party&#x2F;exturl.swig&#39; %&#125;</span><br><span class="line">      &#123;% include &#39;_third-party&#x2F;bookmark.swig&#39; %&#125;</span><br><span class="line">      &#123;% include &#39;_third-party&#x2F;copy-code.swig&#39; %&#125;</span><br><span class="line"></span><br><span class="line">+     &#123;% include &#39;_custom&#x2F;custom.swig&#39; %&#125;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">  &lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>在主题配置文件中添加以下代码：</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mouse click effect: fireworks | explosion | love | text</span><br><span class="line">cursor_effect: fireworks</span><br></pre></td></tr></table></figure>
<p>这样即可在配置文件中一键快速切换鼠标点击特效。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>二、Hexo 搭建个人博客系列：写作技巧篇</title>
    <url>/2020/06/13/Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7%E7%AF%87/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/20/NlQqVH.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">梦境夜空</div>
</center>

<blockquote>
<p>本文搭建Hexo主要参考<a href="http://yearito.cn/tags/Hexo/" target="_blank" rel="noopener">Yearito’s Blog</a></p>
</blockquote>
<h3 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h3><p>在博客目录下执行如下命令新建一篇文章</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果未指定文章的布局（layout），则默认使用 post 布局，生成的文档存放于 source_posts\ 目录下，打开后使用 Markdown 语法进行写作，保存后刷新浏览器即可看到文章。</p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>布局是什么概念呢，你可以理解为新建文档时的一个模板，基于布局生成的文档将会继承布局的样式。</p>
<p>Hexo 默认有三种布局：post、 page 和 draft，用户可以在 scaffolds 目录下新建文档来自定义布局格式，还可以修改站点配置文件中的 default_layout参数来指定生成文档时的默认布局。</p>
<h4 id="文章（post）"><a href="#文章（post）" class="headerlink" title="文章（post）"></a>文章（post）</h4><p>基于 post 布局生成的文档存在于 source_posts\ 目录下，该目录下的文档会作为博客正文显示在网站中。</p>
<h4 id="页面（page）"><a href="#页面（page）" class="headerlink" title="页面（page）"></a>页面（page）</h4><p>page 布局用于生成类似 首页 和 归档 这样的页面。默认的 Next 主题样式中只包含首页和归档这两个链接，可以通过修改主题配置文件中的 menu 字段来新增更多页面菜单。</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  about: &#x2F;about&#x2F; || user</span><br><span class="line">+ tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">+ categories: &#x2F;categories&#x2F; || th</span><br><span class="line">+ archives: &#x2F;archives&#x2F; || archive</span><br></pre></td></tr></table></figure>

<h4 id="草稿（draft）"><a href="#草稿（draft）" class="headerlink" title="草稿（draft）"></a>草稿（draft）</h4><p>draft 布局用于创建草稿，生成的文档存在于 source_drafts\ 目录中，默认配置下将不会把该目录下的文档渲染到网站中。</p>
<p>通过以下命令将草稿发布为正式文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo publish &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>该命令会将 source_drafts\ 目录下</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>四、Hexo 搭建个人博客系列：进阶设置篇</title>
    <url>/2020/06/21/Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%E8%BF%9B%E9%98%B6%E8%AE%BE%E7%BD%AE%E7%AF%87/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/21/Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%E8%BF%9B%E9%98%B6%E8%AE%BE%E7%BD%AE%E7%AF%87/星辰.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">醉美星辰</div>
</center>

<blockquote>
<p>本文搭建Hexo主要参考<a href="http://yearito.cn/tags/Hexo/" target="_blank" rel="noopener">Yearito’s Blog</a></p>
</blockquote>
<h4 id="一、后台管理界面"><a href="#一、后台管理界面" class="headerlink" title="一、后台管理界面"></a>一、后台管理界面</h4><a id="more"></a>
<p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-admin</span><br></pre></td></tr></table></figure>
<p>浏览器访问localhost:4000/admin</p>
<h4 id="二、站点访问量统计"><a href="#二、站点访问量统计" class="headerlink" title="二、站点访问量统计"></a>二、站点访问量统计</h4><p>在页脚布局模板文件首行添加如下代码：</p>
<blockquote>
<p>themes\next\layout_partial\footer.swig</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>在文件末尾添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;br&gt;</span><br><span class="line">Total &lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt; views.</span><br><span class="line">&lt;br&gt;</span><br><span class="line">您是闳的第&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;个小伙伴</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;span id&#x3D;&quot;busuanzi_value_page_pv&quot;&gt;&lt;&#x2F;span&gt; Hits</span><br></pre></td></tr></table></figure>

<h4 id="三、站点及文章字数统计"><a href="#三、站点及文章字数统计" class="headerlink" title="三、站点及文章字数统计"></a>三、站点及文章字数统计</h4><p>在根目录下执行如下命令安装相关依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<p>启用该功能需要同时修改站点配置文件和主题配置文件。</p>
<p>将如下配置项添加到站点配置文件中，这些配置项主要用于控制每项统计信息是否显示。</p>
<blockquote>
<p>_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true # 统计单篇文章字数</span><br><span class="line">  time: false # 取消估算单篇文章阅读时间</span><br><span class="line">  total_symbols: true # 统计站点总字数</span><br><span class="line">  total_time: false # 取消估算站点总阅读时间</span><br></pre></td></tr></table></figure>
<p>在主题配置文件中做如下修改，这些配置项主要用于控制统计信息的显示样式。</p>
<blockquote>
<p>themes\next\ _config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: false # 统计信息不换行显示</span><br><span class="line">  item_text_post: true # 文章统计信息中是否显示“本文字数&#x2F;阅读时长”等描述文字</span><br><span class="line">  item_text_total: true # 站点统计信息中是否显示“本文字数&#x2F;阅读时长”等描述文字</span><br><span class="line">  awl: 4 # Average Word Length：平均字符长度</span><br><span class="line">  wpm: 275 # Words Per Minute：阅读速度</span><br></pre></td></tr></table></figure>
<p>汉字的平均字符长度为 1.5，如果在文章中使用纯中文进行写作（没有混杂英文），那么推荐设置 awl: 2 及 wpm: 300，但是如果文章中存在英文，建议设置 awl: 4 及 wpm: 275。</p>
<h4 id="四、添加评论功能"><a href="#四、添加评论功能" class="headerlink" title="四、添加评论功能"></a>四、添加评论功能</h4><p>Next 已经内置了 Valine 组件，在主题配置文件中开启评论功能即可，同时，由于 Valine 是基于 Leancloud 提供后端服务的，所以需要填写 LeanCloud 的 App ID 和 App Key。</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid:  ***&lt;app_id***</span><br><span class="line">  appkey: ***&lt;app_key&gt;***</span><br><span class="line">  notify: false  # 收到新评论是否邮件通知</span><br><span class="line">  verify: false  # 是否开启验证码</span><br><span class="line">  placeholder:  # 默认填充文字</span><br><span class="line">  avatar: mm  # 设置默认评论列表</span><br><span class="line">  guest_info: nick,mail  # 评论区头部表单</span><br><span class="line">  pageSize: 10  # 每页评论数</span><br><span class="line">  visitor: true  # 同时开启文章阅读次数统计</span><br></pre></td></tr></table></figure>

<h4 id="五、添加打赏功能"><a href="#五、添加打赏功能" class="headerlink" title="五、添加打赏功能"></a>五、添加打赏功能</h4><p>启用主题配置文件中的打赏相关字段，并将个人收款码图片置于 themes\next\source\images\ 目录下，注意保持图片命名与配置文件中一致：</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  # If true, reward will be displayed in every article by default.</span><br><span class="line">  enable: true</span><br><span class="line">  animation: true</span><br><span class="line">  comment: 你的支持就是我前进的动力</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  #wechatpay: &#x2F;images&#x2F;wechatpay.png</span><br><span class="line">  #alipay: &#x2F;images&#x2F;alipay.png</span><br><span class="line">  #paypal: &#x2F;images&#x2F;paypal.png</span><br><span class="line">  #bitcoin: &#x2F;images&#x2F;bitcoin.png</span><br><span class="line">  wechatpay: &#x2F;images&#x2F;wechatpay.jpg</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.jpg</span><br></pre></td></tr></table></figure>

<h4 id="六、添加图片灯箱"><a href="#六、添加图片灯箱" class="headerlink" title="六、添加图片灯箱"></a>六、添加图片灯箱</h4><p>添加灯箱功能，实现点击图片后放大聚焦图片，并支持幻灯片播放、全屏播放、缩略图、快速分享到社交媒体等，该功能由 fancyBox 提供<br>在根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fancybox3 themes&#x2F;next&#x2F;source&#x2F;lib&#x2F;fancybox</span><br></pre></td></tr></table></figure>
<p>在主题配置文件中设置 fancybox: true：</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fancybox: true</span><br></pre></td></tr></table></figure>

<h4 id="七、文章加密访问"><a href="#七、文章加密访问" class="headerlink" title="七、文章加密访问"></a>七、文章加密访问</h4><p>该功能由 hexo-blog-encrypt 插件提供。</p>
<p>在站点根目录中执行以下命令安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-blog-encrypt --save</span><br></pre></td></tr></table></figure>
<p>在站点配置文件中添加如下字段：</p>
<blockquote>
<p>_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">encrypt:</span><br><span class="line">  enable: true</span><br><span class="line">  default_abstract: 此文章已被加密，需要输入密码访问。  &#x2F;&#x2F;首页文章列表中加密文章的默认描述文案</span><br><span class="line">  default_message: 请输入密码以阅读这篇私密文章。  &#x2F;&#x2F;文章详情页的密码输入框上的默认描述文案</span><br></pre></td></tr></table></figure>
<p>然后在文章 Front-Matter 中添加 password 字段用于设置文章访问密码。重启服务器，这个时候可能需要经历较长一段时间的加密过程，请耐心等待，加密完成后刷新页面将会显示密码输入框，输入密码后才能继续访问文章内容。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>一、搭建个人博客系列：基础建站篇</title>
    <url>/2020/06/13/Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%99%E7%AF%87/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img.pc841.com/2018/0730/20180730081702510.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">《逆水寒》</div>
</center>

<blockquote>
<p>本文搭建Hexo主要参考<a href="http://yearito.cn/tags/Hexo/" target="_blank" rel="noopener">Yearito’s Blog</a></p>
</blockquote>
<p>Hexo 是一个高效简洁的静态博客框架，支持 Markdown 写作语法，插件丰富，主题优雅，部署方便。目前已成为多数人博客建站的选择。</p>
<a id="more"></a>
<p>本文为 Hexo 搭建个人博客系列中的第一篇。第一章中介绍了如何在Mac本地搭建 Hexo 博客，第二章中介绍了如何安装使用 Next 主题，第三章和第四章分别介绍了针对于站点和文章详情页的一些基础优化方案。</p>
<h3 id="一、开始使用"><a href="#一、开始使用" class="headerlink" title="一、开始使用"></a>一、开始使用</h3><p>下载 npm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew install npm</span><br></pre></td></tr></table></figure>
<p>在命令行中通过 npm 来安装 Hexo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>-g 表示全局安装，会将 Hexo 命令加入环境变量中，以使其在 cmd 下有效。</p>
<p>新建博客目录，然后在该路径下执行初始化命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p>在根目录下执行如下命令启动 hexo 的内置 Web 服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>该命令还会启动一个简易的 Web 服务器用于提供对内存中网页资源的访问（工作机制类似于 webpack-dev-server），Web 服务器默认监听 4000 端口，用户可在浏览器中通过地址 localhost:4000 访问博客。</p>
<p><a href="https://imgchr.com/i/tvZgrF" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/13/tvZgrF.jpg" alt="tvZgrF.jpg"></a></p>
<center>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">Hexo 默认主题</div>
</center>


<p>此外，可以通过添加命令行参数来支持高级用法：</p>
<ul>
<li>当 4000 端口已被其他应用占用时，可以添加 -p / –port 参数来设置 Web 服务监听的端口号，如hexo s -p 8000</li>
<li>默认情况下，hexo 监听项目目录的文件变化，用户对于项目文件的任何改动都会触发实时解析编译并更新内存中的网页资源，也就是说，用户在本地修改后刷新浏览器就可以看到改动效果。如果不希望 hexo 监听项目目录的文件变化，可以添加 -s / –static 参数，这样本地改动就不会触发 hexo 实时解析更新。</li>
</ul>
<h3 id="二、更换-Next-主题"><a href="#二、更换-Next-主题" class="headerlink" title="二、更换 Next 主题"></a>二、更换 Next 主题</h3><p>Next 作为一款符合广大程序员审美的主题，还是有着较高的出场率的。Hexo 中切换主题的方式非常简单，只需要将主题文件拷贝至根目录下的 themes 文件夹中， 然后修改 _config.yml 文件中的 theme 字段即可。</p>
<p>在根目录下执行以下命令下载主题文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>打开站点配置文件，将 theme 字段的值修改为 next。</p>
<blockquote>
<p>_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>这个时候刷新浏览器页面并不会发生变化，需要重启服务器并刷新才能使主题生效。</p>
<p><img src="https://s1.ax1x.com/2020/06/13/tvQYJH.jpg" alt="tvQYJH.jpg"></p>
<center>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">Hexo next主题</div>
</center>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果重启服务器仍无效，尝试使用 hexo clean 清除缓存</span><br></pre></td></tr></table></figure>

<p>Next 默认主题风格为 Muse，用户可以在主题配置文件中修改 scheme 字段以选择自己喜欢的主题风格：</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<h3 id="三、站点优化"><a href="#三、站点优化" class="headerlink" title="三、站点优化"></a>三、站点优化</h3><h4 id="1-完善站点基础信息"><a href="#1-完善站点基础信息" class="headerlink" title="1.完善站点基础信息"></a>1.完善站点基础信息</h4><p>在站点配置文件中完善网站基本信息：</p>
<blockquote>
<p>_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Yearito&#39;s Blog  # 站点名称</span><br><span class="line">description: Stay hungry, stay foolish.  # 站点描述</span><br><span class="line">language: zh-CN # 设置网站语言为简体中文</span><br><span class="line">author: yearito  # 作者名称</span><br></pre></td></tr></table></figure>
<h4 id="2-修改站点页脚"><a href="#2-修改站点页脚" class="headerlink" title="2.修改站点页脚"></a>2.修改站点页脚</h4><p>在主题配置文件中修改网站页脚信息：</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:  # 底部信息区</span><br><span class="line">  since: 2018  # 建站时间</span><br><span class="line">  icon:</span><br><span class="line">    name: heart   # 图标名称</span><br><span class="line">    animated: true   # 开启动画</span><br><span class="line">    color: &quot;#ff0000&quot;   # 图标颜色</span><br><span class="line"></span><br><span class="line">  powered:</span><br><span class="line">    enable: true  # 显示由 Hexo 强力驱动</span><br><span class="line">    version: false  # 隐藏 Hexo 版本号</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    enable: true  # 显示所用的主题名称</span><br><span class="line">    version: false  # 隐藏主题版本号</span><br></pre></td></tr></table></figure>

<h4 id="3-取消数字编号"><a href="#3-取消数字编号" class="headerlink" title="3.取消数字编号"></a>3.取消数字编号</h4><p>在主题配置文件中关闭目录中的数字编号：</p>
<blockquote>
<p>themes\next_config.yml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  number: false  # 关闭目录中的数字编号</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 网络互连.md</title>
    <url>/2018/10/06/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E4%BA%92%E8%BF%9E.md/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/21/N8NY7t.jpg">
    <br>
</center>

<h2 id="一、-什么是交换机"><a href="#一、-什么是交换机" class="headerlink" title="一、 什么是交换机"></a>一、 什么是交换机</h2><ul>
<li>有多个输入端和多个输出端的设备</li>
<li>可将分组或数据帧从一个输入端口传输到一个或多个输出端口</li>
</ul>
<a id="more"></a>
<h2 id="二、交换网络"><a href="#二、交换网络" class="headerlink" title="二、交换网络"></a>二、交换网络</h2><h3 id="1-星形拓扑优点"><a href="#1-星形拓扑优点" class="headerlink" title="1.星形拓扑优点"></a>1.星形拓扑优点</h3><ul>
<li>构建网络链接大量主机</li>
<li>构建网络覆盖大片地理区域</li>
<li>增加新主机不会影响现有主机的性能</li>
</ul>
<h3 id="2-分组交换网络分类"><a href="#2-分组交换网络分类" class="headerlink" title="2.分组交换网络分类"></a>2.分组交换网络分类</h3><ul>
<li>电话网络: 电路交换网络</li>
<li>计算机网络: 分组交换网络</li>
</ul>
<h3 id="3-交换-转发"><a href="#3-交换-转发" class="headerlink" title="3.交换/转发"></a>3.交换/转发</h3><h4 id="（1）三种方法"><a href="#（1）三种方法" class="headerlink" title="（1）三种方法"></a>（1）三种方法</h4><ul>
<li>数据报, 无连接 </li>
<li>虚电路, 面向连接（VCI 具有”链路局部作用域”, 而非全局意义<br>）</li>
<li>源路由（源节点为每一个分组提供网络交换分组时所需的路由信息<br>）</li>
</ul>
<h3 id="4-网桥和局域网交换机"><a href="#4-网桥和局域网交换机" class="headerlink" title="4.网桥和局域网交换机"></a>4.网桥和局域网交换机</h3><h4 id="（1）透明网桥"><a href="#（1）透明网桥" class="headerlink" title="（1）透明网桥"></a>（1）透明网桥</h4><ul>
<li>问题：如何自适应构造转发表?</li>
<li>动机：根据数据帧转发过程自学习构造转发表</li>
<li>解决方案：逆向学习、主机与端口的映射关系学习</li>
</ul>
<h4 id="（2）虚拟局域网-VLAN"><a href="#（2）虚拟局域网-VLAN" class="headerlink" title="（2）虚拟局域网 (VLAN)"></a>（2）虚拟局域网 (VLAN)</h4><ul>
<li>每一个虚拟局域网分配一个标识符</li>
<li>只有两个网段的标识符相同时, 才能完成数据帧的转发 </li>
</ul>
<h2 id="三、互联网络"><a href="#三、互联网络" class="headerlink" title="三、互联网络"></a>三、互联网络</h2><h3 id="1-什么是互联网"><a href="#1-什么是互联网" class="headerlink" title="1.什么是互联网?"></a>1.什么是互联网?</h3><ul>
<li>“单一”网络的互联集合</li>
<li>视为“网络的网络”: 由许多较小的网络构成</li>
<li>范例: Internet, 当今应用最为广泛的全球性互联网</li>
</ul>
<h3 id="2-服务模型"><a href="#2-服务模型" class="headerlink" title="2.服务模型"></a>2.服务模型</h3><ul>
<li>数据报的一种服务模型</li>
<li>数据流的一种服务模型</li>
</ul>
<h3 id="3-IP服务模型"><a href="#3-IP服务模型" class="headerlink" title="3. IP服务模型"></a>3. IP服务模型</h3><h4 id="分段与重组"><a href="#分段与重组" class="headerlink" title="分段与重组"></a>分段与重组</h4><ul>
<li>主机按照与之直接相连的网络的MTU发送分组</li>
<li>分段重组由目的主机完成</li>
</ul>
<h4 id="网络层的两大核心功能"><a href="#网络层的两大核心功能" class="headerlink" title="网络层的两大核心功能"></a>网络层的两大核心功能</h4><ul>
<li>转发: 将路由器输入端口收到的分组从正确的输出端口发送出去</li>
<li>路由选择: 决定分组从源节点到达目的节点的路径</li>
</ul>
<h3 id="4-全球互联网"><a href="#4-全球互联网" class="headerlink" title="4.全球互联网"></a>4.全球互联网</h3><h4 id="编址方案"><a href="#编址方案" class="headerlink" title="编址方案"></a>编址方案</h4><ul>
<li>Flat 扁平化编址方案</li>
<li>Hierarchy 层次化编址方案</li>
</ul>
<h4 id="层次化地址空间"><a href="#层次化地址空间" class="headerlink" title="层次化地址空间"></a>层次化地址空间</h4><h3 id="5-子网划分"><a href="#5-子网划分" class="headerlink" title="5.子网划分"></a>5.子网划分</h3><ul>
<li>寻址: 子网掩码</li>
<li>IP 转发</li>
</ul>
<h3 id="6-无分类路由选择"><a href="#6-无分类路由选择" class="headerlink" title="6.无分类路由选择"></a>6.无分类路由选择</h3><p>问题：IP地址固定结构的低效性</p>
<p>动机：IP地址不采用固定的分类结构</p>
<p>解决方案：CIDR 汇聚路由</p>
<h3 id="6-无分类路由选择-CIDR"><a href="#6-无分类路由选择-CIDR" class="headerlink" title="6.无分类路由选择(CIDR)"></a>6.无分类路由选择(CIDR)</h3><ul>
<li>最长前缀匹配</li>
</ul>
<h3 id="7-地址转换"><a href="#7-地址转换" class="headerlink" title="7.地址转换"></a>7.地址转换</h3><ul>
<li>ARP工作原理:ip地址到屋里地址转换的问题</li>
</ul>
<h3 id="8-动态主机配置协议-DHCP"><a href="#8-动态主机配置协议-DHCP" class="headerlink" title="8.动态主机配置协议 (DHCP)"></a>8.动态主机配置协议 (DHCP)</h3><h3 id="9-DHCP-工作原理"><a href="#9-DHCP-工作原理" class="headerlink" title="9.DHCP 工作原理"></a>9.DHCP 工作原理</h3><h3 id="10-ICMP"><a href="#10-ICMP" class="headerlink" title="10.ICMP"></a>10.ICMP</h3><ul>
<li>ICMP分组格式</li>
<li>ICMP的应用: traceroute</li>
</ul>
<h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><ul>
<li>路由表和转发表</li>
<li>本节讨论小到中型网络的路由选择问题, 而非整个Internet的.</li>
</ul>
<h3 id="1、用图表示网络"><a href="#1、用图表示网络" class="headerlink" title="1、用图表示网络"></a>1、用图表示网络</h3><ul>
<li>节点: 路由器</li>
<li>边: 链路</li>
<li>寻找两个节点之间较低成本的路径的问题</li>
</ul>
<h3 id="2、距离向量-RIP"><a href="#2、距离向量-RIP" class="headerlink" title="2、距离向量 (RIP)"></a>2、距离向量 (RIP)</h3><h4 id="设计选项"><a href="#设计选项" class="headerlink" title="设计选项"></a>设计选项</h4><ul>
<li>如何获得拓扑信息</li>
<li>什么时候分发拓扑信息</li>
</ul>
<h4 id="距离向量路由选择"><a href="#距离向量路由选择" class="headerlink" title="距离向量路由选择"></a>距离向量路由选择</h4><h4 id="无穷计算问题的解决方案"><a href="#无穷计算问题的解决方案" class="headerlink" title="无穷计算问题的解决方案"></a>无穷计算问题的解决方案</h4><h3 id="3、链路状态-OSPF"><a href="#3、链路状态-OSPF" class="headerlink" title="3、链路状态(OSPF)"></a>3、链路状态(OSPF)</h3><ul>
<li>可靠洪泛</li>
<li>路由计算 </li>
<li>OSPF 协议</li>
</ul>
<h3 id="4、路由评价指标"><a href="#4、路由评价指标" class="headerlink" title="4、路由评价指标"></a>4、路由评价指标</h3>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 TCP</title>
    <url>/2018/10/06/%E7%AC%AC%E4%BA%94%E7%AB%A0%20TCP/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/21/N8Ur8O.jpg">

</center>

<!-- <center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="./InterNet/5.jpg">
</center> -->

<h2 id="一、拥塞"><a href="#一、拥塞" class="headerlink" title="一、拥塞"></a>一、拥塞</h2><h4 id="1-当网络负载持续大于其承载能力则发生拥塞"><a href="#1-当网络负载持续大于其承载能力则发生拥塞" class="headerlink" title="1.当网络负载持续大于其承载能力则发生拥塞"></a>1.当网络负载持续大于其承载能力则发生拥塞</h4><h4 id="2-拥塞现象的体现"><a href="#2-拥塞现象的体现" class="headerlink" title="2.拥塞现象的体现"></a>2.拥塞现象的体现</h4><ul>
<li>持续的分组丢失</li>
<li>分组时延不断增加</li>
</ul>
<a id="more"></a>

<h2 id="二、资源分配"><a href="#二、资源分配" class="headerlink" title="二、资源分配"></a>二、资源分配</h2><h3 id="1-网络模型"><a href="#1-网络模型" class="headerlink" title="1. 网络模型"></a>1. 网络模型</h3><ul>
<li>分组交换网</li>
<li>无连接流</li>
<li>服务模型</li>
</ul>
<h3 id="2-资源分配性能评估指标"><a href="#2-资源分配性能评估指标" class="headerlink" title="2.资源分配性能评估指标"></a>2.资源分配性能评估指标</h3><p>能力 = 吞吐量/时延</p>
<ul>
<li>吞吐量</li>
<li>时延</li>
</ul>
<h3 id="3-拥塞控制方法分类"><a href="#3-拥塞控制方法分类" class="headerlink" title="3.拥塞控制方法分类"></a>3.拥塞控制方法分类</h3><ul>
<li>端到端拥塞控制</li>
<li>网络协助拥塞控制</li>
</ul>
<h2 id="三、排队规则"><a href="#三、排队规则" class="headerlink" title="三、排队规则"></a>三、排队规则</h2><h3 id="1-排队规则-FIFO"><a href="#1-排队规则-FIFO" class="headerlink" title="1.排队规则: FIFO"></a>1.排队规则: FIFO</h3><ul>
<li>调度算法 vs 缓存管理</li>
<li>FIFO: First-In-First-Out / FCFS : First-Come-First-Served</li>
<li>缓存管理: 分组丢弃策略</li>
</ul>
<h3 id="2-排队规则-优先调度"><a href="#2-排队规则-优先调度" class="headerlink" title="2.排队规则: 优先调度"></a>2.排队规则: 优先调度</h3><ul>
<li>优先传输高优先级队列中的分组</li>
<li>不同类型的流量具有不同的优先级</li>
</ul>
<h3 id="3-排队规则-循环调度"><a href="#3-排队规则-循环调度" class="headerlink" title="3.排队规则: 循环调度"></a>3.排队规则: 循环调度</h3><ul>
<li>分组被分成不同类别(与优先级排队一样)</li>
<li>在类之间不存在严格的服务优先级，循环调度器在这些类之间轮流提供服务。 </li>
</ul>
<h3 id="4-排队规则-加权公平排队调度"><a href="#4-排队规则-加权公平排队调度" class="headerlink" title="4.排队规则:加权公平排队调度"></a>4.排队规则:加权公平排队调度</h3><ul>
<li>分组分类，在每个类的等待区域排队, 调度器循环为各类分组提供服务</li>
<li>每个类被分配一个加权，因此每一类在任何时间间隔内可能得到不同数量的服务</li>
<li>模拟比特级的循环调度，计算每个分组的发送完毕时间Fi, 并按照Fi的先后时间发送分组</li>
</ul>
<h2 id="四、TCP-拥塞控制"><a href="#四、TCP-拥塞控制" class="headerlink" title="四、TCP 拥塞控制"></a>四、TCP 拥塞控制</h2><h3 id="1-两个基本问题"><a href="#1-两个基本问题" class="headerlink" title="1.两个基本问题"></a>1.两个基本问题</h3><ul>
<li>如何察觉网络拥塞?<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以超时作为网络拥塞的标志</span><br></pre></td></tr></table></figure></li>
<li>如何调整发送速率?<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP维护一个CongestionWindow 变量</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-接收窗口-vs-拥塞窗口"><a href="#2-接收窗口-vs-拥塞窗口" class="headerlink" title="2.接收窗口 vs 拥塞窗口"></a>2.接收窗口 vs 拥塞窗口</h3><ul>
<li>流量控制</li>
<li>拥塞控制</li>
<li>不同的概念, 但是采用类似的机制</li>
</ul>
<h3 id="3-TCP的两种丢包"><a href="#3-TCP的两种丢包" class="headerlink" title="3.TCP的两种丢包"></a>3.TCP的两种丢包</h3><ul>
<li>超时</li>
<li>三个重复的ACK</li>
</ul>
<h3 id="4-快速重传与快速恢复"><a href="#4-快速重传与快速恢复" class="headerlink" title="4.快速重传与快速恢复"></a>4.快速重传与快速恢复</h3><h3 id="5-TCP的发展"><a href="#5-TCP的发展" class="headerlink" title="5.TCP的发展"></a>5.TCP的发展</h3><ul>
<li>基于简单滑动窗口的流量控制机制.</li>
<li>慢启动, 拥塞避免, 快速重传.</li>
<li>快速恢复.</li>
<li>对快速重传进行了修订.</li>
</ul>
<h3 id="6-拥塞避免"><a href="#6-拥塞避免" class="headerlink" title="6.拥塞避免"></a>6.拥塞避免</h3><ul>
<li>DECbit</li>
<li>RED</li>
<li>基于源</li>
</ul>
<h2 id="五、服务质量-QoS"><a href="#五、服务质量-QoS" class="headerlink" title="五、服务质量(QoS)"></a>五、服务质量(QoS)</h2><h3 id="1、应用需求"><a href="#1、应用需求" class="headerlink" title="1、应用需求"></a>1、应用需求</h3><ul>
<li>多媒体应用和服务质量</li>
<li>多媒体网络应用 </li>
<li>点播流媒体音频和视频 </li>
<li>存储式流媒体音频和视频</li>
<li>直播流媒体音频和视频</li>
</ul>
<h3 id="2-区分服务-EF、AF"><a href="#2-区分服务-EF、AF" class="headerlink" title="2.区分服务(EF、AF)"></a>2.区分服务(EF、AF)</h3><ul>
<li>提供多个服务等级</li>
<li>音频应用和FTP传输</li>
<li>区分服务(DiffServ)</li>
<li>边缘路由器分组标记</li>
<li>分类和调节</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业,难舍喻家山</title>
    <url>/2020/06/21/%E6%AF%95%E4%B8%9A-%E9%9A%BE%E8%88%8D%E5%96%BB%E5%AE%B6%E5%B1%B1/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/21/%E6%AF%95%E4%B8%9A-%E9%9A%BE%E8%88%8D%E5%96%BB%E5%AE%B6%E5%B1%B1/山川岁月.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">山川岁月</div>
</center>

<center>文 |  易子闳</center> 

<p>&emsp;&emsp;弃我去者，昨日之日不可留；乱我心者，今日之日多烦忧。坐上了南下的动车，在车上思绪万千。因为疫情，我们只有短短的三日回学校毕业，没有想象中的热闹与繁华，只有满眼的落寞与冷清。回学校办了手续，独自骑上电动车，满富仪式感地游览校园，不知怎的，思绪如流水般流淌，泪水和雨水在眼眸交织，慢慢回忆过往，慢慢与喻家山告别。</p>
<a id="more"></a>
<p>&emsp;&emsp;子在川上曰：逝者如斯乎，不舍昼夜。多少人的青春留在了喻家山下，多少的回忆成了过往，有多少想说的话，多少想表达的情感，都化成了朋友圈一张张或哭或笑的照片，都揉进了一首首或慷慨激昂或低沉婉转的歌曲里。历史，对于旁观者只是一段故事，而对于亲历者却是数不尽的喜悦与感伤。分享之人，必有想说之事，可未必所有人都会停留听你诉说，对过客来说，你说的是故事，可对你来说却是四年的轰轰烈烈的时光呀。光阴何尝不是一条河流，我们伫立在河中央，河水从身旁流过，带着丝丝无情与坚定，无论我们如何努力，它还是义无反顾地流走了。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/21/%E6%AF%95%E4%B8%9A-%E9%9A%BE%E8%88%8D%E5%96%BB%E5%AE%B6%E5%B1%B1/时间倒影.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">时间倒影</div>
</center>

<p>&emsp;&emsp;多少个日夜，每当我在聚精会神地阅读学习的时候，灯突然灭了，这是启明的规定：在启明楼里的学生必须十二点离开。我多么恨那只拉电闸的手，它恶狠狠地又从我的生命中割走了一天。走出启明，一个人在回去的路上，望着朦胧月色，我泪眼汪汪，感叹时光流逝。弃我去的不是日历上一个个日子，而是我生命中的岁月；甚至不仅仅是我的岁月，而是我自己。我们的生命或许是由一个个自己组成，他会因为韵苑可口的拉面而开心，他会因为做错事而懊恼不已，他会为了微机原理课设而彻夜不眠。他仿佛是个孤儿，被遗留在过去的岁月里，他举目无亲，孑然一身。<br>我大声向他呼喊，多么想把他带回，可是我无法与岁月的洪流抗衡，他慢慢成了过往和回忆。或许正是因为成为了回忆，我开始怀恋考试月和胡杨坐绿皮车去主图啃一本本厚厚的专业书，开始觉得在深信服写C++只有成长没有痛苦，开始以为除了淇营就数我和矢量唱歌最好听。岁月的急流带走了自己，也扭曲了记忆，让我们记住了快乐，忘却了痛苦，满满的苦尽甘来的滋味。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/21/%E6%AF%95%E4%B8%9A-%E9%9A%BE%E8%88%8D%E5%96%BB%E5%AE%B6%E5%B1%B1/星辰大海.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">星辰大海</div>
</center>

<p>&emsp;&emsp;临走之前，和新睿聊大学四年到深夜，新睿觉得要是大学四年可以重新来过，那绝对不会这么过。对啊，我还没打卡学校34座食堂，还没把东湖的各个路线摸熟，还没在启明楼下螺蛳粉店最后被推倒之前去吃上最后一碗螺蛳粉，还没去蹭过节节爆满的深度中国，还没在学校里见到自己喜欢的作家方方，还没……还在喻家山时觉得她平白无奇，要走时，她的点点滴滴，化成颗颗璀璨夺目的珍珠，散落在时间的长河，熠熠生辉。在日后的某年某月，和挚友闲聊时，才会把它们从长河中拾起，串成打上了喻家山和Dian烙印的珍珠项链。</p>
<p>&emsp;&emsp;因为失去青春，我们才懂得长大；因为失去岁月，我们才知道缅怀时间。每个人的大学四年，都有自己专属的特点，我们四处找寻团队，交往朋友，就是想把最珍贵的岁月揉进喻家山的历史长河，磨砺颗颗珍珠。回首自己的四年，时光被熔铸在《第一行代码》和《深入理解Java虚拟机》中，被回响于网安组服务器声声轰鸣声中，被填充在海底捞过后的满天星里，被藏匿在游客如织的樱园里，被浸润在团队导师声声教诲之中。人们把失去的称为过去，尚未得到的称为未来，停在手里的称为现在。可是时间何时停留过，现在转瞬即逝，成为过去，我们又拥有什么？</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/21/%E6%AF%95%E4%B8%9A-%E9%9A%BE%E8%88%8D%E5%96%BB%E5%AE%B6%E5%B1%B1/深林小屋.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">深林小屋</div>
</center>

<p>&emsp;&emsp;许多年后，当我们回到喻家山下，看着那一张张陌生稚嫩的面孔，我们难免会怅然若失，因为许多年前，我们才是喻家山的主人，我们才是那篮球场上飞驰的身影，我们才是东九楼里冥思苦想的少年。嫉妒之情油然而生，他们成了喻家山母亲的最小的孩子，他们可以在校园里大喊大笑，他们成了老师心头最疼爱关心的学生。当年喻园吃过的油条最香甜，当年追过的姑娘最动人，当年我们见证了喻家山下那段悲壮的抗疫史，当年我们成了有史以来最特殊的毕业生。可是，多年后，我们努力推掉手头的工作，和当年的同学相聚，我们寻访恩师，故地重游，企图找回当年的爱恨情仇，酸甜苦辣，然而这一切都是徒劳。我们终于怅然发现，时光带走的不只是我们最美好的青春，而是由当年善良的人，高大的梧桐，壮丽的大楼，巍峨的喻家山，蔚蓝的天空一起组成的世界，其中还包含着我们的爱和忧愁，感觉和性情，我们当年整个的心灵世界呀！</p>
<p>&emsp;&emsp;莫问前路无知己，天下谁人不识君。多年前，喻家山下走出了微信之父张小龙，中国网球第一人李娜，中国外科之父裘法祖。喻家山人在各行各业崭露头角，独领风骚。我们处在喻家山的不同的时代，但是却得到了喻家山同样的哺育与关爱，今天的他们，必定会是明天的我们。</p>
]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 基础</title>
    <url>/2018/10/06/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/21/N8NUtf.jpg">
    <br>
</center>

<h1 id="第一章-基础"><a href="#第一章-基础" class="headerlink" title="第一章 基础"></a>第一章 基础</h1><h2 id="一、什么是网络"><a href="#一、什么是网络" class="headerlink" title="一、什么是网络"></a>一、什么是网络</h2><a id="more"></a>
<h3 id="（1）-什么是网络"><a href="#（1）-什么是网络" class="headerlink" title="（1） 什么是网络"></a>（1） 什么是网络</h3><ul>
<li>将两个或多个实体连接为在一起的系统；</li>
</ul>
<h3 id="（2）计算机网络"><a href="#（2）计算机网络" class="headerlink" title="（2）计算机网络"></a>（2）计算机网络</h3><ul>
<li>自主计算机的互联集合</li>
<li>互联网是一个典型的计算机网络</li>
</ul>
<h3 id="（3）协议"><a href="#（3）协议" class="headerlink" title="（3）协议"></a>（3）协议</h3><ul>
<li>控制发送和接受信息</li>
<li>例如：TCP、IP、HTTP、Skype</li>
</ul>
<h2 id="二、如何建造计算机网络"><a href="#二、如何建造计算机网络" class="headerlink" title="二、如何建造计算机网络"></a>二、如何建造计算机网络</h2><h3 id="1-连通性"><a href="#1-连通性" class="headerlink" title="1 连通性"></a>1 连通性</h3><p>（1）链路</p>
<ul>
<li>点到点链路</li>
<li>节点：中间结点</li>
</ul>
<p>（2）交换网络</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">交换网络</span><br><span class="line"></span><br><span class="line">一种基础网络</span><br><span class="line"></span><br><span class="line">两种类型的交换网络：电路交换和分组交换</span><br></pre></td></tr></table></figure>

<p>（3）网络互连</p>
<ul>
<li>多个独立的网络相互连接形成互联网</li>
<li>路由器、网关：连接两个或多个网络的特殊节点</li>
</ul>
<p>（4）主机和主机的连通性</p>
<ul>
<li>直接连接或间接连接</li>
<li>网络节点的识别</li>
</ul>
<p>（5）路由</p>
<ul>
<li>如何将报文发至目的节点</li>
</ul>
<h3 id="2-可拓展的连通性"><a href="#2-可拓展的连通性" class="headerlink" title="2 可拓展的连通性"></a>2 可拓展的连通性</h3><p>（1）梅特卡夫定律</p>
<ul>
<li>是指网络价值以用户数量的平方的速度增长。 这个法则告诉我们：网络中总人数是n，网络价值是n×n=n²。</li>
</ul>
<h3 id="3-通信网络的分类"><a href="#3-通信网络的分类" class="headerlink" title="3 通信网络的分类"></a>3 通信网络的分类</h3><ul>
<li>交换网络（考试会考计算时间）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">电路交换--多路复用、时分复用、频分复用</span><br><span class="line">        --网络资源被分成片</span><br><span class="line">        --优点：带宽保证、通信可靠、路由机制简单、数据包结构的额外开销小</span><br><span class="line">        --缺点：浪费带宽、受限连接、连接建立延时、网络状态</span><br><span class="line">        --电话网</span><br><span class="line">        </span><br><span class="line">分组交换：数据通过离散的数据分组进行传输</span><br><span class="line">        --先把较长的报文划分较短的、固定长的数据段</span><br><span class="line">        --每个数据前添加收不构成分组</span><br><span class="line">        --统计复用</span><br><span class="line">        --实例：ip数据网</span><br><span class="line">报文交换</span><br></pre></td></tr></table></figure></li>
<li>广播网络</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传播时延</span><br><span class="line"></span><br><span class="line">传输时延</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">排队</span><br><span class="line"></span><br><span class="line">丢包</span><br></pre></td></tr></table></figure>

<h3 id="4-通用服务"><a href="#4-通用服务" class="headerlink" title="4 通用服务"></a>4 通用服务</h3><h4 id="1-什么是通用服务"><a href="#1-什么是通用服务" class="headerlink" title="(1)什么是通用服务"></a>(1)什么是通用服务</h4><ul>
<li>一些可以被应用车农夫调用的构件</li>
</ul>
<h4 id="2-相同的通信模式"><a href="#2-相同的通信模式" class="headerlink" title="(2)相同的通信模式"></a>(2)相同的通信模式</h4><ul>
<li>请求/响应</li>
<li>消息流</li>
</ul>
<h4 id="3-三类故障"><a href="#3-三类故障" class="headerlink" title="(3)三类故障"></a>(3)三类故障</h4><ul>
<li>比特错误</li>
<li>分组丢失</li>
<li>节点宕机</li>
</ul>
<h3 id="5-分层结构中的一些基本概念"><a href="#5-分层结构中的一些基本概念" class="headerlink" title="5 分层结构中的一些基本概念"></a>5 分层结构中的一些基本概念</h3><h4 id="（1）实体"><a href="#（1）实体" class="headerlink" title="（1）实体"></a>（1）实体</h4><h4 id="（2）协议"><a href="#（2）协议" class="headerlink" title="（2）协议"></a>（2）协议</h4><ul>
<li>语法：数据与控制信息的结构或格式</li>
<li>语义：需要发出何种控制信息，完成何的种动作以及做出何种响应。</li>
<li>同步：事件实现顺序详细说明。</li>
</ul>
<h2 id="三、非常重要，但是自己已经弄懂的了问题"><a href="#三、非常重要，但是自己已经弄懂的了问题" class="headerlink" title="三、非常重要，但是自己已经弄懂的了问题"></a>三、非常重要，但是自己已经弄懂的了问题</h2><h3 id="1-电路交换的有点和缺点，以及需要辩证地理解其有缺点。"><a href="#1-电路交换的有点和缺点，以及需要辩证地理解其有缺点。" class="headerlink" title="1 电路交换的有点和缺点，以及需要辩证地理解其有缺点。"></a>1 电路交换的有点和缺点，以及需要辩证地理解其有缺点。</h3><p>答：电路交换的优点：带宽保证、通信可靠、路由机制简单、数据包结构的额外开销小。</p>
<p>缺点：浪费带宽、受限连接、连接建立延时、网络状态。</p>
<p>理解：电路交换的优缺点实质就是相互关联的，在一定的环境下，优点可能演变为缺点，缺点可能演变为优点，我们只有真正理解事物的本质，才能让事物为我们所用，取长补短。</p>
<h3 id="2-分组交换的优点和缺点，以及需要辩证地理解其有缺点。"><a href="#2-分组交换的优点和缺点，以及需要辩证地理解其有缺点。" class="headerlink" title="2 分组交换的优点和缺点，以及需要辩证地理解其有缺点。"></a>2 分组交换的优点和缺点，以及需要辩证地理解其有缺点。</h3><p>答：优点：不存在带宽浪费、多路复用技术、服务、健壮性。</p>
<p>缺点：无法保证带宽、每个分组的开销、复杂的端到端控制、时延和拥塞。</p>
<h2 id="四、自己没有弄懂的问题"><a href="#四、自己没有弄懂的问题" class="headerlink" title="四、自己没有弄懂的问题"></a>四、自己没有弄懂的问题</h2><h3 id="1-关于计算机网络应用问题，它对应着现代企业中的什么工作，下一代计算机网络会是怎样的？"><a href="#1-关于计算机网络应用问题，它对应着现代企业中的什么工作，下一代计算机网络会是怎样的？" class="headerlink" title="1 关于计算机网络应用问题，它对应着现代企业中的什么工作，下一代计算机网络会是怎样的？"></a>1 关于计算机网络应用问题，它对应着现代企业中的什么工作，下一代计算机网络会是怎样的？</h3><h3 id="2-Ipv4和Ipv6的相同和区别？"><a href="#2-Ipv4和Ipv6的相同和区别？" class="headerlink" title="2 Ipv4和Ipv6的相同和区别？"></a>2 Ipv4和Ipv6的相同和区别？</h3><h3 id="3-对于分组交换存在的丢包情况，我们在平时上网中是不是下载一个东西，在下到一半的情况下突然下载失败了，这是不是就是丢包了？如果丢包，用户层面是如何体现的？"><a href="#3-对于分组交换存在的丢包情况，我们在平时上网中是不是下载一个东西，在下到一半的情况下突然下载失败了，这是不是就是丢包了？如果丢包，用户层面是如何体现的？" class="headerlink" title="3 对于分组交换存在的丢包情况，我们在平时上网中是不是下载一个东西，在下到一半的情况下突然下载失败了，这是不是就是丢包了？如果丢包，用户层面是如何体现的？"></a>3 对于分组交换存在的丢包情况，我们在平时上网中是不是下载一个东西，在下到一半的情况下突然下载失败了，这是不是就是丢包了？如果丢包，用户层面是如何体现的？</h3><h3 id="4-对于网络7层我们在什么样的工程应用中会遇到，这7层本质是协议，还是什么，设计这么多层是否显得过于冗余？"><a href="#4-对于网络7层我们在什么样的工程应用中会遇到，这7层本质是协议，还是什么，设计这么多层是否显得过于冗余？" class="headerlink" title="4 对于网络7层我们在什么样的工程应用中会遇到，这7层本质是协议，还是什么，设计这么多层是否显得过于冗余？"></a>4 对于网络7层我们在什么样的工程应用中会遇到，这7层本质是协议，还是什么，设计这么多层是否显得过于冗余？</h3><h2 id="五、分层的协议层"><a href="#五、分层的协议层" class="headerlink" title="五、分层的协议层"></a>五、分层的协议层</h2><h3 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h3><ul>
<li>通过封装, 协议实体可以在分组中携带信息通告对等实体如何处理收到的分组</li>
<li>首部/尾部的加载及分-离</li>
</ul>
<h3 id="二、复用与解复用"><a href="#二、复用与解复用" class="headerlink" title="二、复用与解复用"></a>二、复用与解复用</h3><ul>
<li>复用(Multiplexing)来自源节点不同高层实体的数据，将数据解复用(Demultiplexing)至目的节点对应的高层实体</li>
<li>能够区别数据所属的高层实体需要</li>
<li>各种不同类型的解多路复用密钥</li>
<li>在接收端主机解复用：把收到的报文传送到正确的socket</li>
<li>在发送端主机采用复用：从多个得到数据，并添<br>加头部信息 (后面的分用会socket用到)</li>
</ul>
<h3 id="六、OSI七层模型"><a href="#六、OSI七层模型" class="headerlink" title="六、OSI七层模型"></a>六、OSI七层模型</h3><h4 id="1-各层功能定义"><a href="#1-各层功能定义" class="headerlink" title="1.各层功能定义"></a>1.各层功能定义</h4><ul>
<li>应用层：向终端用户提供各类应用服务, 例如: ftp, telnet</li>
<li>表示层：<br>数据结构表示, 数据格式转换(加密、压缩)</li>
<li>会话层：<br>提供会话管理, 接入控制, 数据传输同步等</li>
<li>传输层：<br>实现终端进程之间的逻辑信道</li>
<li>网络层：<br>处理分组交换网络中的路由选择</li>
<li>数据链路层：<br>收集比特流组合成帧</li>
<li>物理层：<br>处理通信链路上的原始比特流传输</li>
</ul>
<h4 id="2-传输模型"><a href="#2-传输模型" class="headerlink" title="2.传输模型"></a>2.传输模型</h4><ul>
<li>每个层次可以在数据的前后追加本层附加的数据</li>
</ul>
<h4 id="3-网络体系架构的五层模型"><a href="#3-网络体系架构的五层模型" class="headerlink" title="3. 网络体系架构的五层模型"></a>3. 网络体系架构的五层模型</h4><ul>
<li>应用进程数据先传送到应用层</li>
<li>加上应用层首部，成为应用层 PDU</li>
<li>加上运输层首部，成为运输层报文</li>
<li>加上网络层首部，成为 IP 数据报（或分组）</li>
<li>最下面的物理层把比特流传送到物理媒体</li>
</ul>
<h3 id="六、互联网的体系结构"><a href="#六、互联网的体系结构" class="headerlink" title="六、互联网的体系结构"></a>六、互联网的体系结构</h3><h4 id="1-分层结构"><a href="#1-分层结构" class="headerlink" title="1.分层结构"></a>1.分层结构</h4><ul>
<li>应用层</li>
<li>传输层：<br>进程与进程之间的消息传输, 两个主要的协议:<br>TCP (Transmission Control Protocol)<br>UDP (User Datagram Protocol) </li>
<li>IP层：<br>主机到主机的数据分组传输<br>唯一协议: IP</li>
<li>网络接入层：没有指定该层的实际细节，可以是任意一种底层网络</li>
</ul>
<h4 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2.设计原则"></a>2.设计原则</h4><ul>
<li>沙漏模型是Internet能够快速适应用户新应用需求和网络技术更新的关键.</li>
<li>“Simple Core and Complex Host’’ Philosophy</li>
</ul>
<h4 id="3-分组交换网中时延的四个来源"><a href="#3-分组交换网中时延的四个来源" class="headerlink" title="3.分组交换网中时延的四个来源"></a>3.分组交换网中时延的四个来源</h4><ul>
<li>节点处理时延 </li>
<li>排队延时</li>
<li>传输延时</li>
<li>传播延时</li>
</ul>
<h4 id="4-网络性能-吞吐量"><a href="#4-网络性能-吞吐量" class="headerlink" title="4.网络性能: 吞吐量"></a>4.网络性能: 吞吐量</h4><ul>
<li>吞吐量: 发送者与接收者之间比特交换的速率 (比特/单位时间)</li>
<li>瞬时: 在给定时间点的速率</li>
</ul>
<h3 id="七、网络性能"><a href="#七、网络性能" class="headerlink" title="七、网络性能"></a>七、网络性能</h3><h4 id="1-链路带宽"><a href="#1-链路带宽" class="headerlink" title="1.链路带宽"></a>1.链路带宽</h4><ul>
<li>原始定义：信号的频带宽度, 用 Hertz (Hz) 表示</li>
<li>网络定义: 一段特定的时间内网络所能传送的比特数, 用<br>bits per second (bps)表示</li>
</ul>
<h4 id="2-应用性能需求"><a href="#2-应用性能需求" class="headerlink" title="2.应用性能需求"></a>2.应用性能需求</h4><ul>
<li>平均速率及突发流量</li>
<li>内存溢出导致的数据包丢弃</li>
<li>时延抖动</li>
</ul>
<h3 id="八-套接字编程"><a href="#八-套接字编程" class="headerlink" title="八.套接字编程"></a>八.套接字编程</h3><ul>
<li>Socket：一个本地的，应用程序创建的，操作系统控制的接口。</li>
<li>套接字(socket): 应用进程之间的接口，实现端到端的传输协议</li>
<li>Socket API类别<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PF_INET : 用于互联网编程</span><br><span class="line">PF_UNIX: 用于Unix 管道编程</span><br><span class="line">PF_PACKET:直接访问网络接口 (i.e, 绕过TCP &#x2F; IP协议栈)</span><br></pre></td></tr></table></figure></li>
<li>两种基本socket API分别支持两种传输服务:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SOCK_STREAM: 可靠的，字节流服务 (TCP)  SOCK_DGRAM: 非可靠的数据报服务 (UDP)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="没有懂的问题"><a href="#没有懂的问题" class="headerlink" title="没有懂的问题"></a>没有懂的问题</h3><p>1.为什么网络体系架构没有像OSI一样分为7层；</p>
<p>2.链路带宽对于吞吐量有什么影响；</p>
<p>3.对于Socket编程没有在华为组这样的使用经历，我们该怎么深入了解socket编程。</p>
<h3 id="懂了的问题"><a href="#懂了的问题" class="headerlink" title="懂了的问题"></a>懂了的问题</h3><h4 id="1-带宽与吞吐量的区别？"><a href="#1-带宽与吞吐量的区别？" class="headerlink" title="1.带宽与吞吐量的区别？"></a>1.带宽与吞吐量的区别？</h4><p>答：吞吐量和带宽是很容易搞混的一个词，两者的单位都是Mbps。先来看两者对应的英语，吞吐量：throughput；带宽：Max net bitrate。当讨论通信链路的带宽时，一般是指链路上每秒所能传送的比特数，它取决于链路时钟速率和信道编码，在计算机网络中又称为线速。可以说以太网的带宽是10Mbps。但是需要区分链路上的可用带宽（带宽）与实际链路中每秒所能传送的比特数（吞吐量）。通常更倾向于用“吞吐量”一词来表示一个系统的测试性能。这样，因为实现受各种低效率因素的影响，所以由一段带宽为10Mbps的链路连接的一对节点可能只达到2Mbps的吞吐量。这样就意味着，一个主机上的应用能够以2Mbps的速度向另外的一个主机发送数据。</p>
<h4 id="2-网络延迟是怎样产生的？"><a href="#2-网络延迟是怎样产生的？" class="headerlink" title="2.网络延迟是怎样产生的？"></a>2.网络延迟是怎样产生的？</h4><p>网络延迟 = 传输延迟 + 处理延迟 + 缓冲队列延迟</p>
<ul>
<li>1）传输延迟这个延迟很好理解，指光、电信号在有线介质上的延迟，或无线电信号在空气介质中的延迟，这种传输延迟只和光速有关、或电信号的传输速度有关，用户无法改变该延迟。对于一条选定的端对端路径，此值是恒定的。</li>
<li>2）处理延迟接收IP包，查询转发表，硬件、或软件转发，包括封装、解封装、编码、解码时间，经过设备越多，设备吞吐能力越弱（一秒可以转发多少Gb的数据），延迟越大。但对于一条选定的端对端路径，此值也是恒定的。</li>
<li>3）缓冲队列延迟当端到端的路径上，没有任何网络拥塞，缓冲队列的延迟几户为0，网络转发性能达到线速度，好像两端用一根线直连。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>海尔集团总裁周云杰华科毕业典礼演讲：智商＋情商＋逆商铸就魂商</title>
    <url>/2020/06/21/%E5%8D%8E%E4%B8%AD%E5%A4%A7%E4%BA%BA%E5%90%8E%E6%B5%AA%E5%85%A5%E6%B5%B7-%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/21/%E5%8D%8E%E4%B8%AD%E5%A4%A7%E4%BA%BA%E5%90%8E%E6%B5%AA%E5%85%A5%E6%B5%B7-%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F/思维隧道.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">思维隧道</div>
</center>

<blockquote>
<p>本文是海尔集团总裁周云杰在华科2020届毕业典礼演讲辞，听了后感觉对自己思维冲击很大，于是将其收录在自己的博客中，方便日后学习，进步。</p>
</blockquote>
<a id="more"></a>

<p>&emsp;&emsp;尊敬的校领导，尊敬的老师们，亲爱的同学们，大家好。感谢母校邀请我在特殊的时期，以这种特别的方式参加同学们的毕业典礼，一场突如其来的疫情，让2020届毕业生注定是与众不同的。</p>
<p>&emsp;&emsp;人生本身是一场修行，它充满了无数的不确定性，但同时也孕育着无限的可能。所以今天我用7分钟的时间分享三点体会，送给即将走向社会的同学们</p>
<br>
<center><font size="4">一、少年转身不追华丽，但求速度</font></center>
<br>

<p>&emsp;&emsp;人生本身是一场修行，它充满了无数的不确定性，同时也孕育着无限的可能。人生有很多第一次，但毕业踏上社会是人生中比较大的一次转身。</p>
<p>&emsp;&emsp;上学时学校以你为中心。但我建议从今天起就忘记：“我学习成绩很好，我来自名校”。因为从今以后，你不再是中心，你的价值要体现在为他人、为社会创造的价值上。</p>
<p>&emsp;&emsp;角色转换的快慢将决定你事业起步的速度，甚至决定你人生的方向。转身不必华丽，但必须追求速度。</p>
<br>
<center><font size="4">第二，智商+情商+逆商才会铸就魂商。</font></center>
<br>


<p>&emsp;&emsp;能从这个校门走出去的都具有高智商，但我所说的高智商指的是知行合一。《道德经》有云：胜人者有力，自胜者强。既不妄自菲薄，也不妄自尊大，能时刻战胜满足感的人，才是真正高智商的人。情商的高低决定了有多少人帮你，成就事业并不取决于你自己有多大的能耐，拥有多少资源，而在于你可以调动多少人，可以整合多少资源，这就是德鲁克所说的企业即人，管理即借力，高智商需要良好的沟通能力，其关键在于能否换位思考。</p>
<p>&emsp;&emsp;余秋雨说过，这世界上有些时候山是水的故事，云是风的故事。但有些时候星不是夜的故事，情不是爱的故事。生命的旅途中苦过了才知甜蜜，痛过了才懂坚强，傻过了才会成长。有逆商的人不会被困难打倒，视挫折为财富，学会做自己的心理医生。</p>
<p>&emsp;&emsp;高魂商意味着有着大开大合的人生格局，有着改变世界的家国情怀。比如乔布斯曾经说过，活着就是为了改变世界。我们华中大也有一位优秀的校友，张小龙，他发明了微信，改变了人们的生活，也改变了世界。所以我的第二个体会是高智商加高情商，适合从政；高智商加高逆商，适合做科研；高情商加高逆商，适合做企业。当然如果你同时拥有了三高，你可能就会迸发出魂商，成为伟大的政治家，伟大的科学家或者伟大的企业家，这都会是你的选项。</p>
<br>
<center><font size="4">第三，成功的道路并不拥挤，因为坚持的人太少。</font></center>
<br>


<p>&emsp;&emsp;成功是每个人的梦想，但每个成功者的背后又都潜伏着失败的危机。因为成功之前的每一天，你都面对的是失败，而且一旦成功，成功便成为过去时，我很欣赏电视剧《天道》里的一句台词：忍，是一条线；能，又是一条线，这两者之间是你的生存空间，如果做到了忍人所不能忍，能人所不能，那么你的生存空间就会比别人大。</p>
<p>&emsp;&emsp;没有郭平师兄等多位校友在任正非先生领导下的坚持，就没有今天的华为；没有陈宗年等三位师兄的坚持，就没有今天的海康威视；没有黄立师兄的坚持，就没有今天的高德红外；当然没有张瑞敏先生的坚持，也不会有今天的海尔。所以我的第三个体会是在前进的道路上选择与谁同行，比要去的远方更重要。你和你的同伴比别人多坚持一会儿，可能你就成功了。</p>
<p>&emsp;&emsp;萧伯纳说过，改变世界的是这样一群人，他们一直在寻找梦想中的乐园，当他们找不到时，便亲手创造了它。祝愿2020届的同学们带着“明德、厚学、求是、创新”的校训，亲手去创造自己的乐园。</p>
]]></content>
      <categories>
        <category>文集及讲座</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 端到端协议</title>
    <url>/2018/10/06/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/21/N8NyBn.jpg">
    <br>
</center>

<h2 id="一、支持通用服务"><a href="#一、支持通用服务" class="headerlink" title="一、支持通用服务"></a>一、支持通用服务</h2><ul>
<li>目标 1: 网络支持各种不同的应用 </li>
<li>目标 2: 网络在现实网络条件下支持各种不同的应用</li>
</ul>
<a id="more"></a>

<h2 id="二、进程间如何通信"><a href="#二、进程间如何通信" class="headerlink" title="二、进程间如何通信"></a>二、进程间如何通信</h2><h3 id="1-传输层-上层协议的观点"><a href="#1-传输层-上层协议的观点" class="headerlink" title="1.传输层: 上层协议的观点"></a>1.传输层: 上层协议的观点</h3><ul>
<li>保证消息的传输</li>
<li>传送过程中保证消息发送时的顺序</li>
<li>最多传送每个消息的一个副本</li>
<li>支持任意大的消息</li>
<li>支持发送方与接收方之间的同步</li>
<li>允许接收方对发送方进行流量控制</li>
<li>支持每台主机上的多个应用进程</li>
</ul>
<h3 id="2-传输层-下层网络的观点"><a href="#2-传输层-下层网络的观点" class="headerlink" title="2.传输层: 下层网络的观点"></a>2.传输层: 下层网络的观点</h3><ul>
<li>底层网络可以提供的服务:</li>
<li>不可靠的分组传送</li>
<li>不确定的时延</li>
<li>有限大小的分组</li>
</ul>
<h3 id="3-用户数据报协议-UDP"><a href="#3-用户数据报协议-UDP" class="headerlink" title="3.用户数据报协议(UDP)"></a>3.用户数据报协议(UDP)</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>仅在IP基础上增加了一级解多路复用功能</li>
<li>面向报文</li>
<li>无连接</li>
<li>不保证消息的可靠传送</li>
<li>无流量控制 </li>
</ul>
<h4 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h4><ul>
<li>控制数据发送的内容和时间</li>
<li>不存在连接建立时延</li>
<li>无状态连接</li>
<li>报文首部开销较小</li>
</ul>
<h4 id="UDP的缺点"><a href="#UDP的缺点" class="headerlink" title="UDP的缺点"></a>UDP的缺点</h4><ul>
<li>“尽最大努力交付”</li>
<li>无拥塞控制</li>
<li>抑制TCP流</li>
</ul>
<h4 id="采用UDP协议的应用"><a href="#采用UDP协议的应用" class="headerlink" title="采用UDP协议的应用"></a>采用UDP协议的应用</h4><ul>
<li>简单查询协议(例如域名解析系统, DNS)</li>
<li>多媒体应用</li>
</ul>
<h2 id="三、TCP-服务模型"><a href="#三、TCP-服务模型" class="headerlink" title="三、TCP 服务模型"></a>三、TCP 服务模型</h2><h3 id="1-TCP面临的挑战"><a href="#1-TCP面临的挑战" class="headerlink" title="1.TCP面临的挑战"></a>1.TCP面临的挑战</h3><ul>
<li>连接</li>
<li>超时重传</li>
<li>乱序到达</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<h3 id="2-三次握手"><a href="#2-三次握手" class="headerlink" title="2.三次握手"></a>2.三次握手</h3><p>主要是为了防止已经失效的连接请求报文段又被接收方<br>收到而导致的错误</p>
<h3 id="3-TCP-滑动窗口算法"><a href="#3-TCP-滑动窗口算法" class="headerlink" title="3.TCP 滑动窗口算法"></a>3.TCP 滑动窗口算法</h3><ul>
<li>可靠有序的数据传送</li>
<li>流量控制</li>
<li>防止回绕</li>
<li>保持管道满载</li>
</ul>
<h3 id="4-TCP中的触发传输"><a href="#4-TCP中的触发传输" class="headerlink" title="4.TCP中的触发传输"></a>4.TCP中的触发传输</h3><ul>
<li>傻瓜窗口症状</li>
<li>当应用层交付数据速度较快，而网络速率较慢时，较小的报文段浪费带宽</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 开始连接</title>
    <url>/2018/10/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BC%80%E5%A7%8B%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s1.ax1x.com/2020/06/21/N8NNAP.jpg">
    <br>
</center>

<h3 id="一、适配器之间的通信"><a href="#一、适配器之间的通信" class="headerlink" title="一、适配器之间的通信"></a>一、适配器之间的通信</h3><ul>
<li>发送端：将分组封装为数据帧，增加差错检测、可靠传输、留空等功能</li>
<li>接收端：完成差错检测、实施可靠传输</li>
</ul>
<a id="more"></a>

<h3 id="二、直接网络的研究问题"><a href="#二、直接网络的研究问题" class="headerlink" title="二、直接网络的研究问题"></a>二、直接网络的研究问题</h3><ul>
<li>编码：对发送到电缆或光纤上的比特进行编码, 使其能被接收主机所理解</li>
<li>帧定界：把物理链路上传输的比特序列描述为完整的消息，以便传送到端节点</li>
<li>差错检测</li>
<li>可靠传输</li>
<li>通信：如果链路静态共享, 很容易处理</li>
</ul>
<h3 id="三、网络硬件"><a href="#三、网络硬件" class="headerlink" title="三、网络硬件"></a>三、网络硬件</h3><h4 id="1-节点"><a href="#1-节点" class="headerlink" title="1.节点"></a>1.节点</h4><ul>
<li>网络中的两种稀缺资源: 节点的内存及网络链路带宽</li>
<li>网络适配器是节点接入网络的专用设备</li>
</ul>
<h4 id="2-网络适配器"><a href="#2-网络适配器" class="headerlink" title="2.网络适配器"></a>2.网络适配器</h4><ul>
<li>功能<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进行串行&#x2F;并行转换;</span><br><span class="line"></span><br><span class="line">对数据进行缓存;</span><br><span class="line"></span><br><span class="line">设备驱动程序（数据链路层协议）</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="3-链路"><a href="#3-链路" class="headerlink" title="3.链路"></a>3.链路</h4><ul>
<li>导向型媒质: 信号在固态媒质上传播, 例如同轴电缆, 光纤, 双绞线</li>
<li>非导向型媒质: 信号自由传播, 例如电磁波</li>
<li>物理媒介：有线，无线</li>
<li>链路容量（通信信道、信道容量）</li>
</ul>
<h3 id="四、编码"><a href="#四、编码" class="headerlink" title="四、编码"></a>四、编码</h3><h4 id="1-不归零-NRZ-Non-Return-to-Zero"><a href="#1-不归零-NRZ-Non-Return-to-Zero" class="headerlink" title="1.不归零 NRZ (Non-Return to Zero)"></a>1.不归零 NRZ (Non-Return to Zero)</h4><ul>
<li>问题: 连续的1s 或 0s</li>
</ul>
<p>连续的 0s可能被误认为没有信号</p>
<p>连续的 1s可能导致基线漂移</p>
<p>时钟恢复困难（同步问题）</p>
<h4 id="2-曼彻斯特编码"><a href="#2-曼彻斯特编码" class="headerlink" title="2.曼彻斯特编码"></a>2.曼彻斯特编码</h4><ul>
<li>缺点: 信号跳变速率翻倍，比特率是信号跳变速率（波特率）的一半</li>
</ul>
<h3 id="五、组帧"><a href="#五、组帧" class="headerlink" title="五、组帧"></a>五、组帧</h3><h4 id="1-帧定界问题"><a href="#1-帧定界问题" class="headerlink" title="1.帧定界问题"></a>1.帧定界问题</h4><ul>
<li>两个节点之间的数据传输以块为单位(帧)</li>
<li>能够识别数据帧的开始和结束</li>
</ul>
<h3 id="六、可靠传输"><a href="#六、可靠传输" class="headerlink" title="六、可靠传输"></a>六、可靠传输</h3><h4 id="1-停止等待协议"><a href="#1-停止等待协议" class="headerlink" title="1.停止等待协议"></a>1.停止等待协议</h4><ul>
<li><p>链路带宽利用率较低</p>
</li>
<li><p>示例 </p>
</li>
</ul>
<p>链路带宽为2 Mbps, RTT为45 ms, 数据帧大小为1.5KB<br>每一个RTT内, 发送方仅能发送一个数据帧<br>吞吐量为1500x8/0.045 = 266.7kbps</p>
<h4 id="2-连续ARQ协议"><a href="#2-连续ARQ协议" class="headerlink" title="2.连续ARQ协议"></a>2.连续ARQ协议</h4><ul>
<li><p>Go-Back-N</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一次性发送N个数据帧；</span><br><span class="line"></span><br><span class="line">如果第k个帧丢失, 对[k, k+N-1]范围内的所有帧重传。</span><br><span class="line"></span><br><span class="line">优点: 接收方不需要缓存接收到的乱序帧，确认简单</span><br><span class="line"></span><br><span class="line">缺点: 正确帧也可能被重传，效率较低</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择性重传</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一次性发送N个数据帧；</span><br><span class="line"></span><br><span class="line">如果第k个帧丢失, 仅重传第k个帧；</span><br><span class="line"></span><br><span class="line">接收方对每一个帧进行确认。</span><br><span class="line"></span><br><span class="line">优点: 链路利用率较高</span><br><span class="line"></span><br><span class="line">缺点: 接收方更复杂</span><br></pre></td></tr></table></figure>

<h4 id="3-滑动窗口协议ARQ"><a href="#3-滑动窗口协议ARQ" class="headerlink" title="3.滑动窗口协议ARQ"></a>3.滑动窗口协议ARQ</h4><ul>
<li>发送方:发送方在未收到确认前能够发送的数据帧的最大个数</li>
</ul>
<h3 id="七、多路访问控制"><a href="#七、多路访问控制" class="headerlink" title="七、多路访问控制"></a>七、多路访问控制</h3><h4 id="1-两种类型的“链路”"><a href="#1-两种类型的“链路”" class="headerlink" title="1.两种类型的“链路”:"></a>1.两种类型的“链路”:</h4><ul>
<li>点到点链路</li>
<li>广播链路(共享的有线/无线传输媒质)</li>
</ul>
<h4 id="2-共享广播链路通信的基本问题"><a href="#2-共享广播链路通信的基本问题" class="headerlink" title="2.共享广播链路通信的基本问题"></a>2.共享广播链路通信的基本问题</h4><ul>
<li>干扰: 如果两个或多个节点同时传输</li>
<li>冲突: 如果节点同时收到两个或多个信号</li>
</ul>
<h4 id="3-基本解决方法"><a href="#3-基本解决方法" class="headerlink" title="3.基本解决方法"></a>3.基本解决方法</h4><ul>
<li>首先、寻址</li>
<li>其次，多路访问控制协议</li>
</ul>
<h4 id="4-MAC协议"><a href="#4-MAC协议" class="headerlink" title="4.MAC协议"></a>4.MAC协议</h4><ul>
<li><p>静态信道划分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在每次循环中每一个节点占用信道固定时长 (时隙, 长度 &#x3D; 数据帧传输时延) </span><br><span class="line"></span><br><span class="line">将信道划分为较小的 “分片” (时隙, 频率, 编码)</span><br><span class="line"></span><br><span class="line">每一个分片被分配给某一节点专用</span><br></pre></td></tr></table></figure></li>
<li><p>随机接入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不划分信道, 允许冲突发生;</span><br><span class="line">“避免” 冲突或冲突“恢复”;</span><br><span class="line">更适合于基于分组的数据通信;</span><br><span class="line">案例: Aloha, CSMA, …</span><br></pre></td></tr></table></figure>
</li>
<li><p>轮转发送</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">节点轮流发送;</span><br><span class="line">待发送数据量大的节点占用信道更长时间;</span><br><span class="line">无冲突;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="八、问题"><a href="#八、问题" class="headerlink" title="八、问题"></a>八、问题</h3><h4 id="1-已经懂了的问题"><a href="#1-已经懂了的问题" class="headerlink" title="1.已经懂了的问题"></a>1.已经懂了的问题</h4><ul>
<li><p>1.物理链路和数据链路是什么关系？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据链路可以粗略地理解为数据通道。物理层要为终端设备间的数据通信提供传输媒体及其</span><br><span class="line">连接.媒体是长期的,连接是有生存期的.在连接生存期内,收发两端可以进行不等的一次或多次数</span><br><span class="line">据通信.每次通信都要经过建立通信联络和拆除通信联络两过程.这种建立起来的数据收发关系就</span><br><span class="line">叫作数据链路.而在物理媒体上传输的数据难免受到各种不可靠因素的影响而产生差错,为了弥补</span><br><span class="line">物理层上的不足,为上层提供无差错的数据传输,就要能对数据进行检错和纠错.数据链路的建立,</span><br><span class="line">拆除,对数据的检错,纠错是数据链路层的基本任务.</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.检错码和纠错码的区别是什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">检错码：只检错不纠正</span><br><span class="line">纠错码：发现错误并给以纠正</span><br><span class="line">检错码：一种编码。指在传输过程中发生错误后，在接收端能自动检查并发现错误的编码。目前常用的检错码有奇偶校验码、恒比码等 检错码的两大类别:奇偶校验编码和循环冗余编码。</span><br><span class="line">纠错码(error correcting code)，在传输过程中发生错误后能在收端自行发现或纠正的码。仅用来发现错误的码一般常称为检错码。为使一种码具有检错或纠错能力，须对原码字增加多余的码元，以扩大码字之间的差别 ，即把原码字按某种规则变成有一定剩余度（见信源编码）的码字，并使每个码字的码之间有一定的关系。关系的建立称为编码。码字到达收端后，可以根据编码规则是否满足以判定有无错误。当不能满足时，按一定规则确定错误所在位置并予以纠正。纠错并恢复原码字的过程称为译码。检错码与其他手段结合使用，可以纠错。</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="3">
<li>如何理解CRC的基本工作原理?</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CRC校验原理看起来比较复杂，好难懂，因为大多数书上基本上是以二进制的多项式形式来说明的。其实很简单的问题，其根本思想就是先在要发送的帧后面附加一个数（这个就是用来校验的校验码，但要注意，这里的数也是二进制序列的，下同），生成一个新帧发送给接收端。当然，这个附加的数不是随意的，它要使所生成的新帧能与发送端和接收端共同选定的某个特定数整除（注意，这里不是直接采用二进制除法，而是采用一种称之为“模2除法”）。到达接收端后，再把接收到的新帧除以（同样采用“模2除法”）这个选定的除数。因为在发送端发送数据帧之前就已通过附加一个数，做了“去余”处理（也就已经能整除了），所以结果应该是没有余数。如果有余数，则表明该帧在传输过程中出现了差错。</span><br></pre></td></tr></table></figure>

<ul>
<li>4.如何理解滑动窗口控制机理的工作原理?<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP滑动窗口技术通过动态改变窗口大小来调节两台主机间数据传输。每个TCP&#x2F;IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。TCP使用肯定确认技术，其确认号指的是下一个所期待的字节。假定发送方设备以每一次三个数据包的方式发送数据，也就是说，窗口大小为3。发送方发送序列号为1、2、3的三个数据包，接收方设备成功接收数据包，用序列号4确认。发送方设备收到确认，继续以窗口大小3发送数据。当接收方设备要求降低或者增大网络流量时，可以对窗口大小进行减小或者增加，本例降低窗口大小为2，每一次发送两个数据包。当接收方设备要求窗口大小为0，表明接收方已经接收了全部数据，或者接收方应用程序没有时间读取数据，要求暂停发送。发送方接收到携带窗口号为0的确认，停止这一方向的数据传输。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-未理解的问题"><a href="#2-未理解的问题" class="headerlink" title="2.未理解的问题"></a>2.未理解的问题</h4><ul>
<li>1.Go-back-N和选择重传有什么相同之处，他们的最大区别在哪？</li>
<li>2.我们该如何提高停止-等待协议的效率？</li>
<li>3.NS-3我们在实验时时如何模拟现实世界多用户，多并发量的场景的？</li>
</ul>
<h3 id="九、以太网"><a href="#九、以太网" class="headerlink" title="九、以太网"></a>九、以太网</h3><h4 id="1、802-x-标准背景介绍"><a href="#1、802-x-标准背景介绍" class="headerlink" title="1、802.x 标准背景介绍"></a>1、802.x 标准背景介绍</h4><ul>
<li>IEEE 802将数据链路层功能划分为两个子层<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LLC (逻辑链路控制) 子层</span><br><span class="line">MAC (介质访问控制) 子层</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2、物理属性"><a href="#2、物理属性" class="headerlink" title="2、物理属性"></a>2、物理属性</h4><ul>
<li>不能超过四个中继器</li>
<li>一个以太网中最多容纳1024台主机</li>
<li>分类：粗缆、细缆、双绞线</li>
</ul>
<h4 id="3、Ethernet-集线器vs-Ethernet-交换机"><a href="#3、Ethernet-集线器vs-Ethernet-交换机" class="headerlink" title="3、Ethernet 集线器vs. Ethernet 交换机"></a>3、Ethernet 集线器vs. Ethernet 交换机</h4><ul>
<li><p>Ethernet 集线器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">层1设备</span><br><span class="line">简单的信号中继器</span><br><span class="line">为节点提供共享链路</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ethernet Switch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">层2设备</span><br><span class="line">识别数据帧的地址, 完成数据帧的存储转发</span><br><span class="line">为节点提供独立的链接</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-介质访问控制协议"><a href="#4-介质访问控制协议" class="headerlink" title="4.介质访问控制协议"></a>4.介质访问控制协议</h4><ul>
<li>帧定界</li>
<li>差错检测</li>
<li>寻址</li>
<li>多路访问控制算法</li>
</ul>
<h4 id="5-Ethernet-CSMA-CD-协议"><a href="#5-Ethernet-CSMA-CD-协议" class="headerlink" title="5.Ethernet CSMA/CD 协议"></a>5.Ethernet CSMA/CD 协议</h4><h4 id="十、无线网络"><a href="#十、无线网络" class="headerlink" title="十、无线网络"></a>十、无线网络</h4><h4 id="1-无线链路-高比特误码率"><a href="#1-无线链路-高比特误码率" class="headerlink" title="1.无线链路: 高比特误码率"></a>1.无线链路: 高比特误码率</h4><ul>
<li>电磁波的反射</li>
<li>产生多条不同长度的传播路径</li>
<li>在接收方产生模糊信号</li>
</ul>
<h4 id="2-802-11-信道与关联"><a href="#2-802-11-信道与关联" class="headerlink" title="2.802.11: 信道与关联"></a>2.802.11: 信道与关联</h4><h4 id="3-CA-冲突避免-而不是检测"><a href="#3-CA-冲突避免-而不是检测" class="headerlink" title="3. CA: 冲突避免, 而不是检测"></a>3. CA: 冲突避免, 而不是检测</h4><h4 id="4-隐藏终端问题"><a href="#4-隐藏终端问题" class="headerlink" title="4.隐藏终端问题"></a>4.隐藏终端问题</h4><ul>
<li>依赖于物理载波监听, 可能产生隐藏终端问题</li>
</ul>
<h4 id="5-暴露终端问题"><a href="#5-暴露终端问题" class="headerlink" title="5.暴露终端问题"></a>5.暴露终端问题</h4><ul>
<li>虚拟载波监听</li>
<li>RTS/CTS机制</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>PCIe简介</title>
    <url>/2020/06/22/PCIe%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/PCIe%E7%AE%80%E4%BB%8B/neqwon.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">蓝天小屋</div>
</center>

<h4 id="一、PCI-X总线基本概念"><a href="#一、PCI-X总线基本概念" class="headerlink" title="一、PCI-X总线基本概念"></a>一、PCI-X总线基本概念</h4><p>PCI-X总线在PCI总线的基础上发展而来，其在软件和硬件层面上都是兼容PCI总线的，但是却显著的提高了总线的性能。也就是说PCI-X的设备可以直接插到PCI的插槽中去，PCI的设备也可以直接插到PCI-X的插槽中去。</p>
<a id="more"></a>

<p>从硬件层面上来说，PCI-X继承了PCI总线中的Reflected-Wave Signaling，但是在信号的输入端加入了输入寄存器以增强时序性能，提高了总线的时钟频率。在PCI-X2.0的Spec中还提出了DDR和QDR技术，进一步提高了PCI-X总线的带宽。</p>
<p>一个典型的PCI-X总线系统的例子如下图所示：</p>
<p><img src="https://s1.ax1x.com/2020/03/28/GkefGn.png" alt="GkefGn.png"></p>
<p>下面是一个PCI-X 突发读存储操作（Burst Memory Read Bus Cycle）的例子：</p>
<p><img src="https://s1.ax1x.com/2020/03/28/GkeTqU.png" alt="GkeTqU.png"></p>
<p>在PCI总线中，以总线主机从从机设备读操作为例，当从机设备尚未准备好结束这次操作（从机设备未就绪，且数据尚未发送完）时，可以通过锁存数据并插入等待周期，或者发起Retry操作。PCI-X总线采用了一种叫做Split Transaction的方式来处理这种情况，如下图所示。此时，发起读操作的总线主机被称为Requester，而接受并向总线上发送数据的从机设备被称为Completer。</p>
<p>注：PCIe Spec中继承了PCI-X的这种命名方式。</p>
<p><img src="https://s1.ax1x.com/2020/03/28/GkeIMV.png" alt="GkeIMV.png"></p>
<p>采用这种方式的PCI-X总线的总线传输利用率（效率）可以达到85%，而标准的PCI总线只有50%-60%。关于Split Transaction的详细内容，建议大家去参考PCI-X的Spec，这里不再详细地介绍。此外，PCI-X总线还在配置地址寄存器（Configuration Address Register）中加入了NS（No Snoop）和RO（Relaxed Ordering）两位以提高总线传输效率。</p>
<p>前面的文章中介绍过，PCI总线的中断操作是通过一系列的边带信号（Sideband Signals）来完成的，在PCI-X Spce中引入了消息信号中断（MSI，Message Signaled Interrupts）的机制，以取代这些边带信号，进而精简系统设计。</p>
<h4 id="二、PCIe简介"><a href="#二、PCIe简介" class="headerlink" title="二、PCIe简介"></a>二、PCIe简介</h4><p>PCI-Express是继ISA和PCI总线之后的第三代I/O总线，即3GIO。 由Intel在2001年的IDF上提出，由PCI-SIG（PCI特殊兴趣组织）认证发布后才改名为“PCI-Express”。它的主要优势就是数据传输速率高，另外还有抗干扰能力强，传输距离远，功耗低等优点。 </p>
<p>注：第一代总线一般指ISA、EISA、VESA和Micro Platforms。第二代总线一般指PCI、AGP和PCI-X。</p>
<p><img src="https://s1.ax1x.com/2020/03/28/GknVk4.png" alt="GknVk4.png"></p>
<p>图中的PCI-E的传输速率指的是实际的有效传输速率，为RAW Data速率的80%，因为PCI-E（Gen1&amp;Gen2，Gen3中使用了新的方式，即128b/130b）中使用了8b/10b编解码技术。</p>
<p>PCI-Express总线的Spec中明确规定了PCI-Express的缩写为PCIe，但很多情况下，大家为了方便常把它缩写为PCI-E。</p>
<p>PCI-E接口根据总线位宽不同而有所差异，一个PCI Express连接可以被配置成x1， x2， x4， x8， x12， x16和x32的数据带宽。 (x2 and x12 link widths are optional) PCI-E各种位宽Device可以自由搭配使用，比如x1 的卡可以插到x8的插槽中使用， x8的卡可以插到x16的插槽中使用，升级方便。 </p>
<p><img src="https://s1.ax1x.com/2020/03/28/GknA7F.png" alt="GknA7F.png"></p>
<p>一些常见的PCI-E设备如下图所示：</p>
<p><img src="https://s1.ax1x.com/2020/03/28/Gknk0U.png" alt="Gknk0U.png"></p>
]]></content>
      <categories>
        <category>UEFI</category>
      </categories>
      <tags>
        <tag>UEFI</tag>
      </tags>
  </entry>
  <entry>
    <title>UEFI 详解</title>
    <url>/2020/06/22/UEFI-%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/UEFI-%E8%AF%A6%E8%A7%A3/静默山水.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">静默山水</div>
</center>

<h4 id="一、UEFI-是什么？"><a href="#一、UEFI-是什么？" class="headerlink" title="一、UEFI 是什么？"></a>一、UEFI 是什么？</h4><p>UEFI - Unified Extensible Firmware Interface<br>从规范的角度来看，它是一个规范，定义了计算机操作系统和平台固件之间的接口规范.</p>
<a id="more"></a>

<p>从实体的角度来讲，BIOS 和 UEFI 是两种不同类型的计算机固件（什么是固件？就是固化在计算机主板上某个非易失存储区（EEPROM）中的小系统），计算机启动都是先启动它，然后加载真正的操作系统，计算机启动后进入配置界面，我们能直观看到的是 UEFI 固件的 UI，我们通过 UI 来配置这个固件的可配置项，比如：操作系统启动顺序，启动等待时间等等，在 BIOS 时代，所有的设置都只能存储在主板上，容量很小，无法扩展，而 UEFI 将基础固件烧制在主板存储区中，然后在磁盘上创建 EFI 系统分区来存储更多的内容和数据，通过 UEFI 规范来定义如何使用扩展的方式来定制和扩展功能。</p>
<h4 id="二、EFI-系统分区"><a href="#二、EFI-系统分区" class="headerlink" title="二、EFI 系统分区"></a>二、EFI 系统分区</h4><p>我们知道在 UEFI 之前的 BIOS 时代，操作系统的 bootlloader 是存放在主引导记录（MBR）中的，容量受限，所以 UEFI 中引入了一个新的系统分区 ESP (EFI System Partition) ，该分区用来存储操作系统的 bootloader 和 EFI 驱动程序等数据，当计算机启动后，UEFI 固件从该分区中加载所需要的硬件驱动，执行 bootloader 启动指定的操作系统。在 Windows 系统中默认该分区不可见，可以参照 如何查看 EFI 分区内容 查看 EFI 分区中的内容。</p>
<h4 id="三、EFI-可执行文件"><a href="#三、EFI-可执行文件" class="headerlink" title="三、EFI 可执行文件"></a>三、EFI 可执行文件</h4><p>UEFI 标准定义了一种可执行文件格式，所有的 UEFI 固件都能够执行以这种格式编写的代码，操作系统 bootloader 都采用这种格式编写，比如 Windows 10 64位操作系统的 bootloader 叫做 bootx64.efi，该文件存放在 EFI 系统分区的 Boot 文件夹下，如果一台机器上安装了多个厂商的操作系统，他们的 bootloader 都位于 EFI 系统分区的 Boot 目录中，UEFI 就是通过执行这个 bootloader 来启动指定的操作系统。</p>
<p><img src="https://s1.ax1x.com/2020/03/28/GkAytI.png" alt="GkAytI.png"></p>
<h4 id="四、GPT-分区表"><a href="#四、GPT-分区表" class="headerlink" title="四、GPT 分区表"></a>四、GPT 分区表</h4><p>GUID 分区表格式与 UEFI规范具有密切联系，而且它并不特别复杂，GPT 是 UEFI 规范提供的良好基础架构之一。GPT 仅仅是分区表的一种标准（磁盘起始位置的信息定义了磁盘所包含的分区）。相比 MBR/MS-DOS 分区表，这种分区表对分区的定义要好得多，并且 UEFI 规范要求 UEFI 兼容固件必须能识别 GPT（也要求固件能识别 MBR，以保证向后兼容）。</p>
<h4 id="五、BIOS-如何启动"><a href="#五、BIOS-如何启动" class="headerlink" title="五、BIOS 如何启动"></a>五、BIOS 如何启动</h4><p>在了解 UEFI 启动之前，我们看一下 BIOS 的启动过程，BIOS 启动过程非常简单，你需要在第一块磁盘上有一个 MBR（主引导记录，这是一个标准，它定义了一种格式来描述该磁盘分区，并在特定的地方包含一个 boot loader），BIOS 通过加载 MBR 中的这段 boot loader 代码去启动操作系统，操作系统安装程序负责在系统安装过程中将 boot loader 代码写入到 MBR 中的特定区域。</p>
<p><a href="https://imgchr.com/i/GkEzM8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/28/GkEzM8.png" alt="GkEzM8.png"></a></p>
<p>从 BIOS 的启动过程中我们可以看出，BIOS 方案存在以下问题：</p>
<ul>
<li>处理不便，你需要特殊工具来写入 MBR，如果要查看 MBR 中包含的内容，唯一的方法几乎就是把 MBR dump 出来，然后进行检查</li>
<li>MBR 容量受限，无法容纳现代操作系统的 bootloader</li>
<li>无法实现从其他启动目标来启动系统，比如：网络启动</li>
<li>固件层以上的其他层（比如在操作系统中）无法配置固件的启动行为，BIOS 没有提供相应机制</li>
</ul>
<h4 id="六、UEFI-如何启动"><a href="#六、UEFI-如何启动" class="headerlink" title="六、UEFI 如何启动"></a>六、UEFI 如何启动</h4><p>UEFI 规范定义了一个 boot manager, 它是一个固件策略引擎，可以灵活配置，通过下图的对比图可以看到 UEFI 的启动过程。整个流程没有什么神奇的地方，主要的优势是灵活性和可配置型以及可定制的安全性。</p>
<p><img src="https://s1.ax1x.com/2020/03/28/GkViIs.png" alt="GkViIs.png"></p>
<h4 id="七、Secure-Boot"><a href="#七、Secure-Boot" class="headerlink" title="七、Secure Boot"></a>七、Secure Boot</h4><p>安全启动解决的问题就是 rootkit 攻击问题。<br>UEFI 规范规定了固件可以包含一系列签名，并拒绝运行未签名或签名与固件中包含的签名不一致的 EFI 可执行文件，通俗地讲，安全启动就是使用非对称加密和数字签名技术来确保整个启动链的安全，所有不合法的 UEFI 执行程序和驱动程序都不允许执行，这样就解决了操作系统加载前的启动安全问题。当然这是一个可选项，用户可以在 UEFI 配置界面关闭 Secure Boot。</p>
<h4 id="八、为什么需要BIOS和UEFI？"><a href="#八、为什么需要BIOS和UEFI？" class="headerlink" title="八、为什么需要BIOS和UEFI？"></a>八、为什么需要BIOS和UEFI？</h4><p>与大多数人基本的概念不同，在某种意义上来说，X86体系比ARM体系更加开放。X86是很多小伙伴一起玩，以生态圈的概念提供产品，并对自己那部分负责；而ARM体系虽然也依赖生态圈，但最终有个大Boss统合整个生态链，提供最后产品并对该产品负总责。</p>
<p>X86生态圈玩家众多，有OS 厂商（OSV）定期发布操作系统，如Windows，Ubuntu；芯片厂商提供CPU，如Intel, AMD；主板厂商（OEM）提供电脑主板；独立硬件供应商（IHV）生产扩展板卡如显卡等等PCIE扩展卡，再如内存厂家推出一代一代不同的内存条等等。</p>
<p>DIY玩家可以自由选择搭配合适/兼容的产品搭配出自己心仪的机器，休闲上网用户花2000多元就可以搭配出一套可用的电脑，而游戏玩家则可能花费上万元才能满足游戏配置需求。还有些品牌机厂商如Dell和联想等，他们提供整套最终产品给用户。但他们实际上是在所有小伙伴的零件基础上拼凑出个产品，技术不强，话语权弱，并不能统一整个产业链。用户津津乐道的反而是用的什么CPU，安装的什么操作系统，用的那种显卡等等。Windows死机、蓝屏和缓慢等等时候，用户往往会抱怨微软和Intel，而不是品牌厂商。</p>
<p>ARM体系由最后品牌厂商统合整个产品，它负责打通整个产业链，并对其中所有部分负责，话语权极强，同时对技术也相对较强。用户面对的具体品牌的产品，而不是碎片化的各个部分。强势的如Apple，硬件软件一起抓，完全组成闭环的链条。稍差也如华为等安卓手机，要负责安卓系统在自己手机移植部分（BSP），客户出了问题并不会找谷歌，而会去找华为。</p>
<p>在X86生态圈十分强势的微软，自己负责操作系统开发，跳过品牌直接服务最终用户，甚至不经允许直接升级操作系统，闹出不少风波。强势也带来了副作用，它要直接面对数千数万种千奇百怪的硬件产品，如何才能用一个软件安装包服务于这么多种设备呢？必须要一个软件抽象层封装这些硬件差别！</p>
<p>这就引出了BIOS和UEFI的最主要的功能：初始化硬件和提供硬件的软件抽象。</p>
<p>ARM体系也要初始化具体主板相关硬件如GPIO和内存等，这些一般在BSP中完成。与X86体系不同之处在于这些硬件完全定制化，初始化的时候就预先知道有哪些设备，Solder Down了哪个品牌的哪种内存颗粒，到时候就照方抓药，初始化一大堆寄存器而已。X86系统配置情况在开机时候是不知道的，需要探测（Probe）、Training(内存和PCIe)和枚举（PCIe等等即插即用设备），相对较复杂。<br>BIOS和UEFI提供了整个主板、包括主板上外插的设备的软件抽象。通过探测、Training和枚举，BIOS就有了系统所有硬件的信息。它通过几组详细定义好的接口，把这些信息抽象后传递给操作系统，这些信息包括SMBIOS（专栏稍后介绍）、ACPI表（ACPI与UEFI），内存映射表（E820或者UEFI运行时）等等。通过这层映射，才能做到做到操作系统完全不改而能够适配到所有机型和硬件。<br>在某种程度上来讲，BIOS和UEFI是将操作系统BSP部分单独封装后下放到主板或者BIOS提供商来完成。这在过去带来了巨大的好处，WinXP、Win7现在还可以运行在更新的电脑硬件上，新的硬件只要自己更改一下就行了，兼容性是ARM体系所不能比拟的。当然割裂的生态圈也带来了用户感受的千差万别，这也受到广泛诟病。各自为政也窒息了创新，带来了同质化。为此，Intel越俎代庖，提出了变形本等等概念；而微软更直接出了Surface，似乎要与过去的小伙伴争食。其实这些都是不得已而为之，今后的发展还需要拭目以待。</p>
<p>arm社区最近为了进入x86的传统优势领域，也开始接受uefi，不过一般只在服务器领域。个别厂商为了支持Windows而在平板等设备支持uefi，某厂商在手机上也要引入uefi。不过这些只是支流，并且他们并不吧自己叫做BIOS，而叫做Bootloader。</p>
]]></content>
      <categories>
        <category>UEFI</category>
      </categories>
      <tags>
        <tag>UEFI</tag>
      </tags>
  </entry>
  <entry>
    <title>华为性格测试</title>
    <url>/2020/06/22/%E5%8D%8E%E4%B8%BA%E6%80%A7%E6%A0%BC%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/%E5%8D%8E%E4%B8%BA%E6%80%A7%E6%A0%BC%E6%B5%8B%E8%AF%95/p21383.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">钢铁侠</div>
</center>

<blockquote>
<p>华为的性格测试还是比较坑的，建议面试者在做之前看看攻略，自己就挂过一次，需要注意前后一致，还有不要想着领导别人，螺丝钉性格比较合适</p>
</blockquote>
<a id="more"></a>

<h4 id="1-最合适的性格"><a href="#1-最合适的性格" class="headerlink" title="1 最合适的性格"></a>1 最合适的性格</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我信守自己做出的承诺</span><br><span class="line"></span><br><span class="line">我觉得人们信守承诺相当重要</span><br><span class="line"></span><br><span class="line">我坚持按时完成任务</span><br><span class="line"></span><br><span class="line">我做事广泛听取别人的意见</span><br><span class="line"></span><br><span class="line">做事前我会征询大家的意见</span><br><span class="line"></span><br><span class="line">我愿意花时间去帮助别人</span><br><span class="line"></span><br><span class="line">我做事不喜欢半途而废</span><br><span class="line"></span><br><span class="line">我必须了解底层原理才能更有效的学习</span><br><span class="line"></span><br><span class="line">我倾向于根据客观事实做决定</span><br><span class="line"></span><br><span class="line">我必须找到解决问题的办法</span><br><span class="line"></span><br><span class="line">我需要了解论点背后的逻辑</span><br><span class="line"></span><br><span class="line">我喜欢创新</span><br><span class="line"></span><br><span class="line">做事时我喜欢有新方法、新点子</span><br><span class="line"></span><br><span class="line">我能想出很多主意</span><br><span class="line"></span><br><span class="line">我喜欢提出很多主意</span><br><span class="line"></span><br><span class="line">我喜欢提出独到的见解</span><br><span class="line"></span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>

<h4 id="2-适中的性格"><a href="#2-适中的性格" class="headerlink" title="2 适中的性格"></a>2 适中的性格</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我善于和别人建立融洽关系</span><br><span class="line"></span><br><span class="line">我喜欢有压力的环境下工作</span><br><span class="line"></span><br><span class="line">我喜欢忙碌的生活</span><br><span class="line"></span><br><span class="line">我需要有明确的远景计划</span><br><span class="line"></span><br><span class="line">我喜欢思考未来</span><br><span class="line"></span><br><span class="line">我给自己设定了长远目标</span><br><span class="line"></span><br><span class="line">我经常展望未来</span><br><span class="line"></span><br><span class="line">我对未来比较乐观</span><br><span class="line"></span><br><span class="line">我相信未来的事情会是好的</span><br><span class="line"></span><br><span class="line">我做事很有远见</span><br><span class="line"></span><br><span class="line">做事的时候我需要有章可循</span><br><span class="line"></span><br><span class="line">我做事井井有条</span><br><span class="line"></span><br><span class="line">我非常注重细节</span><br><span class="line"></span><br><span class="line">我善于同时处理多项任务</span><br><span class="line"></span><br><span class="line">我循规蹈矩地去做事情</span><br><span class="line"></span><br><span class="line">我喜欢对数据进行统计与分析</span><br><span class="line"></span><br><span class="line">我喜欢讨论抽象性的问题</span><br><span class="line"></span><br><span class="line">我善于处理数字资料</span><br><span class="line"></span><br><span class="line">我不容易被别人激怒</span><br><span class="line"></span><br><span class="line">不信任他人</span><br><span class="line"></span><br><span class="line">我在陌生朋友交流时会轻松自在</span><br><span class="line"></span><br><span class="line">我大部分时间是快乐的</span><br><span class="line"></span><br><span class="line">我有强烈的好奇心</span><br><span class="line"></span><br><span class="line">我喜欢有竞争的工作</span><br><span class="line"></span><br><span class="line">我是一个竞争心很强的人</span><br></pre></td></tr></table></figure>

<h4 id="3-不适合的性格"><a href="#3-不适合的性格" class="headerlink" title="3 不适合的性格"></a>3 不适合的性格</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我掌控着自己的未来</span><br><span class="line"></span><br><span class="line">我在重大事情发生前会紧张</span><br><span class="line"></span><br><span class="line">我想有人陪在我身边</span><br><span class="line"></span><br><span class="line">我坚持自己的做事方式</span><br><span class="line"></span><br><span class="line">我善于结交朋友</span><br><span class="line"></span><br><span class="line">我喜欢结识陌生人</span><br><span class="line"></span><br><span class="line">我善于谈判</span><br><span class="line"></span><br><span class="line">我善于推销</span><br><span class="line"></span><br><span class="line">我是个很健谈的人</span><br><span class="line"></span><br><span class="line">我关注别人的做事目的与做事动机</span><br><span class="line"></span><br><span class="line">我善于理解人们背后的的动机</span><br><span class="line"></span><br><span class="line">我善于体会他人的感受</span><br><span class="line"></span><br><span class="line">我要超越别人</span><br><span class="line"></span><br><span class="line">我有较大的野心</span><br><span class="line"></span><br><span class="line">我想成为团队中的领导</span><br><span class="line"></span><br><span class="line">我更愿意领导别人</span><br><span class="line"></span><br><span class="line">我喜欢挑战别人的想法</span><br><span class="line"></span><br><span class="line">我享受独自工作</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>性格测试</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓面试笔记</title>
    <url>/2020/06/22/%E5%AE%89%E5%8D%93%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/%E5%AE%89%E5%8D%93%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/438yjy.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">林间小格</div>
</center>

<blockquote>
<p>本科面试笔记</p>
</blockquote>
<a id="more"></a>
<h3 id="一、四大组件问题"><a href="#一、四大组件问题" class="headerlink" title="一、四大组件问题"></a>一、四大组件问题</h3><h4 id="1-四大组件是什么"><a href="#1-四大组件是什么" class="headerlink" title="1.四大组件是什么"></a>1.四大组件是什么</h4><p>1）Activity：用户可操作的可视化界面，为用户提供一个完成操作指令的窗口。一个 Activity 通常是一个单独的屏幕，Activity 通过 Intent 来进行通信。Android 中会维持一个 Activity Stack， 当一个新 Activity 创建时，它就会放到栈顶，这个 Activity 就处于运行状态。 </p>
<p>2）Service：服务，运行在手机后台，适合执行不需和用户交互且还需长期运行的任务。 </p>
<p>3）ContentProvider：内容提供者，使一个应用程序的指定数据集提供给其他应用程序，其 他应用可通过 ContentResolver 类从该内容提供者中获取或存入数据。它提供了一种跨进程 数据共享的方式，当数据被修改后，ContentResolver 接口的 notifyChange 函数通知那些注册 监控特定 URI 的 ContentObserver 对象。</p>
<p>4）Broadcast Receiver: 广播接收者，运用在应用程序间传输信息，可以使用广播接收器来让 应用对一个外部事件做出响应。</p>
<h4 id="2-Activity生命周期和简单用法"><a href="#2-Activity生命周期和简单用法" class="headerlink" title="2.Activity生命周期和简单用法"></a>2.Activity生命周期和简单用法</h4><p>Activity：onCreate()-&gt;onStart()-&gt;onResume()-&gt;onPause()-&gt;onStop()-&gt;onDestory() </p>
<p>onCreate()：为 Activity 设置布局，此时界面还不可见；</p>
<p>onStart(): Activity 可见但还不能与用户交互，不能获得焦点 </p>
<p>onRestart(): 重新启动 Activity 时被回调 </p>
<p>onResume(): Activity 可见且可与用户进行交互 </p>
<p>onPause(): 当前 Activity 暂停，不可与用户交互，但还可见。在新 Activity 启动前被系统调用 保存现有的 Activity 中的持久数据、停止动画等。 </p>
<p>onStop(): 当 Activity 被新的 Activity 覆盖不可见时被系统调用 onDestory(): 当 Activity 被系统销毁杀掉或是由于内存不足时调用</p>
<p>onDestory(): 当 Activity 被系统销毁杀掉或是由于内存不足时调用</p>
<h4 id="3-Service生命周期和简单用法"><a href="#3-Service生命周期和简单用法" class="headerlink" title="3.Service生命周期和简单用法"></a>3.Service生命周期和简单用法</h4><p>a) onBind 方式绑定的：onCreate-&gt;onBind-&gt;onUnBind-&gt;onDestory（不管调用 bindService 几次，<br>onCreate 只会调用一次，onStart 不会被调用，建立连接后，service 会一直运行，直到调用 unBindService 或是之前调用的 bindService 的 Context 不存在了，系统会自动停止 Service,对 应的 onDestory 会被调用） </p>
<p>b) startService 启动的：onCreate-&gt;onStartCommand-&gt;onDestory(start 多次，onCreate 只会被 调用一次，onStart会调用多次，该 service 会在后台运行，直至被调用stopService 或是stopSelf) </p>
<p>c) 又被启动又被绑定的服务，不管如何调用 onCreate()只被调用一次，startService 调用多少 次，onStart 就会被调用多少次，而 unbindService 不会停止服务，必须调用 stopService 或是 stopSelf 来停止服务。必须 unbindService 和 stopService(stopSelf）同时都调用了才会停止服 务。</p>
<h4 id="4-BroadcastReceiver-生命周期和简单用法"><a href="#4-BroadcastReceiver-生命周期和简单用法" class="headerlink" title="4.BroadcastReceiver 生命周期和简单用法"></a>4.BroadcastReceiver 生命周期和简单用法</h4><p>a) 动态注册：存活周期是在 Context.registerReceiver 和 Context.unregisterReceiver 之间， BroadcastReceiver 每次收到广播都是使用注册传入的对象处理的。 </p>
<p>b) 静态注册：进程在的情况下，receiver 会正常收到广播，调用 onReceive 方法；生命周期 只存活在 onReceive 函数中，此方法结束，BroadcastReceiver 就销毁了。onReceive()只有十 几秒存活时间，在 onReceive()内操作超过 10S，就会报 ANR。 </p>
<hr>
<p>动态注册广播与静态注册广播的区别</p>
<p>（1）动态注册广播不是常驻型广播，也就是说广播跟随Activity的生命周期。注意在Activity结束前，移除广播接收器。</p>
<p>静态注册是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</p>
<p>（2）当广播为有序广播时：优先级高的先接收（不分静态和动态）。同优先级的广播接收器，动态优先于静态</p>
<p>（3）同优先级的同类广播接收器，静态：先扫描的优先于后扫描的，动态：先注册的优先于后注册的。</p>
<p>（4）当广播为默认广播时：无视优先级，动态广播接收器优先于静态广播接收器。同优先级的同类广播接收器，静态：先扫描的优先于后扫描的，动态：先注册的优先于后册的。</p>
<h4 id="5-ContentProvider-生命周期和简单用法"><a href="#5-ContentProvider-生命周期和简单用法" class="headerlink" title="5.ContentProvider 生命周期和简单用法"></a>5.ContentProvider 生命周期和简单用法</h4><p>ContentProvider：应该和应用的生命周期一样，它属于系统应用，应用启动时，它会跟着初始化，应用关闭或被杀，它会跟着结束。</p>
<h4 id="6-Activity-之间的通信方式"><a href="#6-Activity-之间的通信方式" class="headerlink" title="6.Activity 之间的通信方式"></a>6.Activity 之间的通信方式</h4><p>1）通过 Intent 方式传递参数跳转 </p>
<p>2）通过广播方式 </p>
<p>3）通过接口回调方式 </p>
<p>4）借助类的静态变量或全局变量 </p>
<p>5）借助 SharedPreference或是外部存储，如数据库或本地文件</p>
<h4 id="7-Activity-各种情况下的生命周期"><a href="#7-Activity-各种情况下的生命周期" class="headerlink" title="7.Activity 各种情况下的生命周期"></a>7.Activity 各种情况下的生命周期</h4><ol>
<li>两 个 Activity(A-&gt;B) 切 换 (B 正 常 的 Activity) 的 生 命 周 期 ： onPause(A)-&gt;onCreate(B)-&gt;onStart(B)-&gt;onResume(B)-&gt;oStop(A) 这时如果按回退键回退到 A onPause(B)-&gt;onRestart(A)-&gt;onStart(A)-&gt;onResume(A)-&gt;oStop(B)<br>如果在切换到 B 后调用了 A.finish()，则会走到 onDestory(A)，这时点回退键会退出应用 </li>
</ol>
<p>2) 两个 Activity(A-&gt;B)切换(B 透明主题的 Activity 或是 Dialog 风格的 Acivity)的生命周期： onPause(A)-&gt;onCreate(B)-&gt;onStart(B)-&gt;onResume(B) 这时如果回退到 A onPause(B)-&gt;onResume(A)-&gt;oStop(B)-&gt;onDestory(B) </p>
<p>3) Activity(A) 启 动 后 点 击 Home 键 再 回 到 应 用 的 生 命 周 期 ： onPause(A)-&gt;oStop(A)-&gt;onRestart(A)-&gt;onStart(A)-&gt;onResume(A)</p>
<p>4) Activity 上有 Dialog 的时候, Dialog 并不会影响 Activity 的生命周期</p>
<h4 id="8-横竖屏切换的时候，Activity-各种情况下的生命周期"><a href="#8-横竖屏切换的时候，Activity-各种情况下的生命周期" class="headerlink" title="8.横竖屏切换的时候，Activity 各种情况下的生命周期"></a>8.横竖屏切换的时候，Activity 各种情况下的生命周期</h4><ol>
<li>切换横屏时 ： onSaveInstanceState-&gt;onPause-&gt;onStop-&gt;onDestory-&gt;onCreate-&gt;onStart-&gt;onRestoreInstanceSta te-&gt;onResume </li>
</ol>
<p>2) 切换竖屏时：会打印两次相同的log onSaveInstanceState-&gt;onPause-&gt;onStop-&gt;onDestory-&gt;onCreate-&gt;onStart-&gt;onRestoreInstanceSta te-&gt;onResume-&gt;onSaveInstanceState-&gt;onPause-&gt;onStop-&gt;onDestory-&gt;onCreate-&gt;onStart-&gt;onRe storeInstanceState-&gt;onResume </p>
<p>3) 如 果 在 AndroidMainfest.xml 中 修 改 该 Activity 的 属 性 ， 添 加 android:configChanges=”orientation” 横竖屏切换，打印的 log 一样，同 1) </p>
<h4 id="9-Fragment-生命周期"><a href="#9-Fragment-生命周期" class="headerlink" title="9.Fragment 生命周期"></a>9.Fragment 生命周期</h4><ul>
<li>Fragment 生命周期 :onAttach-&gt;onCreate-&gt;onCreateView-&gt;onActivityCreated-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestoryView-&gt;onDestory-&gt;onDetach </li>
<li>切换到该Fragment ： onAttach-&gt;onCreate-&gt;onCreateView-&gt;onActivityCreated-&gt;onStart-&gt;onResume </li>
<li>按下Power键：onPause-&gt;onSaveInstanceState-&gt;onStop </li>
<li>点亮屏幕解锁：onStart-&gt;onRestoreInstanceState-&gt;onResume </li>
<li>切换到其他 Fragment:onPause-&gt;onStop-&gt;onDestoryView</li>
<li>切回到该Fragment: onCreateView-&gt;onActivityCreated-&gt;onStart-&gt;onResume </li>
<li>退出应用：onPause-&gt;onStop-&gt;onDestoryView-&gt;onDestory-&gt;onDetach</li>
</ul>
<hr>
<p>Fragment与Activity生命周期关系</p>
<p><img src="https://s1.ax1x.com/2020/03/26/GpCAh9.png" alt="GpCAh9.png"></p>
<h4 id="10-Activity-的四种启动模式对比"><a href="#10-Activity-的四种启动模式对比" class="headerlink" title="10.Activity 的四种启动模式对比"></a>10.Activity 的四种启动模式对比</h4><ol>
<li>standard：标准启动模式（默认），每启动一次 Activity，都会创建一个实例，即使从 ActivityA startActivity ActivityA,也会再次创建 A 的实例放于栈顶，当回退时，回到上一个 ActivityA 的 实例。<br>2) singleTop：栈顶复用模式，每次启动 Activity，如果待启动的 Activity 位于栈顶，则不会重 新 创 建 Activity 的 实 例 ， 即 不 会 走 onCreate-&gt;onStart ， 会 直 接 进 入 Activity 的 onPause-&gt;onNewIntent-&gt;onResume 方法<br>3) singleInstance: 单一实例模式，整个手机操作系统里只有一个该 Activity 实例存在，没有 其 他 Actvity,后 续 请 求 均 不 会 创 建 新 的 Activity 。 若 task 中 存 在 实 例 ， 执 行 实 例 的 onNewIntent()。应用场景：闹钟、浏览器、电话<br>4) singleTask：栈内复用，启动的 Activity 如果在指定的 taskAffinity 的 task 栈中存在相应的实 例，则会把它上面的 Activity 都出栈，直到当前 Activity 实例位于栈顶，执行相应的 onNewIntent()方法。如果指定的 task 不存在，创建指定的 taskAffinity 的 task,taskAffinity 的 作用，进入指写 taskAffinity 的 task,如果指定的 task 存在，将 task 移到前台，如果指定的 task 不存在，创建指定的 taskAffinity 的 task. 应用场景：应用的主页面</li>
</ol>
<h4 id="11-说说-ContentProvider、ContentResolver、ContentObserver-之间的关系"><a href="#11-说说-ContentProvider、ContentResolver、ContentObserver-之间的关系" class="headerlink" title="11.说说 ContentProvider、ContentResolver、ContentObserver 之间的关系"></a>11.说说 ContentProvider、ContentResolver、ContentObserver 之间的关系</h4><p>ContentProvider实现各个应用程序间数据共享，用来提供内容给别的应用操作。如联系人应用中就使用了ContentProvider，可以在自己应用中读取和修改联系人信息，不过需要获取相应的权限。它也只是一个中间件，真正的数据源是文件或SQLite等。</p>
<p>ContentResolver内容解析者 ， 用于获取内容提供者提供的数据 ，通过ContentResolver.notifyChange(uri)发出消息 </p>
<p>ContentObserver内容监听者，可以监听数据的改变状态，观察特定 Uri 引起的数据库变化， 继而做一些相应的处理，类似于数据库中的触发器，当 ContentObserver 所观察的 Uri 发生 变化时，便会触发它。</p>
<h4 id="12-下广播-BroadcastReceiver-的理解"><a href="#12-下广播-BroadcastReceiver-的理解" class="headerlink" title="12.下广播 BroadcastReceiver 的理解"></a>12.下广播 BroadcastReceiver 的理解</h4><ul>
<li><p>BroadcastReceiver 是一种全局监听器，用来实现系统中不同组件之间的通信。</p>
</li>
<li><p>有时候也会用 来作为传输少量而且发送频率低的数据，但是如果数据的发送频率比较高或者数量比较大就 不建议用广播接收者来接收了，因为这样的效率很不好，因为 BroadcastReceiver 接收数据的 开销还是比较大的。</p>
</li>
</ul>
<h4 id="13-如何实现-Fragment-的滑动？"><a href="#13-如何实现-Fragment-的滑动？" class="headerlink" title="13.如何实现 Fragment 的滑动？"></a>13.如何实现 Fragment 的滑动？</h4><p>ViewPager+FragmentPagerAdapter+List<Fragment></Fragment></p>
<h4 id="14-fragment-之间传递数据的方式？"><a href="#14-fragment-之间传递数据的方式？" class="headerlink" title="14.fragment 之间传递数据的方式？"></a>14.fragment 之间传递数据的方式？</h4><p>1) 在相应的 fragment 中编写方法，在需要回调的 fragment 里获取对应的 Fragment 实例，调 用相应的方法； </p>
<ol start="2">
<li>采用接口回调的方式进行数据传递； </li>
</ol>
<ul>
<li>a) 在 Fragment1中创建一个接口及接口对应的set 方法; </li>
<li>b) 在Fragment1 中调用接口的方法； </li>
<li>c)在 Fragment2 中实现该接口； </li>
</ul>
<p>3）利用第三方开源框架 EventBus</p>
<h4 id="15-service-和-activity-怎么进行数据交互？"><a href="#15-service-和-activity-怎么进行数据交互？" class="headerlink" title="15.service 和 activity 怎么进行数据交互？"></a>15.service 和 activity 怎么进行数据交互？</h4><p>1）通过 bindService 启动服务，可以在 ServiceConnection 的 onServiceConnected 中获取到 Service 的实例，这样就可以调用 service 的方法，如果 service 想调用 activity 的方法，可以 在 service 中定义接口类及相应的 set 方法，在activity中实现相应的接口，这样 service 就可 以回调接口言法； </p>
<p>2）通过广播方式</p>
<h4 id="16-在-manifest-和代码中如何注册和使用-BroadcastReceiver"><a href="#16-在-manifest-和代码中如何注册和使用-BroadcastReceiver" class="headerlink" title="16.在 manifest 和代码中如何注册和使用 BroadcastReceiver?"></a>16.在 manifest 和代码中如何注册和使用 BroadcastReceiver?</h4><p>1）mainfest 中注册:静态注册的广播接收者就是一个常驻在系统中的全局监听器，也就是说 如果你应用中配置了一个静态的 BroadcastReceiver，而且你安装了应用而无论应用是否处于 运行状态，广播接收者都是已经常驻在系统中了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;receiver android:name&#x3D;&quot;.MyBroadcastReceiver&quot;&gt; </span><br><span class="line">    &lt;intent-filter&gt; </span><br><span class="line">        &lt;action android:name&#x3D;&quot;com.smilexie.test.intent.mybroadcastreceiver&quot;&#x2F;&gt; </span><br><span class="line">    &lt;&#x2F;intent-filter&gt; </span><br><span class="line">&lt;&#x2F;receiver&gt;</span><br></pre></td></tr></table></figure>
<p>2) 动态注册:动态注册的广播接收者只有执行了 registerReceiver(receiver, filter)才会开始监听 广播消息，并对广播消息作为相应的处理。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IntentFilter fiter &#x3D; new IntentFilter(&quot;com.smilexie.test.intent.mybroadcastreceiver&quot;); </span><br><span class="line">MyBroadcastReceiver receiver &#x3D; new MyBroadcastReceiver(); </span><br><span class="line">registerReceiver(receiver, filter);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;撤销广播接受者的动态注册 unregisterReceiver(receiver);</span><br></pre></td></tr></table></figure>

<h4 id="17-AlertDialog-popupWindow区别"><a href="#17-AlertDialog-popupWindow区别" class="headerlink" title="17.AlertDialog,popupWindow区别"></a>17.AlertDialog,popupWindow区别</h4><p>（1）Popupwindow 在显示之前一定要设置宽高，Dialog 无此限制。 </p>
<p>（2）Popupwindow 默认不会响应物理键盘的 back，除非显示设置了 popup.setFocusable(true); 而在点击 back 的时候，Dialog 会消失。</p>
<p>（3）Popupwindow 不会给页面其他的部分添加蒙层，而Dialog 会。  </p>
<p>（4） Popupwindow 没有标题 ， Dialog 默认有标 题 ， 可以通过 dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);取消标题 </p>
<p>（5）二者显示的时候都要设置 Gravity。如果不设置，Dialog 默认是 Gravity.CENTER。</p>
<h4 id="18-HttpClient-与-HttpUrlConnection-的区别"><a href="#18-HttpClient-与-HttpUrlConnection-的区别" class="headerlink" title="18.HttpClient 与 HttpUrlConnection 的区别"></a>18.HttpClient 与 HttpUrlConnection 的区别</h4><ul>
<li><p>首先 HttpClient 和 HttpUrlConnection 这两种方式都支持 Https 协议，都是以流的形式进行上<br>传或者下载数据，也可以说是以流的形式进行数据的传输，还有 ipv6,以及连接池等功能。 </p>
</li>
<li><p>HttpClient 这个拥有非常多的 API，所以如果想要进行扩展的话，并且不破坏它的兼容性的话， 很难进行扩展，也就是这个原因，Google 在 Android6.0 的时候，直接就弃用了这个 HttpClient. </p>
</li>
<li><p>而HttpUrlConnection 相对来说就是比较轻量级了，API 比较少，容易扩展，并且能够满足 Android 大部分的数据传输。比较经典的一个框架 volley，在 2.3 版本以前都是使用 HttpClient, 在 2.3 以后就使用了 HttpUrlConnection。</p>
</li>
</ul>
<h4 id="19-java-虚拟机和-Dalvik-虚拟机的区别"><a href="#19-java-虚拟机和-Dalvik-虚拟机的区别" class="headerlink" title="19.java 虚拟机和 Dalvik 虚拟机的区别"></a>19.java 虚拟机和 Dalvik 虚拟机的区别</h4><p>Java 虚拟机： </p>
<ul>
<li><p>1、java 虚拟机基于栈。 基于栈的机器必须使用指令来载入和操作栈上数据，所需指令更多。</p>
</li>
<li><p>2、java 虚拟机运行的是 java 字节码。（java 类会被编译成一个或多个字节码.class 文件） </p>
</li>
</ul>
<p>Dalvik 虚拟机： </p>
<ul>
<li><p>1、dalvik 虚拟机是基于寄存器的 </p>
</li>
<li><p>2、Dalvik 运行的是自定义的.dex 字节码格式。（java 类被编译成.class 文件后，会通过一个 dx 工具将所有的.class 文件转换成一个.dex 文件，然后 dalvik 虚拟机会从其中读取指令和数 据</p>
</li>
<li><p>3、常量池已被修改为只使用 32 位的索引，以 简化解释器。</p>
</li>
<li><p>4、一个应用，一个虚拟机实例，一个进程（所有 android 应用的线程都是对应一个 linux 线 程，都运行在自己的沙盒中，不同的应用在不同的进程中运行。每个 android dalvik 应用程 序都被赋予了一个独立的 linux PID(app_*)</p>
</li>
</ul>
<h4 id="20-进程保活"><a href="#20-进程保活" class="headerlink" title="20.进程保活"></a>20.进程保活</h4><p>当前业界的 Android 进程保活手段主要分为黑、白、灰三种，其大致的实现思路如下： </p>
<ol>
<li>黑色保活：不同的 app 进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所谓黑色保活，就是利用不同的 app 进程使用广播来进行相互唤醒。</span><br><span class="line"></span><br><span class="line">举个3个比较常见的场景：</span><br><span class="line">1：开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒 app 场景 </span><br><span class="line"></span><br><span class="line">2：接入第三方 SDK 也会唤醒相应的 app 进程，如微信 sdk 会唤醒微信，支付宝 sdk 会 唤醒支付宝。由此发散开去，就会直接触发了下面的场景3场景 </span><br><span class="line"></span><br><span class="line">3：假如你手机里装了支付宝、淘宝、天猫、UC 等阿里系的 app，那么你打开任意一个阿里系的 app 后，有可能就顺便把其他阿里系的 app 给唤醒了。（只是拿阿里打个比方，其实BAT系都差不多）</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>白色保活：启动前台 Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">白色保活手段非常简单，就是调用系统 api 启动一个前台的 Service 进程，这样会在系统的 通知栏生成一个 Notification，用来让用户知道有这样一个 app 在运行着，哪怕当前的 app 退到了后台。</span><br></pre></td></tr></table></figure>
</li>
<li><p>灰色保活：利用系统的漏洞启动前台 Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">灰色保活，这种保活手段是应用范围最广泛。它是利用系统的漏洞来启动一个前台的 Service 进程，与普通的启动方式区别在于，它不会在系统通知栏处出现一个 Notification，看起来就 </span><br><span class="line">如同运行着一个后台 Service 进程一样。这样做带来的好处就是，用户无法察觉到你运行着 一个前台进程（因为看不到 Notification）,但你的进程优先级又是高于普通后台</span><br><span class="line">进程的。那 么如何利用系统的漏洞呢，大致的实现思路和代码如下： </span><br><span class="line"></span><br><span class="line">思路一：API &lt; 18，启动前台 Service 时直接传入 new Notification()； </span><br><span class="line"></span><br><span class="line">思路二：API &gt;&#x3D; 18，同时启动两个 id 相同的前台 Service，然后再将后启动的 Service 做 stop 处理</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="21-什么是-oom-adj？"><a href="#21-什么是-oom-adj？" class="headerlink" title="21.什么是 oom_adj？"></a>21.什么是 oom_adj？</h4><p>概念</p>
<ul>
<li>它是 linux 内核分配给 每个系统进程的一个值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收。</li>
</ul>
<p>对于 oom_adj 的作用，你只需要记住以下几点即可： </p>
<ul>
<li>进程的 oom_adj 越大，表示此进程优先级越低，越容易被杀回收；越小，表示进程优先级 越高，越不容易被杀回收 </li>
<li>普通 app 进程的 oom_adj&gt;=0,系统进程的 oom_adj 才可能&lt;0 </li>
<li>有些手机厂商把这些知名的 app 放入了自己的白名单中，保证了进程不死来提高用户体验 （如微信、QQ、陌陌都在小米的白名单中）。如果从白名单中移除，他们终究还是和普通 app 一样躲避不了被杀的命运，为了尽量避免被杀，还是老老实实去做好优化工作吧。 </li>
<li>所以，进程保活的根本方案终究还是回到了性能优化上，进程永生不死终究是个彻头彻尾的 伪命题！</li>
</ul>
<h4 id="22-讲解一下-Context"><a href="#22-讲解一下-Context" class="headerlink" title="22.讲解一下 Context"></a>22.讲解一下 Context</h4><ul>
<li>Context 是一个抽象基类。在翻译为上下文，也可以理解为环境，是提供一些程序的运行环境基础信息。</li>
<li>Context 下有两个子类，ContextWrapper 是上下文功能的封装类，而 ContextImpl 则是上下文功能的实现类。而ContextWrapper又有三个直接的子类，ContextThemeWrapper、 Service 和 Application。</li>
<li>Context 一共有三种类型，分别是 Application、Activity 和 Service。这三个类虽然分别各种承担着不同的作用，但它们都属于 Context 的一种，而它 们具体 Context 的功能则是由 ContextImpl 类去实现的，因此在绝大多数场景下，Activity、 Service 和 Application 这三种类型的 Context 都是可以通用的。</li>
<li>Context 一共有三种类型，分别是 Application、Activity 和 Service。这三个类虽然分别各种承担着不同的作用，但它们都属于 Context 的一种，而它 们具体 Context 的功能则是由 ContextImpl 类去实现的，因此在绝大多数场景下，Activity、 Service 和 Application 这三种类型的 Context 都是可以通用的。</li>
<li>getApplicationContext()和 getApplication()方法得到的对象都是同一个 application 对象，只是 对象的类型不一样。</li>
<li>Context 数量 = Activity 数量 + Service 数量 + 1 （1 为 Application）</li>
</ul>
<h4 id="23-理解-Activity，View-Window-三者关系"><a href="#23-理解-Activity，View-Window-三者关系" class="headerlink" title="23.理解 Activity，View, Window 三者关系"></a>23.理解 Activity，View, Window 三者关系</h4><p>Activity 像一个工匠（控制单元），Window 像窗户（承载模型），View 像窗花（显示视图） LayoutInflater 像剪刀，Xml 配置像窗花图纸。 </p>
<p>1：Activity 构造的时候会初始化一个 Window，准确的说是 PhoneWindow。</p>
<p>2：这个 PhoneWindow 有一个“ViewRoot”，这个“ViewRoot”是一个 View 或者说 ViewGroup， 是最初始的根视图。 </p>
<p>3：“ViewRoot”通过 addView 方法来一个个的添加 View。比如 TextView，Button 等。</p>
<p>4：这些 View 的事件监听，是由 Window完成的。</p>
<h4 id="24-View-的绘制流程"><a href="#24-View-的绘制流程" class="headerlink" title="24.View 的绘制流程"></a>24.View 的绘制流程</h4><p>View 的绘制流程：OnMeasure()——&gt;OnLayout()——&gt;OnDraw() </p>
<p>第一步：OnMeasure()：测量视图大小。从顶层父 View 到子 View 递归调用 measure 方法， measure 方法又回调 OnMeasure。 </p>
<p>第二步：OnLayout()：确定 View 位置，进行页面布局。从顶层父 View 向子 View 的递归调用 view.layout 方法的过程，即父 View 根据上一步 measure 子 View 所得到的布局大小和布局参 数，将子 View 放在合适的位置上。 </p>
<p>第三步：OnDraw()：绘制视图。ViewRoot 创建一个 Canvas 对象，然后调用 OnDraw()。六个 步骤：</p>
<p>①、绘制视图的背景；</p>
<p>②、保存画布的图层（Layer）；</p>
<p>③、绘制 View 的内容；</p>
<p>④、绘制 View 子视图，如果没有就不用；</p>
<p>⑤、还原图层（Layer）；</p>
<p>⑥、绘制滚动条。</p>
<h4 id="25-View，ViewGroup-事件分发"><a href="#25-View，ViewGroup-事件分发" class="headerlink" title="25.View，ViewGroup 事件分发"></a>25.View，ViewGroup 事件分发</h4><ol>
<li><p>Touch 事件分发中只有两个主角:ViewGroup 和 View。ViewGroup 包含 onInterceptTouchEvent、 dispatchTouchEvent、onTouchEvent 三个相关事件。View 包含 dispatchTouchEvent、onTouchEvent 两个相关事件。其中 ViewGroup 又继承于 View。 </p>
</li>
<li><p>ViewGroup 和 View 组成了一个树状结构，根节点为 Activity 内部包含的一个 ViwGroup。</p>
</li>
<li><p>触摸事件由 Action_Down、Action_Move、Aciton_UP 组成，其中一次完整的触摸事件中， Down 和 Up 都只有一个，Move 有若干个，可以为 0 个。 </p>
</li>
<li><p>当 Acitivty 接收到 Touch 事件时，将遍历子 View 进行 Down 事件的分发。ViewGroup 的遍 历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的 View，这个 View 会在 onTouchuEvent 结果返回 true。 </p>
</li>
<li><p>当某个子 View 返回 true 时，会中止 Down 事件的分发，同时在 ViewGroup 中记录该子 View。 接下去的 Move 和 Up 事件将由该子 View 直接进行处理。由于子 View 是保存在 ViewGroup 中的，多层 ViewGroup 的节点结构时，上级 ViewGroup 保存的会是真实处理事件的 View 所 在的 ViewGroup 对象:如 ViewGroup0-ViewGroup1-TextView 的结构中，TextView 返回了 true，<br>它将被保存在 ViewGroup1 中，而 ViewGroup1 也会返回 true，被保存在 ViewGroup0 中。当 Move 和 UP 事件来时，会先从 ViewGroup0 传递至 ViewGroup1，再由 ViewGroup1 传递至 TextView。 </p>
</li>
<li><p>当 ViewGroup 中所有子 View 都不捕获 Down 事件时，将触发 ViewGroup 自身的 onTouch 事件。触发的方式是调用 super.dispatchTouchEvent 函数，即父类 View 的 dispatchTouchEvent 方法。在所有子 View 都不处理的情况下，触发 Acitivity 的 onTouchEvent 方法。 </p>
</li>
<li><p>onInterceptTouchEvent 有两个作用：1.拦截 Down 事件的分发。2.中止 Up 和 Move 事件向 目标 View 传递，使得目标 View 所在的 ViewGroup 捕获 Up 和 Move 事件。</p>
</li>
</ol>
<h4 id="26-Android-中的几种动画"><a href="#26-Android-中的几种动画" class="headerlink" title="26.Android 中的几种动画"></a>26.Android 中的几种动画</h4><p>帧动画：指通过指定每一帧的图片和播放时间，有序的进行播放而形成动画效果，比如想听 的律动条。 </p>
<p>补间动画：指通过指定 View 的初始状态、变化时间、方式，通过一系列的算法去进行图形 变换，从而形成动画效果，主要有 Alpha、Scale、Translate、Rotate 四种效果。注意：只是 在视图层实现了动画效果，并没有真正改变 View 的属性，比如滑动列表，改变标题栏的透 明度。 </p>
<p>属性动画：在 Android3.0 的时候才支持，通过不断的改变 View 的属性，不断的重绘而形成 动画效果。相比于视图动画，View 的属性是真正改变了。比如 view 的旋转，放大，缩小。</p>
<h4 id="27-Android-中跨进程通讯的几种方式"><a href="#27-Android-中跨进程通讯的几种方式" class="headerlink" title="27.Android 中跨进程通讯的几种方式"></a>27.Android 中跨进程通讯的几种方式</h4><ul>
<li><p>intent：这种跨进程方式并不是访问内存的形式，它需要传递一个 uri,比如说打电话。 </p>
</li>
<li><p>contentProvider：这种形式，是使用数据共享的形式进行数据共享。 </p>
</li>
<li><p>service：远程服务，aidl</p>
</li>
<li><p>广播</p>
</li>
</ul>
<h4 id="28-AIDL-理解"><a href="#28-AIDL-理解" class="headerlink" title="28.AIDL 理解"></a>28.AIDL 理解</h4><p>AIDL: 每一个进程都有自己的 Dalvik VM 实例，都有自己的一块独立的内存，都在自己的内 存上存储自己的数据，执行着自己的操作，都在自己的那片狭小的空间里过完自己的一生。</p>
<p>而 aidl 就类似与两个进程之间的桥梁，使得两个进程之间可以进行数据的传输，跨进程通信 有多种选择，比如 BroadcastReceiver , Messenger 等，但是 BroadcastReceiver 占用的系统 资源比较多，如果是频繁的跨进程通信的话显然是不可取的；Messenger 进行跨进程通信时 请求队列是同步进行的，无法并发执行。</p>
<h4 id="29-Binder-机制简单理解"><a href="#29-Binder-机制简单理解" class="headerlink" title="29.Binder 机制简单理解"></a>29.Binder 机制简单理解</h4><p>在 Android 系统的 Binder 机制中，是有Client,Service,ServiceManager,Binder 驱动程序组成的， 其中 Client，service，Service Manager 运行在用户空间，Binder 驱动程序是运行在内核空间 的。而 Binder 就是把这 4 种组件粘合在一块的粘合剂，其中核心的组件就是 Binder 驱动程 序，Service Manager 提供辅助管理的功能，而 Client 和 Service 正是在 Binder 驱动程序和 Service Manager 提供的基础设施上实现 C/S 之间的通信。其中 Binder 驱动程序提供设备文 件/dev/binder 与用户控件进行交互</p>
<p>Client、Service，Service Manager 通过 open 和 ioctl 文件操作相应的方法与 Binder 驱动程序 进行通信。而Client和Service之间的进程间通信是通过Binder驱动程序间接实现的。而Binder Manager 是一个守护进程，用来管理 Service，并向 Client 提供查询 Service 接口的能力。</p>
<h4 id="30-Handler-的原理"><a href="#30-Handler-的原理" class="headerlink" title="30.Handler 的原理"></a>30.Handler 的原理</h4><p>Android 中主线程是不能进行耗时操作的，子线程是不能进行更新 UI 的。所以就有了 handler， 它的作用就是实现线程之间的通信。</p>
<p>handler 整个流程中，主要有四个对象，handler，Message,MessageQueue,Looper。当应用创 建的时候，就会在主线程中创建 handler 对象， </p>
<p>我们通过要传送的消息保存到 Message 中，handler 通过调用 sendMessage 方法将 Message 发送到 MessageQueue 中，Looper 对象就会不断的调用 loop()方法 </p>
<p>不断的从 MessageQueue 中取出 Message 交给 handler 进行处理。从而实现线程之间的通信。</p>
<h4 id="31-热修复的原理"><a href="#31-热修复的原理" class="headerlink" title="31.热修复的原理"></a>31.热修复的原理</h4><p>我们知道 Java 虚拟机 —— JVM 是加载类的 class 文件的，而 Android 虚拟机——Dalvik/ART VM 是加载类的 dex 文件， 而他们加载类的时候都需要 ClassLoader,ClassLoader 有一个子类 BaseDexClassLoader，而 BaseDexClassLoader 下有一个 数组——DexPathList，是用来存放 dex 文件，当 BaseDexClassLoader 通过调用 findClass 方法 时，实际上就是遍历数组， 找到相应的 dex 文件，找到，则直接将它 return。</p>
<p>而热修复的解决方法就是将新的 dex 添加 到该集合中，并且是在旧的 dex 的前面， 所以就会优先被取出来并且 return 返回。</p>
<h4 id="32-内存泄露原因"><a href="#32-内存泄露原因" class="headerlink" title="32.内存泄露原因"></a>32.内存泄露原因</h4><p>一、Handler 引起的内存泄漏。 </p>
<p>解决：将 Handler 声明为静态内部类，就不会持有外部类 SecondActivity 的引用，其生命周 期就和外部类无关， 如果 Handler 里面需要 context 的话，可以通过弱引用方式引用外部类 </p>
<p>二、单例模式引起的内存泄漏。 </p>
<ul>
<li>解决：Context 是 ApplicationContext，由于 ApplicationContext 的生命周期是和 app 一致的， 不会导致内存泄漏 </li>
</ul>
<p>三、非静态内部类创建静态实例引起的内存泄漏。 </p>
<ul>
<li>解决：把内部类修改为静态的就可以避免内存泄漏了 </li>
</ul>
<p>四、非静态匿名内部类引起的内存泄漏。</p>
<ul>
<li>解决：将匿名内部类设置为静态的。 </li>
</ul>
<p>五、注册/反注册未成对使用引起的内存泄漏。 </p>
<ul>
<li>注册广播接受器、EventBus 等，记得解绑。 </li>
</ul>
<p>六、资源对象没有关闭引起的内存泄漏。 </p>
<ul>
<li>在这些资源不使用的时候，记得调用相应的类似 close（）、destroy（）、recycler（）、release （）等方法释放。 </li>
</ul>
<p>七、集合对象没有及时清理引起的内存泄漏。 </p>
<ul>
<li>通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不 再被引用。</li>
</ul>
<h4 id="33-Android-UI-适配"><a href="#33-Android-UI-适配" class="headerlink" title="33.Android UI 适配"></a>33.Android UI 适配</h4><p>字体使用 sp,使用 dp，多使用 match_parent，wrap_content，weight </p>
<p>图片资源，不同图片的的分辨率，放在相应的文件夹下可使用百分比代替。</p>
<h4 id="34-App-启动优化-针对冷启动-App"><a href="#34-App-启动优化-针对冷启动-App" class="headerlink" title="34.App 启动优化(针对冷启动) App"></a>34.App 启动优化(针对冷启动) App</h4><p>启动的方式有三种： </p>
<ol>
<li>冷启动：App 没有启动过或 App 进程被 killed, 系统中不存在该 App 进程, 此时启动 App 即 为冷启动。 </li>
<li>热启动：热启动意味着你的 App 进程只是处于后台, 系统只是将其从后台带到前台, 展示给 用户。</li>
<li>介于冷启动和热启动之间, 一般来说在以下两种情况下发生: </li>
</ol>
<ul>
<li>(1)用户 back 退出了 App, 然后又启动. App 进程可能还在运行, 但是 activity 需要重建。 </li>
<li>(2)用户退出 App 后, 系统可能由于内存原因将 App 杀死, 进程和 activity 都需要重启, 但是 可以在 onCreate 中将被动杀死锁保存的状态(saved instance state)恢复。</li>
</ul>
<h4 id="35-ANR"><a href="#35-ANR" class="headerlink" title="35.ANR"></a>35.ANR</h4><p>概念 </p>
<ul>
<li>ANR 全名 Application Not Responding, 也就是”应用无响应”. 当操作在一段时间内系统无法 处理时, 系统层面会弹出上图那样的 ANR 对话框.</li>
</ul>
<p>解决方式：</p>
<p>(1)不要在主线程中做耗时的操作，而应放在子线程中来实现。如 onCreate()和 onResume() 里尽可能少的去做创建操作。 </p>
<p>(2)应用程序应该避免在 BroadcastReceiver 里做耗时的操作或计算。</p>
<p>(3)避免在 Intent Receiver 里启动一个 Activity，因为它会创建一个新的画面，并从当前用户正 在运行的程序上抢夺焦点。 </p>
<p>(4)service 是运行在主线程的，所以在 service 中做耗时操作，必须要放在子线程中。</p>
<h4 id="36-MVC，MVP，MVVM"><a href="#36-MVC，MVP，MVVM" class="headerlink" title="36.MVC，MVP，MVVM"></a>36.MVC，MVP，MVVM</h4><p><a href="https://imgchr.com/i/8rgdgK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/19/8rgdgK.md.png" alt="8rgdgK.md.png"></a></p>
<p>MVC：PC时代就有的架构方案，在Android上也是最早的方案，Activity/Fragment这些上帝角色既承担了V的角色，也承担了C的角色，小项目开发起来十分顺手，大项目就会遇到<br>耦合过重，Activity/Fragment类过大等问题。</p>
<p>MVP：为了解决MVC耦合过重的问题，MVP的核心思想就是提供一个Presenter将视图逻辑I和业务逻辑相分离，达到解耦的目的。</p>
<p>MVVM：使用ViewModel代替Presenter，实现数据与View的双向绑定，这套框架最早使用的data-binding将数据绑定到xml里，这么做在大规模应用的时候是不行的，不过数据绑定是一个很有用的概念，后续Google又推出了ViewModel组件与LiveData组件。ViewModel组件规范了ViewModel所处的地位、生命周期、生产方式以及一个Activity下多个Fragment共享ViewModel数据的问题。LiveData组件则提供了在Java层面View订阅ViewModel数据源的实现方案。</p>
<h4 id="37-Glide-的理解"><a href="#37-Glide-的理解" class="headerlink" title="37.Glide 的理解"></a>37.Glide 的理解</h4><ol>
<li><p>不仅仅可以进行图片缓存还可以缓存媒体文件。Glide 不仅是一个图片缓存，它支持 Gif、 WebP、缩略图。甚至是 Video，所以更该当做一个媒体缓存。</p>
</li>
<li><p>支持优先级处理。 </p>
</li>
<li><p>与 Activity/Fragment 生命周期一致，支持 trimMemory。Glide 对每个 context 都保持一 个 RequestManager，通过 FragmentTransaction 保持与 Activity/Fragment 生命周期一致， 并且有对应的 trimMemory 接口实现可供调用。 </p>
</li>
<li><p>支持 okhttp、Volley。Glide 默认通过 UrlConnection 获取数据，可以配合 okhttp 或是 Volley 使用。实际 ImageLoader、Picasso 也都支持 okhttp、Volley。</p>
</li>
</ol>
<h4 id="38-Xutils-OKhttp-Volley-Retrofit-对比"><a href="#38-Xutils-OKhttp-Volley-Retrofit-对比" class="headerlink" title="38.Xutils, OKhttp, Volley, Retrofit 对比"></a>38.Xutils, OKhttp, Volley, Retrofit 对比</h4><p>Xutils 这个框架非常全面，可以进行网络请求，可以进行图片加载处理，可以数据储存，还 可以对 view 进行注解，使用这个框架非常方便，但是缺点也是非常明显的，使用这个项目， 会导致项目对这个框架依赖非常的严重，一旦这个框架出现问题，那么对项目来说影响非常 大的。</p>
<p>OKhttp ： Android 开发中是可以直接使用现成的 api 进 行 网 络请求 的 。 就 是 使 用 HttpClient,HttpUrlConnection 进行操作。okhttp 针对 Java 和 Android 程序，封装的一个高性 能的 http 请求库，支持同步，异步，而且 okhttp 又封装了线程池，封装了数据转换，封装 了参数的使用，错误处理等。API 使用起来更加的方便。但是我们在项目中使用的时候仍然 需要自己在做一层封装，这样才能使用的更加的顺手。 </p>
<p>Volley：Volley 是 Google 官方出的一套小而巧的异步请求库，该框架封装的扩展性很强，支 持 HttpClient、HttpUrlConnection，甚至支持 OkHttp，而且 Volley 里面也封装了 ImageLoader， 所以如果你愿意你甚至不需要使用图片加载框架，不过这块功能没有一些专门的图片加载框 架强大，对于简单的需求可以使用，稍复杂点的需求还是需要用到专门的图片加载框架。 Volley 也有缺陷，比如不支持 post 大数据，所以不适合上传文件。不过 Volley 设计的初衷本 身也就是为频繁的、数据量小的网络请求而生。 </p>
<p>Retrofit：Retrofit 是 Square 公司出品的默认基于 OkHttp 封装的一套 RESTful 网络请求框架， RESTful 是目前流行的一套 api 设计的风格， 并不是标准。Retrofit 的封装可以说是很强大， 里面涉及到一堆的设计模式,可以通过注解直接配置请求，可以使用不同的 http 客户端，虽 然默认是用 http ，可以使用不同 Json Converter 来序列化数据，同时提供对 RxJava 的支持， 使用 Retrofit + OkHttp + RxJava + Dagger2 可以说是目前比较潮的一套框架，但是需要有比较 高的门槛。</p>
<p>Volley VS OkHttp </p>
<p>Volley 的优势在于封装的更好，而使用 OkHttp 你需要有足够的能力再进行一次封装。而 OkHttp 的优势在于性能更高，因为 OkHttp 基于 NIO 和 Okio ，所以性能上要比 Volley 更快。 IO 和 NIO 这两个都是 Java 中的概念，如果我从硬盘读取数据，第一种方式就是程序一直等， 数据读完后才能继续操作这种是最简单的也叫阻塞式 IO,还有一种是你读你的,程序接着往下 执行，等数据处理完你再来通知我，然后再处理回调。而第二种就是 NIO 的方式，非阻塞 式， 所以 NIO 当然要比 IO 的性能要好了,而 Okio 是 Square 公司基于 IO 和 NIO 基础上做 的一个更简单、高效处理数据流的一个库。理论上如果 Volley 和 OkHttp 对比的话，更倾向 于使用 Volley，因为 Volley 内部同样支持使用 OkHttp,这点 OkHttp 的性能优势就没了， 而 且 Volley 本身封装的也更易用，扩展性更好些。</p>
<h4 id="39-Android中的动画有哪些"><a href="#39-Android中的动画有哪些" class="headerlink" title="39.Android中的动画有哪些"></a>39.Android中的动画有哪些</h4><p>逐帧动画(Frame Animation)</p>
<ul>
<li>加载一系列Drawable资源来创建动画，简单来说就是播放一系列的图片来实现动画效果，可以自定义每张图片的持续时间</li>
</ul>
<p>补间动画(Tween Animation)</p>
<ul>
<li>Tween可以对View对象实现一系列动画效果，比如平移，缩放，旋转，透明度等。但是它并不会改变View属性的值，只是改变了View的绘制的位置，比如，一个按钮在动画过后，不在原来的位置，但是触发点击事件的仍然是原来的坐标。</li>
</ul>
<p>属性动画(Property Animation)</p>
<ul>
<li>动画的对象除了传统的View对象，还可以是Object对象，动画结束后，Object对象的属性值被实实在在的改变了</li>
</ul>
<h4 id="40-synchronized和lock的区别？"><a href="#40-synchronized和lock的区别？" class="headerlink" title="40.synchronized和lock的区别？"></a>40.synchronized和lock的区别？</h4><p>synchronized会主动释放锁，而lock需要手动调用unlock释放锁；</p>
<p>synchronized是java内置的关键字，而lock是个java类；</p>
<h4 id="41-开发过程中如果想替换第三方jar中的某个class文件，或者在开发时你的class文件与jar中的重名，但是你想使用自己的应该如何解决？如果你替换掉某个方法又该怎么解决？"><a href="#41-开发过程中如果想替换第三方jar中的某个class文件，或者在开发时你的class文件与jar中的重名，但是你想使用自己的应该如何解决？如果你替换掉某个方法又该怎么解决？" class="headerlink" title="41.开发过程中如果想替换第三方jar中的某个class文件，或者在开发时你的class文件与jar中的重名，但是你想使用自己的应该如何解决？如果你替换掉某个方法又该怎么解决？"></a>41.开发过程中如果想替换第三方jar中的某个class文件，或者在开发时你的class文件与jar中的重名，但是你想使用自己的应该如何解决？如果你替换掉某个方法又该怎么解决？</h4><p>方式一：可以获取到jar的源码或者将jar反编译获取到java项目，然后替换掉自己想要的.java文件或者方法；</p>
<p>方式二：可以通过类加载器将目标class替换成自己的class；</p>
<h4 id="42-IO与NIO的区别？"><a href="#42-IO与NIO的区别？" class="headerlink" title="42.IO与NIO的区别？"></a>42.IO与NIO的区别？</h4><p>第一点：IO是面向流的，NIO是面向缓冲区的。</p>
<p>IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。</p>
<p>NIO是面向缓存的。数据读取到一个缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且要确保当更多的数据读入缓冲区时，不要覆盖缓冲区中未处理的数据。</p>
<p>第二点：IO的各种流是阻塞的。</p>
<p>这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情。NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，在数据可读之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h4 id="43-单例模式有几种写法以及各自的优劣？"><a href="#43-单例模式有几种写法以及各自的优劣？" class="headerlink" title="43.单例模式有几种写法以及各自的优劣？"></a>43.单例模式有几种写法以及各自的优劣？</h4><p>1.饿汉式：</p>
<p>缺点：存在内存损耗问题，如果当前类没有用到也会被实例化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingleInstance &#123;</span><br><span class="line">    </span><br><span class="line">    private static SingleInstance mInstance &#x3D; new SingleInstance();</span><br><span class="line">    </span><br><span class="line">    private SingleInstance()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static SingleInstance getInstance()&#123;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.懒汉式：</p>
<p>缺点：加了synchronized锁会影响性能<br>有次被问到为什么要有两次空判断？</p>
<p>第一次空判断和好理解，可以很大程度上减少锁机制的次数；</p>
<p>第二次判空是因为，如果a，b两个线程都到了synchronized处，而假设a拿到了锁，进入到代码块中创建了对象，然后释放了锁，由于b线程在等待锁，所以a释放后，会被b拿到，因此此时判空就保证了实例的唯一性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingleInstance &#123;</span><br><span class="line"></span><br><span class="line">    private static SingleInstance mInstance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private SingleInstance()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static SingleInstance getInstance()&#123;</span><br><span class="line">        if(mInstance&#x3D;&#x3D;null)&#123;</span><br><span class="line">            synchronized (SingleInstance.class)&#123;</span><br><span class="line">                if(mInstance&#x3D;&#x3D;null)&#123;</span><br><span class="line">                    mInstance &#x3D; new SingleInstance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="44-自定义View的基本流程"><a href="#44-自定义View的基本流程" class="headerlink" title="44.自定义View的基本流程"></a>44.自定义View的基本流程</h4><p>①.自定义View的属性 编写attr.xml文件</p>
<p>②.在layout布局文件中引用，同时引用命名空间</p>
<p>③.在View的构造方法中获得我们自定义的属性 ，在自定义控件中进行读取（构造方法拿到attr.xml文件值）</p>
<p>④.重写onMesure</p>
<p>⑥.重写onDraw</p>
<h4 id="45-三级缓存-这个偶尔会问"><a href="#45-三级缓存-这个偶尔会问" class="headerlink" title="45.三级缓存(这个偶尔会问)"></a>45.三级缓存(这个偶尔会问)</h4><p>网络加载，不优先加载，速度慢，浪费流量</p>
<p>本地缓存，次优先加载，速度快</p>
<p>内存缓存，优先加载，速度最快</p>
<p>首次加载Android App时，肯定要通过网络交互来获取图片，之后我们可以将图片保存至本地SD卡和内存中，之后运行APP时，优先访问内存中的图片缓存，若内存中没有，则加载本地SD卡中图片，最后选择访问网络</p>
<h4 id="46-内存泄露原因以及解决"><a href="#46-内存泄露原因以及解决" class="headerlink" title="46.内存泄露原因以及解决"></a>46.内存泄露原因以及解决</h4><p>一、Handler 引起的内存泄漏。</p>
<p>解决：将Handler声明为静态内部类，就不会持有外部类SecondActivity的引用，其生命周期就和外部类无关，</p>
<p>如果Handler里面需要context的话，可以通过弱引用方式引用外部类</p>
<p>二、单例模式引起的内存泄漏。</p>
<p>解决：Context是ApplicationContext，由于ApplicationContext的生命周期是和app一致的，不会导致内存泄漏</p>
<p>三、非静态内部类创建静态实例引起的内存泄漏。</p>
<p>解决：把内部类修改为静态的就可以避免内存泄漏了</p>
<p>四、非静态匿名内部类引起的内存泄漏。</p>
<p>解决：将匿名内部类设置为静态的。</p>
<p>五、注册/反注册未成对使用引起的内存泄漏。</p>
<p>注册广播接受器、EventBus等，记得解绑。</p>
<p>六、资源对象没有关闭引起的内存泄漏。</p>
<p>在这些资源不使用的时候，记得调用相应的类似close（）、destroy（）、recycler（）、release（）等方法释放。</p>
<p>七、集合对象没有及时清理引起的内存泄漏。</p>
<p>通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不再被引用。</p>
<h4 id="47-图片加载框架有哪些？他们之间的区别是什么？"><a href="#47-图片加载框架有哪些？他们之间的区别是什么？" class="headerlink" title="47.图片加载框架有哪些？他们之间的区别是什么？"></a>47.图片加载框架有哪些？他们之间的区别是什么？</h4><h5 id="ImageLoader-："><a href="#ImageLoader-：" class="headerlink" title="ImageLoader ："></a>ImageLoader ：</h5><p>优点：</p>
<p>①　支持下载进度监听；</p>
<p>②　可以在 View 滚动中暂停图片加载；</p>
<p>③　默认实现多种内存缓存算法这几个图片缓存都可以配置缓存算法，不过 ImageLoader 默认实现了较多缓存算法，如 Size 最大先删除、使用最少先删除、最近最少使用、先进先删除、时间最长先删除等；</p>
<p>④　支持本地缓存文件名规则定义；</p>
<p>缺点:</p>
<p>缺点在于不支持GIF图片加载, 缓存机制没有和http的缓存很好的结合, 完全是自己的一套缓存机制</p>
<h5 id="Picasso："><a href="#Picasso：" class="headerlink" title="Picasso："></a>Picasso：</h5><p>优点：</p>
<p>①　自带统计监控功能，支持图片缓存使用的监控，包括缓存命中率、已使用内存大小、节省的流量等。</p>
<p>②　支持优先级处理</p>
<p>③　支持延迟到图片尺寸计算完成加载</p>
<p>④　支持飞行模式、并发线程数根据网络类型而变，手机切换到飞行模式或网络类型变换时会自动调整线程池最大并发数。</p>
<p>⑤ “无”本地缓存。Picasso 自己没有实现本地缓存，而由okhttp 去实现，这样的好处是可以通过请求 Response Header 中的 Cache-Control 及 Expired 控制图片的过期时间。</p>
<p>缺点：</p>
<p>于不支持GIF，默认使用ARGB_8888格式缓存图片，缓存体积大。</p>
<p>Glide：</p>
<p>优点：</p>
<p>①　图片缓存-&gt;媒体缓存 ，支持 Gif、WebP、缩略图。甚至是 Video。</p>
<p>②　支持优先级处理</p>
<p>③　与 Activity/Fragment 生命周期一致，支持 trimMemory</p>
<p>④　支持 okhttp、Volley。Glide 默认通过 UrlConnection 获取数据，可以配合 okhttp 或是 Volley 使用。实际 ImageLoader、Picasso 也都支持 okhttp、Volley。</p>
<p>⑤　内存友好，内存缓存更小图片，图片默认使用默认 RGB565 而不是 ARGB888</p>
<p>缺点：</p>
<p>清晰度差，但可以设置</p>
<h5 id="Fresco："><a href="#Fresco：" class="headerlink" title="Fresco："></a>Fresco：</h5><p>优点:</p>
<p>①　图片存储在安卓系统的匿名共享内存, 而不是虚拟机的堆内存中,所以不会因为图片加载而导致oom, 同时也减少垃圾回收器频繁调用回收Bitmap导致的界面卡顿,性能更高.</p>
<p>②　渐进式加载JPEG图片, 支持图片从模糊到清晰加载</p>
<p>③　图片可以以任意的中心点显示在ImageView, 而不仅仅是图片的中心.</p>
<p>④ JPEG图片改变大小也是在native进行的, 不是在虚拟机的堆内存, 同样减少OOM</p>
<p>⑤　很好的支持GIF图片的显示</p>
<p>缺点:</p>
<p>框架较大, 影响Apk体积，使用较繁琐</p>
<h4 id="48-ContentProvider、ContentResolver与ContentObserver之间的关系是什么？"><a href="#48-ContentProvider、ContentResolver与ContentObserver之间的关系是什么？" class="headerlink" title="48.ContentProvider、ContentResolver与ContentObserver之间的关系是什么？"></a>48.ContentProvider、ContentResolver与ContentObserver之间的关系是什么？</h4><p>ContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、文件、XML、网络等，ContentProvider为这些数据的访问提供了统一的接口，可以用来做进程间数据共享。</p>
<p>ContentResolver：ContentResolver可以不同URI操作不同的ContentProvider中的数据，外部进程可以通过ContentResolver与ContentProvider进行交互。</p>
<p>ContentObserver：观察ContentProvider中的数据变化，并将变化通知给外界。</p>
<h4 id="49-APK的打包流程"><a href="#49-APK的打包流程" class="headerlink" title="49.APK的打包流程"></a>49.APK的打包流程</h4><ol>
<li><p>通过AAPT工具进行资源文件（包括AndroidManifest.xml、布局文件、各种xml资源等）的打包，生成R.java文件。</p>
</li>
<li><p>通过AIDL工具处理AIDL文件，生成相应的Java文件。</p>
</li>
<li><p>通过Javac工具编译项目源码，生成Class文件。</p>
</li>
<li><p>通过DX工具将所有的Class文件转换成DEX文件，该过程主要完成Java字节码转换成Dalvik字节码，压缩常量池以及清除冗余信息等工作。</p>
</li>
<li><p>通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件。</p>
</li>
<li><p>利用KeyStore对生成的APK文件进行签名。</p>
</li>
<li><p>如果是正式版的APK，还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件<br>的速度会更快</p>
</li>
</ol>
<h4 id="50-Activity的启动流程"><a href="#50-Activity的启动流程" class="headerlink" title="50.Activity的启动流程"></a>50.Activity的启动流程</h4><ol>
<li><p>点击桌面应用图标，Launcher进程将启动Activity（MainActivity）的请求以Binder的方式发送给了AMS。</p>
</li>
<li><p>AMS接收到启动请求后，交付ActivityStarter处理Intent和Flag等信息，然后再交给ActivityStackSupervisior/ActivityStack<br>处理Activity进栈相关流程。同时以Socket方式请求Zygote进程fork新进程。</p>
</li>
<li><p>Zygote接收到新进程创建请求后fork出新进程。</p>
</li>
<li><p>在新进程里创建ActivityThread对象，新创建的进程就是应用的主线程，在主线程里开启Looper消息循环，开始处理创建Activity。</p>
</li>
<li><p>ActivityThread利用ClassLoader去加载Activity、创建Activity实例，并回调Activity的onCreate()方法。这样便完成了Activity的启动。</p>
</li>
</ol>
<h4 id="51-既然有现有的IPC方式，为什么重新设计一套Binder机制呢"><a href="#51-既然有现有的IPC方式，为什么重新设计一套Binder机制呢" class="headerlink" title="51.既然有现有的IPC方式，为什么重新设计一套Binder机制呢?"></a>51.既然有现有的IPC方式，为什么重新设计一套Binder机制呢?</h4><ol>
<li><p>高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。</p>
</li>
<li><p>稳定性：上面说到共享内存的性能优于Binder，那为什么不适用共享内存呢，因为共享内存需要处理并发同步问题，控制负责，容易出现死锁和资源竞争，稳定性较差。而Binder基于C/S架构，客户端与服务端彼此独立，稳定性较好。</p>
</li>
<li><p>安全性：我们知道Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理，包括6.0以前的固定权限和6.0以后的动态权限，传荣IPC只能由用户在数据包里填入UID/PID，这个标记完全是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。</p>
</li>
</ol>
<h4 id="52-Java与C-如何相互调用？"><a href="#52-Java与C-如何相互调用？" class="headerlink" title="52.Java与C++如何相互调用？"></a>52.Java与C++如何相互调用？</h4><p>Java调用C++</p>
<ol>
<li><p>在Java中声明Native方法（即需要调用的本地方法）</p>
</li>
<li><p>编译上述 Java源文件javac（得到 .class文件）</p>
</li>
<li><p>通过 javah 命令导出JNI的头文件（.h文件）</p>
</li>
<li><p>使用 Java需要交互的本地代码 实现在 Java中声明的Native方法</p>
</li>
<li><p>编译.so库文件</p>
</li>
<li><p>通过Java命令执行 Java程序，最终实现Java调用本地代码</p>
</li>
</ol>
<p>C++调用Java</p>
<ol>
<li><p>从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象。</p>
</li>
<li><p>获取类的默认构造方法ID。</p>
</li>
<li><p>查找实例方法的ID。</p>
</li>
<li><p>创建该类的实例。</p>
</li>
<li><p>调用对象的实例方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessMethod_callJavaInstaceMethod  </span><br><span class="line">(JNIEnv *env, jclass cls)  </span><br><span class="line">&#123;  </span><br><span class="line">    jclass clazz &#x3D; NULL;  </span><br><span class="line">    jobject jobj &#x3D; NULL;  </span><br><span class="line">    jmethodID mid_construct &#x3D; NULL;  </span><br><span class="line">    jmethodID mid_instance &#x3D; NULL;  </span><br><span class="line">    jstring str_arg &#x3D; NULL;  </span><br><span class="line">    &#x2F;&#x2F; 1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象  </span><br><span class="line">    clazz &#x3D; (*env)-&gt;FindClass(env, &quot;com&#x2F;study&#x2F;jnilearn&#x2F;ClassMethod&quot;);  </span><br><span class="line">    if (clazz &#x3D;&#x3D; NULL) &#123;  </span><br><span class="line">        printf(&quot;找不到&#39;com.study.jnilearn.ClassMethod&#39;这个类&quot;);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F; 2、获取类的默认构造方法ID  </span><br><span class="line">    mid_construct &#x3D; (*env)-&gt;GetMethodID(env,clazz, &quot;&lt;init&gt;&quot;,&quot;()V&quot;);  </span><br><span class="line">    if (mid_construct &#x3D;&#x3D; NULL) &#123;  </span><br><span class="line">        printf(&quot;找不到默认的构造方法&quot;);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F; 3、查找实例方法的ID  </span><br><span class="line">    mid_instance &#x3D; (*env)-&gt;GetMethodID(env, clazz, &quot;callInstanceMethod&quot;, &quot;(Ljava&#x2F;lang&#x2F;String;I)V&quot;);  </span><br><span class="line">    if (mid_instance &#x3D;&#x3D; NULL) &#123;  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F; 4、创建该类的实例  </span><br><span class="line">    jobj &#x3D; (*env)-&gt;NewObject(env,clazz,mid_construct);  </span><br><span class="line">    if (jobj &#x3D;&#x3D; NULL) &#123;  </span><br><span class="line">        printf(&quot;在com.study.jnilearn.ClassMethod类中找不到callInstanceMethod方法&quot;);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F; 5、调用对象的实例方法  </span><br><span class="line">    str_arg &#x3D; (*env)-&gt;NewStringUTF(env,&quot;我是实例方法&quot;);  </span><br><span class="line">    (*env)-&gt;CallVoidMethod(env,jobj,mid_instance,str_arg,200);  </span><br><span class="line">    &#x2F;&#x2F; 删除局部引用  </span><br><span class="line">    (*env)-&gt;DeleteLocalRef(env,clazz);  </span><br><span class="line">    (*env)-&gt;DeleteLocalRef(env,jobj);  </span><br><span class="line">    (*env)-&gt;DeleteLocalRef(env,str_arg);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="53-了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？"><a href="#53-了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？" class="headerlink" title="53.了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？"></a>53.了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？</h4><p>插件化：插件化是体现在功能拆分方面的，它将某个功能独立提取出来，独立开发，独立测试，再插入到主应用中。依次来较少主应用的规模。</p>
<p>热修复：热修复是体现在bug修复方面的，它实现的是不需要重新发版和重新安装，就可以去修复已知的bug。</p>
<h4 id="54-将apk文件复制到data-app目录"><a href="#54-将apk文件复制到data-app目录" class="headerlink" title="54.将apk文件复制到data/app目录"></a>54.将apk文件复制到data/app目录</h4><p>解析apk信息</p>
<p>dexopt操作</p>
<p>更新权限信息</p>
<p>完成安装,发送Intent.ACTION_PACKAGE_ADDED广播</p>
<h4 id="55-JNI的几种注册方式"><a href="#55-JNI的几种注册方式" class="headerlink" title="55.JNI的几种注册方式"></a>55.JNI的几种注册方式</h4><p>静态注册</p>
<p>1.编写一个java类，在里面加载对应的so库并且通过native关键字定义需要调用的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.wenzhe.myjni;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by wenzhe on 16-1-27.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JniTest &#123;</span><br><span class="line">public native int getRandomNum();</span><br><span class="line">public native String getNativeString();</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    System.loadLibrary(&quot;HelloJni&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.在命令行下输入 javac JniTest.java 生成JniTest.class文件</p>
<p>3.将头文件拷贝到jni目录下(eclipse在src同级目录建立文件夹，Android studio 在java同级目录建立文件夹)</p>
<p>4.编写C/C++源代码 并把刚拷贝的头文件包含进去 ,复制头文件中函数的定义部分，并实现其中的你想要的功能</p>
<p>5.在命令行中进入jni目录，输入ndk-build 即可生产对应so库，会自动放在libs文件夹下 至此就可以运行程序了</p>
<p>动态注册</p>
<p>1.编写Java端的相关native方法</p>
<p>2.编写C/C++代码, 实现JNI_Onload()方法</p>
<p>3.将Java 方法和 C/C++方法通过签名信息一一对应起来</p>
<p>4.通过JavaVM获取JNIEnv, JNIEnv主要用于获取Java类和调用一些JNI提供的方法</p>
<p>5.使用类名和对应起来的方法作为参数, 调用JNI提供的函数RegisterNatives()注册方</p>
<h4 id="56-自定义View-的步骤"><a href="#56-自定义View-的步骤" class="headerlink" title="56.自定义View 的步骤"></a>56.自定义View 的步骤</h4><p>自定义View属性</p>
<p>在View的构造方法中获得自定义的属性</p>
<p>重写onMesure</p>
<p>重写onDraw</p>
<h4 id="57-同步和异步的概念区别："><a href="#57-同步和异步的概念区别：" class="headerlink" title="57.同步和异步的概念区别："></a>57.同步和异步的概念区别：</h4><p>同步，必须执行完成某个问题后才能继续执行其他的。</p>
<p>异步，我会去先执行其他问题，你执行完之后返回给我一个结果就可以。</p>
<hr>
<p>android中为什么要引用异步任务呢？</p>
<p>　android启动的，会启动一个线程也称为主线程，UI线程，但是我们不能把所有耗时的任务交给主线程来完成，这样会影响用户的体验，也就是说我们要另外的开辟新的线程来执行我们的任务，但是在android中，（加载图片，网络编程都属于耗时的操作），在android4.0后规定禁止在主线程中完成网络操作，所以说这些耗时的任务要交给子线程。</p>
<hr>
<p>　<br>Asynctask的基本使用：</p>
<p>首先它是一个抽象类，也就是说我们要重写他的方法然后在new</p>
<p>AsyncTask&lt;Params,progress,result&gt;</p>
<p>parames:启动任务的时候执行的参数，比如传入的url</p>
<p>Progress：后台执行进度的百分比单位</p>
<p>result：执行完异步操作后返回的结果</p>
<h4 id="58-EventBus的原理"><a href="#58-EventBus的原理" class="headerlink" title="58.EventBus的原理"></a>58.EventBus的原理</h4><ol>
<li><p>构造方法: 创建构造方法: 通过双重锁的模式创建对象 ; 通过建造者模式创建对象</p>
</li>
<li><p>注册:这个subscriber就是我们使用EventBus.getDefault().register(this);传入的这个this，比如MainActivity.this。通过反射，查找该Subscriber中，通过@Subscribe注解的方法（消费方法）信息，将这些方法信息封装到SubscriberMethod中，封装的内容包括Method对象、ThreadMode、事件类型、优先级、是否粘性等</p>
</li>
<li><p>发布与消费事件: post进行发布 .然后到线程的队列中,然后进行消费事件,消费的时候通过反射和method 调用,这是回到queue队列当中,循环遍历queue中的event 查找可以消费该事件的类和方法,最终他会将事件交给这个类和方法,完成整个消息的发布与消费;</p>
</li>
</ol>
<hr>
<p>Handler与EventBus区别</p>
<p>EventBus是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息.优点是开销小，代码更优雅。以及将发送者和接收者解耦。</p>
<p>大家可以简单对比下两者的区别，可以发现EventBus进行了完全的解耦。</p>
]]></content>
      <categories>
        <category>面试笔记</category>
      </categories>
      <tags>
        <tag>面试笔记</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>算法面试笔记</title>
    <url>/2020/06/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/dgdvlo.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">一抹光</div>
</center>


<blockquote>
<p>本科面试笔记</p>
</blockquote>
<a id="more"></a>

<h3 id="一、树"><a href="#一、树" class="headerlink" title="一、树"></a>一、树</h3><h4 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1.红黑树"></a>1.红黑树</h4><ul>
<li>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。</li>
<li>通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树</li>
</ul>
<p>性质：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 每个节点非红即黑</span><br><span class="line"></span><br><span class="line">2. 根节点是黑的;</span><br><span class="line"></span><br><span class="line">3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</span><br><span class="line"></span><br><span class="line">4. 如果一个节点是红色的，则它的子节点必须是黑色的。</span><br><span class="line"></span><br><span class="line">5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</span><br></pre></td></tr></table></figure>

<h4 id="2-AVL树"><a href="#2-AVL树" class="headerlink" title="2.AVL树"></a>2.AVL树</h4><p>平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。</p>
<h4 id="3-map底层为什么用红黑树实现"><a href="#3-map底层为什么用红黑树实现" class="headerlink" title="3.map底层为什么用红黑树实现"></a>3.map底层为什么用红黑树实现</h4><p>红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p>
<h4 id="4-Top-K-问题"><a href="#4-Top-K-问题" class="headerlink" title="4.Top(K)问题"></a>4.Top(K)问题</h4><p>1、直接全部排序（只适用于内存够的情况）</p>
<p>当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。</p>
<p>这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。</p>
<p>2、快速排序的变形 （只使用于内存够的情况）</p>
<p>这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。</p>
<p>这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index  &gt; K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index &lt; K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。</p>
<p>3、最小堆法</p>
<p>这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。</p>
<p>4、分治法</p>
<p>将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N<em>K个数据，如果内存不能容纳N</em>K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。</p>
<p>5、Hash法</p>
<p>如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。</p>
<h4 id="5-红黑树较AVL树的优点："><a href="#5-红黑树较AVL树的优点：" class="headerlink" title="5.红黑树较AVL树的优点："></a>5.红黑树较AVL树的优点：</h4><p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p>
<h4 id="6-二叉树的层序遍历并输出（手写代码）"><a href="#6-二叉树的层序遍历并输出（手写代码）" class="headerlink" title="6.二叉树的层序遍历并输出（手写代码）"></a>6.二叉树的层序遍历并输出（手写代码）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line">&#x2F;**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val &#x3D; 0;</span><br><span class="line">    TreeNode left &#x3D; null;</span><br><span class="line">    TreeNode right &#x3D; null;</span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val &#x3D; val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; resultList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode nowNode &#x3D; q.peek();</span><br><span class="line">            q.poll();</span><br><span class="line">            resultList.add(nowNode.val);</span><br><span class="line">            if (nowNode.left !&#x3D; null) &#123;</span><br><span class="line">                q.add(nowNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (nowNode.right !&#x3D; null) &#123;</span><br><span class="line">                q.add(nowNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return resultList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-序列化和反序列化二叉树。（手写代码）"><a href="#7-序列化和反序列化二叉树。（手写代码）" class="headerlink" title="7.序列化和反序列化二叉树。（手写代码）"></a>7.序列化和反序列化二叉树。（手写代码）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;题目：请实现两个函数，分别用来序列化和反序列化二叉树。</span><br><span class="line"> </span><br><span class="line">public class SerializeBinaryTrees &#123;</span><br><span class="line">    public class TreeNode &#123;</span><br><span class="line">        int val &#x3D; 0;</span><br><span class="line">        TreeNode left &#x3D; null;</span><br><span class="line">        TreeNode right &#x3D; null;</span><br><span class="line"> </span><br><span class="line">        public TreeNode(int val) &#123;</span><br><span class="line">            this.val &#x3D; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    String Serialize(TreeNode node) &#123;</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            sb.append(&quot;$,&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sb.append(node.val + &quot;,&quot;);</span><br><span class="line">            sb.append(Serialize(node.left));</span><br><span class="line">            sb.append(Serialize(node.right));</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    int index &#x3D; 0;</span><br><span class="line">    TreeNode Deserialize(String str) &#123;</span><br><span class="line">        TreeNode node &#x3D; null;</span><br><span class="line">        if (str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D; 0)</span><br><span class="line">            return node;</span><br><span class="line">        int start &#x3D; index;</span><br><span class="line">        while (str.charAt(index) !&#x3D; &#39;,&#39;)</span><br><span class="line">            index++;</span><br><span class="line">        if (!str.substring(start, index).equals(&quot;$&quot;)) &#123;</span><br><span class="line">            node &#x3D; new TreeNode(Integer.parseInt(str.substring(start, index)));</span><br><span class="line">            index++; &#x2F;&#x2F; 这条语句位置别放错了</span><br><span class="line">            node.left &#x3D; Deserialize(str);</span><br><span class="line">            node.right &#x3D; Deserialize(str);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-最近公共祖先"><a href="#8-最近公共祖先" class="headerlink" title="8.最近公共祖先"></a>8.最近公共祖先</h4><p>有一棵无穷大的满二叉树，其结点按根结点一层一层地从左往右依次编号，根结点编号为1。现在有两个结点a，b。请设计一个算法，求出a和b点的最近公共祖先的编号。</p>
<p>给定两个int a,b。为给定结点的编号。请返回a和b的最近公共祖先的编号。注意这里结点本身也可认为是其祖先。</p>
<p>测试样例：<br>2，3</p>
<p>返回：<br>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：满二叉树的子节点与父节点之间的关系为root &#x3D; child &#x2F; 2</span><br><span class="line">&#x2F;&#x2F;利用这个关系，如果a ！&#x3D; b，就让其中的较大数除以2， 如此循环知道a &#x3D;&#x3D; b，</span><br><span class="line">&#x2F;&#x2F;即是原来两个数的最近公共祖先</span><br><span class="line">&#x2F;&#x2F;代码如下：</span><br><span class="line"> class LCA &#123;</span><br><span class="line">public:</span><br><span class="line">    int getLCA(int a, int b) &#123;</span><br><span class="line">        &#x2F;&#x2F; write code here</span><br><span class="line">        while(a !&#x3D; b)</span><br><span class="line">            &#123;</span><br><span class="line">            if(a &gt; b)</span><br><span class="line">                a &#x2F;&#x3D; 2;</span><br><span class="line">            else</span><br><span class="line">                b &#x2F;&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、堆和栈"><a href="#二、堆和栈" class="headerlink" title="二、堆和栈"></a>二、堆和栈</h3><h4 id="1-说一说你理解的stack-overflow，并举个简单例子导致栈溢出"><a href="#1-说一说你理解的stack-overflow，并举个简单例子导致栈溢出" class="headerlink" title="1.说一说你理解的stack overflow，并举个简单例子导致栈溢出"></a>1.说一说你理解的stack overflow，并举个简单例子导致栈溢出</h4><p>栈溢出概念：</p>
<p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。</p>
<p>栈溢出的原因：</p>
<ol>
<li><p>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）。</p>
</li>
<li><p>递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</p>
</li>
<li><p>指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</p>
</li>
</ol>
<h4 id="2-堆和栈的区别"><a href="#2-堆和栈的区别" class="headerlink" title="2.堆和栈的区别"></a>2.堆和栈的区别</h4><p>1）申请方式：<br>栈由系统自动分配和管理，堆由程序员手动分配和管理。</p>
<p>2）效率：</p>
<p>栈由系统分配，速度快，不会有内存碎片。</p>
<p>堆由程序员分配，速度较慢，可能由于操作不当产生内存碎片。</p>
<p>3）扩展方向</p>
<p>栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展。</p>
<p>4）程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间。</p>
<h4 id="3-大小根堆特点"><a href="#3-大小根堆特点" class="headerlink" title="3.大小根堆特点"></a>3.大小根堆特点</h4><p>堆是一棵完全二叉树（如果一共有h层，那么1~h-1层均满，在h层可能会连续缺失若干个右叶子）。</p>
<p>1）小根堆</p>
<p>若根节点存在左子女则根节点的值小于左子女的值；若根节点存在右子女则根节点的值小于右子女的值。</p>
<p>2）大根堆</p>
<p>若根节点存在左子女则根节点的值大于左子女的值；若根节点存在右子女则根节点的值大于右子女的值。</p>
<hr>
<p>堆和普通树的区别</p>
<p>堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。我们来看一下两者的主要差别：</p>
<p>节点的顺序。在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。</p>
<p>内存占用。普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额为是我内存。堆仅仅使用一个数据来存储数组，且不使用指针。</p>
<p>平衡。二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。</p>
<p>搜索。在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</p>
<h4 id="4-两个栈实现一个队列-和-用队列实现栈（手写代码）"><a href="#4-两个栈实现一个队列-和-用队列实现栈（手写代码）" class="headerlink" title="4.两个栈实现一个队列 和 用队列实现栈（手写代码）"></a>4.两个栈实现一个队列 和 用队列实现栈（手写代码）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"> </span><br><span class="line">	Stack&lt;Integer&gt; stack1 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">	Stack&lt;Integer&gt; stack2 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;进栈操作呢</span><br><span class="line">	public void appendTail(int item)&#123;</span><br><span class="line">		stack1.push(item);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;出栈操作</span><br><span class="line">	public int deleteHead()&#123;</span><br><span class="line">		while(!stack2.isEmpty())&#123;</span><br><span class="line">			return stack2.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		while(!stack1.isEmpty())&#123;</span><br><span class="line">			stack2.push(stack1.pop());</span><br><span class="line">		&#125;</span><br><span class="line">		return stack2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用队列实现栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">    Queue&lt;Integer&gt; que;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;** Initialize your data structure here. *&#x2F;</span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        que &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Push element x onto stack. *&#x2F;</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        que.add(x);</span><br><span class="line">        int num&#x3D;que.size();</span><br><span class="line">        while(num&gt;1)&#123;</span><br><span class="line">            que.add(que.poll());</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;</span><br><span class="line">    public int pop() &#123;       </span><br><span class="line">       return que.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Get the top element. *&#x2F;</span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return que.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Returns whether the stack is empty. *&#x2F;</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return que.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h3><h4 id="1-数组与链表的区别"><a href="#1-数组与链表的区别" class="headerlink" title="1.数组与链表的区别"></a>1.数组与链表的区别</h4><p>数组的优点：</p>
<ol>
<li><p>随机访问性强</p>
</li>
<li><p>查找速度快</p>
</li>
</ol>
<p>数组的缺点:</p>
<ol>
<li><p>插入和删除效率低</p>
</li>
<li><p>可能浪费内存</p>
</li>
<li><p>内存空间要求高，必须有足够的连续内存空间。</p>
</li>
<li><p>数组大小固定，不能动态拓展</p>
</li>
</ol>
<p>链表的优点:</p>
<ol>
<li><p>插入删除速度快</p>
</li>
<li><p>内存利用率高，不会浪费内存</p>
</li>
<li><p>大小没有固定，拓展很灵活。</p>
</li>
</ol>
<p>链表的缺点:</p>
<ol>
<li>不能随机查找，必须从第一个开始遍历，查找效率低</li>
</ol>
<h4 id="2-二分法"><a href="#2-二分法" class="headerlink" title="2.二分法"></a>2.二分法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int binary_search(T arr[], int n, T target) &#123;</span><br><span class="line">    int l &#x3D; 0, r &#x3D; n - 1;</span><br><span class="line">    while (l &lt;&#x3D; r) &#123;</span><br><span class="line">        int mid &#x3D; (r + l) &#x2F; 2; &#x2F;&#x2F; ☆</span><br><span class="line">        if (arr[mid] &#x3D; target) return mid;</span><br><span class="line">        if (target &gt; arr[mid]) l &#x3D; mid + 1;</span><br><span class="line">        else r &#x3D; mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、排序"><a href="#四、排序" class="headerlink" title="四、排序"></a>四、排序</h3><h4 id="1-各种排序算法及时间复杂度"><a href="#1-各种排序算法及时间复杂度" class="headerlink" title="1.各种排序算法及时间复杂度"></a>1.各种排序算法及时间复杂度</h4><p>插入排序：对于一个带排序数组来说，其初始有序数组元素个数为1，然后从第二个元素，插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插入的元素，则后移一位；如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前元素的下一位中。</p>
<p>希尔排序：先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关，其最后一个值必须为1.</p>
<p>归并排序：该算法采用分治法；对于包含m个元素的待排序序列，将其看成m个长度为1的子序列。然后两两合归并，得到n/2个长度为2或者1的有序子序列；然后再两两归并，直到得到1个长度为m的有序序列。</p>
<p>冒泡排序：对于包含n个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，若为逆序，则交换元素位置；然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前前n-i个元素中的最大的元素移到n-i位置。遍历n次，完成排序。</p>
<p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>选择排序：每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个元素交换位置，从而使有序数组元素加1，无序数组元素减1.初始时无序数组为空。</p>
<p>堆排序：堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数据构造一个最大堆（升序）/最小堆（降序），然后将堆顶元素与待排序数组的最后一个元素交换位置，此时末尾元素就是最大/最小的值。然后将剩余n-1个元素重新构造成最大堆/最小堆。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552474444160_93CF294B0FB45C83DC616C5700184F2E" alt></p>
<h4 id="2-稳定排序哪几种？"><a href="#2-稳定排序哪几种？" class="headerlink" title="2.稳定排序哪几种？"></a>2.稳定排序哪几种？</h4><p>基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序</p>
<h4 id="3-请问求第k大的数的方法以及各自的复杂度是怎样的？"><a href="#3-请问求第k大的数的方法以及各自的复杂度是怎样的？" class="headerlink" title="3.请问求第k大的数的方法以及各自的复杂度是怎样的？"></a>3.请问求第k大的数的方法以及各自的复杂度是怎样的？</h4><p>解法1： 我们可以对这个乱序数组按照从大到小先行排序，然后取出前k大，总的时间复杂度为O(n*logn + k)。</p>
<p>解法2： 利用快速排序的思想，从数组S中随机找出一个元素X，把数组分为两部分Sa和Sb。Sa中的元素大于等于X，Sb中元素小于X。这时有两种情况：</p>
<ol>
<li>Sa中元素的个数小于k，则Sb中的第k-|Sa|个元素即为第k大数；</li>
<li>Sa中元素的个数大于等于k，则返回Sa中的第k大数。时间复杂度近似为O(n)</li>
</ol>
<p>解法3：维护一个k大小的最小堆，对于数组中的每一个元素判断与堆顶的大小，若堆顶较大，则不管，否则，弹出堆顶，将当前值插入到堆中。时间复杂度O(n * logk)</p>
<p>解法4：利用hash保存数组中元素Si出现的次数，利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大数，平均情况下时间复杂度O(n)</p>
<h4 id="4-冒泡排序-手写代码-O-n-2"><a href="#4-冒泡排序-手写代码-O-n-2" class="headerlink" title="4.冒泡排序(手写代码) O(n^2)"></a>4.冒泡排序(手写代码) O(n^2)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void BubbleSort1(int [] arr)&#123;</span><br><span class="line"></span><br><span class="line">   int temp;&#x2F;&#x2F;临时变量</span><br><span class="line">   boolean flag;&#x2F;&#x2F;是否交换的标志</span><br><span class="line">   for(int i&#x3D;0; i&lt;arr.length-1; i++)&#123;   &#x2F;&#x2F;表示趟数，一共 arr.length-1 次</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 每次遍历标志位都要先置为false，才能判断后面的元素是否发生了交换</span><br><span class="line">       flag &#x3D; false;</span><br><span class="line">       </span><br><span class="line">       for(int j&#x3D;arr.length-1; j&gt;i; j--)&#123; &#x2F;&#x2F;选出该趟排序的最大值往后移动</span><br><span class="line"></span><br><span class="line">           if(arr[j] &lt; arr[j-1])&#123;</span><br><span class="line">               temp &#x3D; arr[j];</span><br><span class="line">               arr[j] &#x3D; arr[j-1];</span><br><span class="line">               arr[j-1] &#x3D; temp;</span><br><span class="line">               flag &#x3D; true;    &#x2F;&#x2F;只要有发生了交换，flag就置为true</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 判断标志位是否为false，如果为false，说明后面的元素已经有序，就直接return</span><br><span class="line">       if(!flag) break;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-选择排序-O-n-2"><a href="#5-选择排序-O-n-2" class="headerlink" title="5.选择排序 O(n^2)"></a>5.选择排序 O(n^2)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void select_sort(int array[],int lenth)&#123;</span><br><span class="line"></span><br><span class="line">   for(int i&#x3D;0;i&lt;lenth-1;i++)&#123;</span><br><span class="line"></span><br><span class="line">       int minIndex &#x3D; i;</span><br><span class="line">       for(int j&#x3D;i+1;j&lt;lenth;j++)&#123;</span><br><span class="line">          if(array[j]&lt;array[minIndex])&#123;</span><br><span class="line">              minIndex &#x3D; j;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if(minIndex !&#x3D; i)&#123;</span><br><span class="line">           int temp &#x3D; array[i];</span><br><span class="line">           array[i] &#x3D; array[minIndex];</span><br><span class="line">           array[minIndex] &#x3D; temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-快速排序（手写代码）O-Nlog2N"><a href="#6-快速排序（手写代码）O-Nlog2N" class="headerlink" title="6.快速排序（手写代码）O(Nlog2N)"></a>6.快速排序（手写代码）O(Nlog2N)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void quickSort(int a[],int l,int r)&#123;</span><br><span class="line">     if(l&gt;&#x3D;r)</span><br><span class="line">       return;</span><br><span class="line"></span><br><span class="line">     int i &#x3D; l; int j &#x3D; r; int key &#x3D; a[l];&#x2F;&#x2F;选择第一个数为key</span><br><span class="line"></span><br><span class="line">     while(i&lt;j)&#123;</span><br><span class="line"></span><br><span class="line">         while(i&lt;j &amp;&amp; a[j]&gt;&#x3D;key)&#x2F;&#x2F;从右向左找第一个小于key的值</span><br><span class="line">             j--;</span><br><span class="line">         if(i&lt;j)&#123;</span><br><span class="line">             a[i] &#x3D; a[j];</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         while(i&lt;j &amp;&amp; a[i]&lt;key)&#x2F;&#x2F;从左向右找第一个大于key的值</span><br><span class="line">             i++;</span><br><span class="line"></span><br><span class="line">         if(i&lt;j)&#123;</span><br><span class="line">             a[j] &#x3D; a[i];</span><br><span class="line">             j--;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;i &#x3D;&#x3D; j</span><br><span class="line">     a[i] &#x3D; key;</span><br><span class="line">     quickSort(a, l, i-1);&#x2F;&#x2F;递归调用</span><br><span class="line">     quickSort(a, i+1, r);&#x2F;&#x2F;递归调用</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-归并排序（手写代码）O-Nlog2N"><a href="#7-归并排序（手写代码）O-Nlog2N" class="headerlink" title="7.归并排序（手写代码）O(Nlog2N)"></a>7.归并排序（手写代码）O(Nlog2N)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void merge_sort(int a[],int first,int last,int temp[])&#123;</span><br><span class="line"></span><br><span class="line">  if(first &lt; last)&#123;</span><br><span class="line">      int middle &#x3D; (first + last)&#x2F;2;</span><br><span class="line">      merge_sort(a,first,middle,temp);&#x2F;&#x2F;左半部分排好序</span><br><span class="line">      merge_sort(a,middle+1,last,temp);&#x2F;&#x2F;右半部分排好序</span><br><span class="line">      mergeArray(a,first,middle,last,temp); &#x2F;&#x2F;合并左右部分</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;合并 ：将两个序列a[first-middle],a[middle+1-end]合并</span><br><span class="line">public static void mergeArray(int a[],int first,int middle,int end,int temp[])&#123;    </span><br><span class="line">  int i &#x3D; first;</span><br><span class="line">  int m &#x3D; middle;</span><br><span class="line">  int j &#x3D; middle+1;</span><br><span class="line">  int n &#x3D; end;</span><br><span class="line">  int k &#x3D; 0;</span><br><span class="line">  while(i&lt;&#x3D;m &amp;&amp; j&lt;&#x3D;n)&#123;</span><br><span class="line">      if(a[i] &lt;&#x3D; a[j])&#123;</span><br><span class="line">          temp[k] &#x3D; a[i];</span><br><span class="line">          k++;</span><br><span class="line">          i++;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">          temp[k] &#x3D; a[j];</span><br><span class="line">          k++;</span><br><span class="line">          j++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">  while(i&lt;&#x3D;m)&#123;</span><br><span class="line">      temp[k] &#x3D; a[i];</span><br><span class="line">      k++;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;    </span><br><span class="line">  while(j&lt;&#x3D;n)&#123;</span><br><span class="line">      temp[k] &#x3D; a[j];</span><br><span class="line">      k++;</span><br><span class="line">      j++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for(int ii&#x3D;0;ii&lt;k;ii++)&#123;</span><br><span class="line">      a[first + ii] &#x3D; temp[ii];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-堆排序O-Nlog2N"><a href="#8-堆排序O-Nlog2N" class="headerlink" title="8.堆排序O(Nlog2N)"></a>8.堆排序O(Nlog2N)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构建最小堆</span><br><span class="line">public static void MakeMinHeap(int a[], int n)&#123;</span><br><span class="line"> for(int i&#x3D;(n-1)&#x2F;2 ; i&gt;&#x3D;0 ; i--)&#123;</span><br><span class="line">     MinHeapFixdown(a,i,n);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2  </span><br><span class="line">public static void MinHeapFixdown(int a[],int i,int n)&#123;</span><br><span class="line"></span><br><span class="line">   int j &#x3D; 2*i+1; &#x2F;&#x2F;子节点</span><br><span class="line">   int temp &#x3D; 0;</span><br><span class="line"></span><br><span class="line">   while(j&lt;n)&#123;</span><br><span class="line">       &#x2F;&#x2F;在左右子节点中寻找最小的</span><br><span class="line">       if(j+1&lt;n &amp;&amp; a[j+1]&lt;a[j])&#123;  </span><br><span class="line">           j++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if(a[i] &lt;&#x3D; a[j])</span><br><span class="line">           break;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;较大节点下移</span><br><span class="line">       temp &#x3D; a[i];</span><br><span class="line">       a[i] &#x3D; a[j];</span><br><span class="line">       a[j] &#x3D; temp;</span><br><span class="line"></span><br><span class="line">       i &#x3D; j;</span><br><span class="line">       j &#x3D; 2*i+1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void MinHeap_Sort(int a[],int n)&#123;</span><br><span class="line">  int temp &#x3D; 0;</span><br><span class="line">  MakeMinHeap(a,n);</span><br><span class="line"></span><br><span class="line">  for(int i&#x3D;n-1;i&gt;0;i--)&#123;</span><br><span class="line">      temp &#x3D; a[0];</span><br><span class="line">      a[0] &#x3D; a[i];</span><br><span class="line">      a[i] &#x3D; temp;</span><br><span class="line">      MinHeapFixdown(a,0,i);</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、哈希"><a href="#五、哈希" class="headerlink" title="五、哈希"></a>五、哈希</h3><h4 id="1-hash表的实现"><a href="#1-hash表的实现" class="headerlink" title="1.hash表的实现"></a>1.hash表的实现</h4><p>（1）构造哈希</p>
<p>主要包括直接地址法、平方取中法、除留余数法等。</p>
<p>（2）处理哈希冲突</p>
<p>最常用的处理冲突的方法有开放定址法、再哈希法、链地址法、建立公共溢出区等方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开放定址法: 当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</span><br><span class="line"></span><br><span class="line">再哈希法：当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数。</span><br><span class="line"></span><br><span class="line">链地址法：将所有哈希值相同的Key通过链表存储。key按顺序插入到链表中</span><br><span class="line"></span><br><span class="line">建立公共溢出区：采用一个溢出表存储产生冲突的关键字。如果公共溢出区还产生冲突，再采用处理冲突方法处理。</span><br></pre></td></tr></table></figure>

<h4 id="2-哈希表的桶个数为什么是质数，合数有何不妥？"><a href="#2-哈希表的桶个数为什么是质数，合数有何不妥？" class="headerlink" title="2.哈希表的桶个数为什么是质数，合数有何不妥？"></a>2.哈希表的桶个数为什么是质数，合数有何不妥？</h4><p>哈希表的桶个数使用质数，可以最大程度减少冲突概率，使哈希后的数据分布的更加均匀。如果使用合数，可能会造成很多数据分布会集中在某些点上，从而影响哈希表效率。</p>
<h3 id="六、动态规划"><a href="#六、动态规划" class="headerlink" title="六、动态规划"></a>六、动态规划</h3><p>动态规划，利用问题的最优子结构性质，以自底向上的方式递归的从子问题的最优解逐步构造出整个问题的最优解。<br>对于重叠子问题，一个典型的问题是求斐波那契数列的第N项，如果用递归的方法做会存在大量的重叠子问题，而利用动态规划的方法就是解决了重叠子问题。<br>建立表格不断填表，相当于备忘录，也就是解决重叠子问题的技巧，典型的问题是斐波那契数列、背包问题等，许多动态规划问题都是定义数组，进行递推过程填充数组（模拟备忘录）。<br>马尔科夫性，是随机过程中某事件的发生只取决于它的上一事件、是“无记忆”过程。而动态规划具有“记忆性”。</p>
<h4 id="1-最长公共子序列（手写代码）"><a href="#1-最长公共子序列（手写代码）" class="headerlink" title="1.最长公共子序列（手写代码）"></a>1.最长公共子序列（手写代码）</h4><p>最长公共子序列问题： </p>
<p>给定两个字符串A、B，求A与B的最长公共子序列（子序列不要求是连续的）</p>
<p>举例：</p>
<p>字符串A： abcdef</p>
<p>字符串B：baaecd</p>
<p>输出：acd</p>
<p><img src="http://img.51nod.com/upload/000FBEAF/08D25D565D85EFF40000000000000002.jpeg" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class 最长公共子序列  &#123;</span><br><span class="line">    public  static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">        String str1&#x3D;input.next();</span><br><span class="line">        String str2&#x3D;input.next();</span><br><span class="line">        int m&#x3D;son(str1,str2);&#x2F;&#x2F;传两个字符串</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">    public  static  int  son(String str1,String str2)</span><br><span class="line">    &#123;</span><br><span class="line">    &#x2F;&#x2F;因为要形成上图的表格，所以给两个字符串头多添了一个字符</span><br><span class="line">    &#x2F;&#x2F;使第一行和第一列都变为0</span><br><span class="line">        String s1&#x3D;&quot;2&quot;+str1;</span><br><span class="line">        String s2&#x3D;&quot;1&quot;+str2;</span><br><span class="line">        int [][]check&#x3D;new int[str1.length()+1][str2.length()+1];</span><br><span class="line">        for(int i&#x3D;0;i&lt;s1.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;s2.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i&#x3D;&#x3D;0||j&#x3D;&#x3D;0)&#x2F;&#x2F;定义第一个格子为0</span><br><span class="line">                &#123;</span><br><span class="line">                    check[i][j]&#x3D;0;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(s1.charAt(i)&#x3D;&#x3D;s2.charAt(j))</span><br><span class="line">                &#123;</span><br><span class="line">                    check[i][j]&#x3D;(check[i-1][j-1]+1);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;  &#x2F;&#x2F;取上一个数和左边的数中大的数</span><br><span class="line">                    if(check[i-1][j]&gt;check[i][j-1])</span><br><span class="line">                        check[i][j]&#x3D;check[i-1][j];</span><br><span class="line">                    else</span><br><span class="line">                        check[i][j]&#x3D;check[i][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回数组的最后一位</span><br><span class="line">        return  check[s1.length()-1][s2.length()-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-最长公共子串"><a href="#2-最长公共子串" class="headerlink" title="2.最长公共子串"></a>2.最长公共子串</h4><p>对于两个字符串，请设计一个时间复杂度为O(m*n)的算法(这里的m和n为两串的长度)，求出两串的最长公共子串的长度。这里的最长公共子串的定义为两个序列U1,U2,..Un和V1,V2,…Vn，其中Ui + 1 == Ui+1,Vi + 1 == Vi+1，同时Ui == Vi。</p>
<p>给定两个字符串A和B，同时给定两串的长度n和m。</p>
<p>测试样例：<br>“1AB2345CD”,9,”12345EF”,7</p>
<p>返回：4</p>
<p><img src="https://img-blog.csdn.net/20140901134800948?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM5NzM2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string getLCS(string str1, string str2) &#123;</span><br><span class="line">	vector&lt;vector&lt;int&gt; &gt; record(str1.length(), vector&lt;int&gt;(str2.length()));</span><br><span class="line">	int maxLen &#x3D; 0, maxEnd &#x3D; 0;</span><br><span class="line">	for(int i&#x3D;0; i&lt;static_cast&lt;int&gt;(str1.length()); ++i)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; static_cast&lt;int&gt;(str2.length()); ++j) &#123;</span><br><span class="line">			if (str1[i] &#x3D;&#x3D; str2[j]) &#123;</span><br><span class="line">				if (i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0) &#123;</span><br><span class="line">					record[i][j] &#x3D; 1;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					record[i][j] &#x3D; record[i - 1][j - 1] + 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				record[i][j] &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">			if (record[i][j] &gt; maxLen) &#123;</span><br><span class="line">				maxLen &#x3D; record[i][j];</span><br><span class="line">				maxEnd &#x3D; i; &#x2F;&#x2F;若记录i,则最后获取LCS时是取str1的子串</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	return str1.substr(maxEnd - maxLen + 1, maxLen);</span><br></pre></td></tr></table></figure>
<h4 id="3-求一个字符串最长回文子串-手写代码"><a href="#3-求一个字符串最长回文子串-手写代码" class="headerlink" title="3.求一个字符串最长回文子串(手写代码)"></a>3.求一个字符串最长回文子串(手写代码)</h4><p>子串：小于等于原字符串长度由原字符串中任意个连续字符组成的子序列</p>
<p>回文：关于中间字符对称的文法，即“aba”(单核)、“cabbac”(双核)等</p>
<p>最长回文子串：1.寻找回文子串；2.该子串是回文子串中长度最长的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 求最长回文子串</span><br><span class="line"> * @author autumn_leaf</span><br><span class="line"> * @Date 2019&#x2F;03&#x2F;23</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PalindSubstring &#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">		while(sc.hasNext()) &#123;</span><br><span class="line">			String s &#x3D; sc.nextLine();</span><br><span class="line">			&#x2F;&#x2F;将一串字符转化为字符数组</span><br><span class="line">			char[] str &#x3D; s.toCharArray();</span><br><span class="line">			int len &#x3D; str.length;</span><br><span class="line">			int[][] dp &#x3D; new int[len+10][len+10];</span><br><span class="line">			&#x2F;&#x2F;dp数组初始化</span><br><span class="line">			for(int i&#x3D;0; i&lt;len; i++) &#123;</span><br><span class="line">				dp[i][i] &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;dp中相邻元素</span><br><span class="line">			for(int i&#x3D;0; i&lt;len-1; i++) &#123;</span><br><span class="line">				if(str[i] &#x3D;&#x3D; str[i+1]) &#123;</span><br><span class="line">					dp[i][i+1] &#x3D; 2;</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					dp[i][i+1] &#x3D; 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;**dp中至少相隔一个元素*&#x2F;</span><br><span class="line">			&#x2F;**k代表相隔的区间长度*&#x2F;</span><br><span class="line">			for(int k&#x3D;2; k&lt;len; k++) &#123;</span><br><span class="line">				&#x2F;&#x2F;i代表区间起始位置</span><br><span class="line">				for(int i&#x3D;0; i+k&lt;len; i++) &#123;</span><br><span class="line">					&#x2F;&#x2F;j代表区间末尾位置</span><br><span class="line">					int j &#x3D; i+k;</span><br><span class="line">					if(str[i] &#x3D;&#x3D; str[j]) &#123;</span><br><span class="line">						dp[i][j] &#x3D; dp[i+1][j-1] + 2;</span><br><span class="line">					&#125;else &#123;</span><br><span class="line">						dp[i][j] &#x3D;Math.max(dp[i+1][j], dp[i][j-1]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(dp[0][len-1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Manacher算法用一个辅助数组Len[i]表示以字符T[i]为中心的最长回文字串的最右字符到T[i]的长度，比如以T[i]为中心的最长回文字串是T[l,r],那么Len[i]=r-i+1。</p>
<p>对于上面的例子，可以得出Len[i]数组为:</p>
<p><img src="http://img.blog.csdn.net/20141221160159348" alt></p>
<p>Len数组有一个性质，那就是Len[i]-1就是该回文子串在原字符串S中的长度，至于证明，首先在转换得到的字符串T中，所有的回文字串的长度都为奇数，那么对于以T[i]为中心的最长回文字串，其长度就为2*Len[i]-1,经过观察可知，T中所有的回文子串，其中分隔符的数量一定比其他字符的数量多1，也就是有Len[i]个分隔符，剩下Len[i]-1个字符来自原字符串，所以该回文串在原字符串中的长度就为Len[i]-1。</p>
<p>有了这个性质，那么原问题就转化为求所有的Len[i]。下面介绍如何在线性时间复杂度内求出所有的Len。</p>
<h4 id="4-硬币表示"><a href="#4-硬币表示" class="headerlink" title="4.硬币表示"></a>4.硬币表示</h4><p>有数量不限的硬币，币值为25分、10分、5分和1分，请编写代码计算n分有几种表示法。</p>
<p>给定一个int n，请返回n分有几种表示法。保证n小于等于100000，为了防止溢出，请将答案Mod 1000000007。</p>
<p>测试样例：<br>6</p>
<p>返回：2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fun(int n, int coin)</span><br><span class="line">    &#123;</span><br><span class="line">        int nextcoin&#x3D;0;</span><br><span class="line">        switch(coin)</span><br><span class="line">        &#123;</span><br><span class="line">        case 25:</span><br><span class="line">            nextcoin&#x3D;10; break;</span><br><span class="line">        case 10:</span><br><span class="line">            nextcoin&#x3D;5; break;</span><br><span class="line">        case 5:</span><br><span class="line">            nextcoin&#x3D;1; break;</span><br><span class="line">        case 1:</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        int res&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i*coin&lt;&#x3D;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+&#x3D;fun(n-i*coin, nextcoin)%1000000007;</span><br><span class="line">        &#125;</span><br><span class="line">        return res%1000000007;&#x2F;&#x2F;%1000000007</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-字符混编"><a href="#5-字符混编" class="headerlink" title="5.字符混编"></a>5.字符混编</h4><p>A、B和C。如果C包含且仅包含来自A和B的所有字符，而且在C中属于A的字符之间保持原来在A中的顺序，属于B的字符之间保持原来在B中的顺序，那么称C是A和B的混编。实现一个函数，判断C是否是A和B的混编。</p>
<p>给定三个字符串A,B和C，及他们的长度。请返回一个bool值，代表C是否是A和B的混编。保证三个串的长度均小于等于100。</p>
<p>测试样例：<br>“ABC”,3,”12C”,3,”A12BCC”,6</p>
<p>返回：true</p>
<p><img src="http://uploadfiles.nowcoder.com/images/20150807/277064_1438943576180_1.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Mixture &#123;</span><br><span class="line">    public boolean chkMixture(String A, int n, String B, int m, String C, int v) &#123;</span><br><span class="line">        &#x2F;&#x2F; 边界情况处理</span><br><span class="line">        if (m + n !&#x3D; v)</span><br><span class="line">            return false;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F; 默认初始化为false</span><br><span class="line">        boolean[][] dp &#x3D; new boolean[101][101];</span><br><span class="line"> </span><br><span class="line">        dp[0][0] &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 初始化第0行</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;</span><br><span class="line">            if (B.charAt(i - 1) &#x3D;&#x3D; C.charAt(i - 1))</span><br><span class="line">                dp[0][i] &#x3D; true;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 初始化第0列</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">            if (A.charAt(i - 1) &#x3D;&#x3D; C.charAt(i - 1))</span><br><span class="line">                dp[i][0] &#x3D; true;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 状态转移方程</span><br><span class="line">         *  dp[i][j] &#x3D;</span><br><span class="line">         *</span><br><span class="line">         *  case 1: dp[i][j-1] &#x3D;&#x3D; true &amp;&amp; B[j-1] &#x3D;&#x3D; C[i+j-1]</span><br><span class="line">         * </span><br><span class="line">         *  case 2: dp[i-1][j] &#x3D;&#x3D; true &amp;&amp; A[i-1] &#x3D;&#x3D; C[i+j-1]</span><br><span class="line">         *</span><br><span class="line">         *&#x2F;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; m; ++j) &#123;</span><br><span class="line">                if (!dp[i][j]) &#123;</span><br><span class="line">                    &#x2F;&#x2F; dp[i-1][j] &#x3D; true &amp;&amp; A[i-1] &#x3D;&#x3D; C[i+j-1]</span><br><span class="line">                    if (dp[i - 1][j] &amp;&amp; A.charAt(i - 1) &#x3D;&#x3D; C.charAt(i + j - 1))</span><br><span class="line">                        dp[i][j] &#x3D; true;</span><br><span class="line"> </span><br><span class="line">                    &#x2F;&#x2F; dp[i][j-1] &#x3D;&#x3D; true &amp;&amp; B[j-1] &#x3D;&#x3D; C[i+j-1]</span><br><span class="line">                    if (dp[i][j - 1] &amp;&amp; B.charAt(j - 1) &#x3D;&#x3D; C.charAt(i + j - 1))</span><br><span class="line">                        dp[i][j] &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、链表"><a href="#七、链表" class="headerlink" title="七、链表"></a>七、链表</h3><h4 id="1-如何合并两个有序链表-手写代码"><a href="#1-如何合并两个有序链表-手写代码" class="headerlink" title="1.如何合并两个有序链表(手写代码)"></a>1.如何合并两个有序链表(手写代码)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*Definition for singly-linked list</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;递归</span><br><span class="line"></span><br><span class="line">class ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line"> </span><br><span class="line">    ListNode(int x)&#123;</span><br><span class="line">        val &#x3D; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        if (l1 &#x3D;&#x3D; null) return l2;</span><br><span class="line">        if (l2 &#x3D;&#x3D; null) return l1;</span><br><span class="line"> </span><br><span class="line">        ListNode head &#x3D; null;</span><br><span class="line">        if (l1.val &lt;&#x3D; l2.val)&#123;</span><br><span class="line">            head &#x3D; l1;</span><br><span class="line">            head.next &#x3D; mergeTwoLists(l1.next, l2);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head &#x3D; l2;</span><br><span class="line">            head.next &#x3D; mergeTwoLists(l1, l2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-反转链表（手写代码）"><a href="#2-反转链表（手写代码）" class="headerlink" title="2.反转链表（手写代码）"></a>2.反转链表（手写代码）</h4><p>递归</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Node reverse(Node head) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null)</span><br><span class="line">        return head;</span><br><span class="line">    Node temp &#x3D; head.next;</span><br><span class="line">    Node newHead &#x3D; reverse(head.next);</span><br><span class="line">    temp.next &#x3D; head;</span><br><span class="line">    head.next &#x3D; null;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Node reverseList(Node node) &#123;</span><br><span class="line">    Node pre &#x3D; null;</span><br><span class="line">    Node next &#x3D; null;</span><br><span class="line">    while (node !&#x3D; null) &#123;</span><br><span class="line">        next &#x3D; node.next;</span><br><span class="line">        node.next &#x3D; pre;</span><br><span class="line">        pre &#x3D; node;</span><br><span class="line">        node &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-判断一个链表是否为回文链表，说出你的思路并手写代码"><a href="#3-判断一个链表是否为回文链表，说出你的思路并手写代码" class="headerlink" title="3.判断一个链表是否为回文链表，说出你的思路并手写代码"></a>3.判断一个链表是否为回文链表，说出你的思路并手写代码</h4><ol>
<li>简单粗暴的做法就是：将链表反转生成一个新的链表，然后依次比较两个链表的每一个元素，如果均相等则是回文结构。这里我们可以不用反转链表，而是借助一个栈，将链表的数据全部压入栈中，然后从栈顶依次取出元素和原链表头部取出元素比较。栈的特点是先进后出，正好可以构成一个反转的链表。<br><img src="https://img-blog.csdnimg.cn/20190702222955833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlaW5pZmk=,size_16,color_FFFFFF,t_70" alt></li>
<li>根据回文结构的特点，链表前半部分和后半部分反转之后顺序是一致的，所以可以考虑不用反转整个链表，而是后半部分。要找到后半部分，需要两个指针，他们都从头部开始遍历，一个指针遍历的速度是另一个指针的两倍，这样，当快的指针遍历完成的时候，慢的指针位置就正好是中间位置。再把中间位置到链表尾部的所有节点放入一个堆栈，构成一个反转的链表，后面的判断就回到第一个办法的判断了。<br><img src="https://img-blog.csdnimg.cn/20190702223336946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlaW5pZmk=,size_16,color_FFFFFF,t_70" alt></li>
</ol>
<h4 id="4-如何判断两个单向链表是否相交"><a href="#4-如何判断两个单向链表是否相交" class="headerlink" title="4.如何判断两个单向链表是否相交"></a>4.如何判断两个单向链表是否相交</h4><p>判断两个链表是否相交</p>
<p>1）方法1：</p>
<p>链表相交之后，后面的部分节点全部共用，可以用2个指针分别从这两个链表头部走到尾部，最后判断尾部指针的地址信息是否一样，若一样则代表链表相交！</p>
<p>2）方法2：</p>
<p>可以把其中一个链表的所有节点地址信息存到数组中，然后把另一个链表的每一个节点地址信息遍历数组，若相等，则跳出循环，说明链表相交。进一步优化则是进行hash排序，建立hash表。</p>
<h3 id="八、高级算法"><a href="#八、高级算法" class="headerlink" title="八、高级算法"></a>八、高级算法</h3><h4 id="1-单向加密"><a href="#1-单向加密" class="headerlink" title="1.单向加密"></a>1.单向加密</h4><p>1）定义</p>
<p>单向加密又称为不可逆加密算法，其密钥是由加密散列函数生成的。</p>
<p>2）例子</p>
<ul>
<li><p>MD5（Message Digest Algorithm 5）：是RSA数据安全公司开发的一种单向散列算法，非可逆，相同的明文产生相同的密文；</p>
</li>
<li><p>SHA（Secure Hash Algorithm）：可以对任意长度的数据运算生成一个160位的数值。其变种由SHA192，SHA256，SHA384等；</p>
</li>
</ul>
<p>3）算法特征：</p>
<p>输入一样，输出必然相同；</p>
<p>雪崩效应，输入的微小改变，将会引起结果的巨大变化；</p>
<p>定长输出，无论原始数据多大，结果大小都是相同的；</p>
<p>不可逆，无法根据特征码还原原来的数据；</p>
<h4 id="2-对称加密"><a href="#2-对称加密" class="headerlink" title="2.对称加密"></a>2.对称加密</h4><p>采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。</p>
<p>特点：</p>
<p>1、加密方和解密方使用同一个密钥；</p>
<p>2、加密解密的速度比较快，适合数据比较长时的使用；</p>
<p>3、密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦；</p>
<p>优点：对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。</p>
<p>缺点：对称加密算法的缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p>
<h4 id="3-非对称加密"><a href="#3-非对称加密" class="headerlink" title="3.非对称加密"></a>3.非对称加密</h4><p>非对称密钥加密也称为公钥加密，由一对公钥和私钥组成。公钥是从私钥提取出来的。可以用公钥加密，再用私钥解密，这种情形一般用于公钥加密，当然也可以用私钥加密，用公钥解密。常用于数字签名，因此非对称加密的主要功能就是加密和数字签名。</p>
<p>特征：</p>
<p>1）秘钥对，公钥(public key)和私钥(secret key)</p>
<p>2）主要功能：加密和签名</p>
<p>发送方用对方的公钥加密，可以保证数据的机密性（公钥加密）。</p>
<p>发送方用自己的私钥加密，可以实现身份验证（数字签名）。</p>
<p>3）公钥加密算法很少用来加密数据，速度太慢，通常用来实现身份验证。</p>
<p>常用的非对称加密算法</p>
<p>RSA：由 RSA公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；既可以实现加密，又可以实现签名。</p>
<p>DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准）。</p>
<p>ECC（Elliptic Curves Cryptography）：椭圆曲线密码编码。</p>
<h4 id="4-LRU缓存"><a href="#4-LRU缓存" class="headerlink" title="4.LRU缓存"></a>4.LRU缓存</h4><p>LRU(最近最少使用)算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高</p>
<p>实现：使用一个链表保存缓存数据，将新数据插入到头部，每当缓存命中时，则将命中的数据移动到链表头部，当链表满的时候，将链表尾部的数据丢弃。</p>
<h3 id="九、字符串处理"><a href="#九、字符串处理" class="headerlink" title="九、字符串处理"></a>九、字符串处理</h3><h4 id="1-给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c"><a href="#1-给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c" class="headerlink" title="1.给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c"></a>1.给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c</h4><p>使用哈希的思想，建立256个bool数组array，初始都为false,从头开始扫描字符串，扫到一个，将以其ascii码为下标的元素置true。例如扫描到A的时候，执行：array[‘A’]=true。第二边扫描，扫到一个字母就以其ascii码为下标，去array数组中看其值，如果是true,返回改字母，如果是false，继续扫描下一个字母。</p>
<h3 id="十、贪心算法"><a href="#十、贪心算法" class="headerlink" title="十、贪心算法"></a>十、贪心算法</h3><h4 id="1-安置路灯"><a href="#1-安置路灯" class="headerlink" title="1.安置路灯"></a>1.安置路灯</h4><p>小Q正在给一条长度为n的道路设计路灯安置方案。</p>
<p>为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用’.’表示, 不需要照亮的障碍物格子用’X’表示。</p>
<p>小Q现在要在道路上设置一些路灯, 对于安置在pos位置的路灯, 这盏路灯可以照亮pos - 1, pos, pos + 1这三个位置。</p>
<p>小Q希望能安置尽量少的路灯照亮所有’.’区域, 希望你能帮他计算一下最少需要多少盏路灯。</p>
<p>输入描述:<br>输入的第一行包含一个正整数t(1 &lt;= t &lt;= 1000), 表示测试用例数<br>接下来每两行一个测试数据, 第一行一个正整数n(1 &lt;= n &lt;= 1000),表示道路的长度。<br>第二行一个字符串s表示道路的构造,只包含’.’和’X’。</p>
<p>输出描述:<br>对于每个测试用例, 输出一个正整数表示最少需要多少盏路灯。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        String string &#x3D; scanner.nextLine();</span><br><span class="line">        int caseNumber &#x3D; Integer.parseInt(string);</span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String nString &#x3D; scanner.nextLine();</span><br><span class="line">            int n &#x3D; Integer.parseInt(nString);</span><br><span class="line"></span><br><span class="line">            String road &#x3D; scanner.nextLine();</span><br><span class="line"></span><br><span class="line">            int result &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">                if (road.substring(i,i+1).equals(&quot;.&quot;))&#123;</span><br><span class="line">                    result++;</span><br><span class="line">                    i+&#x3D;2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(result);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="十一、实战题目"><a href="#十一、实战题目" class="headerlink" title="十一、实战题目"></a>十一、实战题目</h3><h4 id="1-九宫格解锁方案（Vivo）"><a href="#1-九宫格解锁方案（Vivo）" class="headerlink" title="1.九宫格解锁方案（Vivo）"></a>1.九宫格解锁方案（Vivo）</h4><p>1、问题定义</p>
<p>问题很简单：安卓的手势解锁是3*3的点阵，在这个点阵上的解锁手势一共有多少种情况？这里一个合格的解锁手势轨迹必须满足以下两个条件：</p>
<ul>
<li>至少连接点阵中的四个点。</li>
<li>手势的轨迹不能跨过一个还没有经过的节点。</li>
<li>不允许重复经过某个定点两次。</li>
</ul>
<p>2、问题转化</p>
<p>为了方便，这里将点阵中的每个点用一个数字代替，1到9九个数字分别代表点阵中的一个点。这样，一个解锁手势可以对应到一个由1到9数字组成的字符串(该字符串中没有重复)。</p>
<p>去掉第二个限制条件，一种解锁手势正好对应一种1到9的排列。连接四个点的解锁手势的所有情况就是9选4的全排列，连接5个点的就是9选5的全排列，以此类推。</p>
<p>计算全排列的比较容易，接下来要解决的就是如何剔除那些不符合限制条件(手势的轨迹不能跨过一个还没有经过的节点)的手势。在3*3的点阵中，不符合条件的情况(也就是两个点的连接过程中跨过点的情况)比较有限，这里我们将其全部列出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from itertools import chain, permutations</span><br><span class="line"></span><br><span class="line">impossible &#x3D; &#123;&#39;13&#39;: &#39;2&#39;, &#39;46&#39;: &#39;5&#39;, &#39;79&#39;: &#39;8&#39;, &#39;17&#39;: &#39;4&#39;, &#39;28&#39;: &#39;5&#39;, &#39;39&#39;: &#39;6&#39;, &#39;19&#39;: &#39;5&#39;, &#39;37&#39;: &#39;5&#39;, &#39;31&#39;: &#39;2&#39;, &#39;64&#39;: &#39;5&#39;, &#39;97&#39;: &#39;8&#39;, &#39;71&#39;: &#39;4&#39;, &#39;82&#39;: &#39;5&#39;, &#39;93&#39;: &#39;6&#39;, &#39;91&#39;: &#39;5&#39;, &#39;73&#39;: &#39;5&#39;&#125;</span><br><span class="line"></span><br><span class="line">def counts_n(n):</span><br><span class="line">        iterlst &#x3D; permutations(&#39;123456789&#39;, n)</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        for i in iterlst:</span><br><span class="line">                stri &#x3D; &#39;&#39;.join(i)</span><br><span class="line">                for k, v in impossible.items():</span><br><span class="line">                        if k in stri and v not in stri[:stri.find(k)]:</span><br><span class="line">                                break</span><br><span class="line">                else: </span><br><span class="line">                        count +&#x3D; 1</span><br><span class="line">        return count</span><br><span class="line">   </span><br><span class="line">sum &#x3D; 0  </span><br><span class="line">print(&quot;len  num  sum&quot;)</span><br><span class="line">for i in range(4,10):</span><br><span class="line">        temp &#x3D; counts_n(i)</span><br><span class="line">        sum &#x3D; sum + temp</span><br><span class="line">        print(str(i)+&quot;  &quot;+str(temp)+&quot;  &quot;+str(sum))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len  num  sum</span><br><span class="line">4  1624  1624</span><br><span class="line">5  7152  8776</span><br><span class="line">6  26016  34792</span><br><span class="line">7  72912  107704</span><br><span class="line">8  140704  248408</span><br><span class="line">9  140704  389112</span><br></pre></td></tr></table></figure>

<h4 id="2-爬楼梯算法"><a href="#2-爬楼梯算法" class="headerlink" title="2.爬楼梯算法"></a>2.爬楼梯算法</h4><p>第一种题目（递归实现）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设一个楼梯有 N 阶台阶，人每次最多可以跨 M 阶，求总共的爬楼梯方案数。</span><br><span class="line"></span><br><span class="line">例如楼梯总共有3个台阶，人每次最多跨2个台阶，也就是说人每次可以走1个，也可以走2个，但最多不会超过2个，那么楼梯总共有这么几种走法：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int calculateCount(int ladder, int maxJump) &#123;</span><br><span class="line">    int jump &#x3D; 0;</span><br><span class="line">    if (ladder &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ladder &gt;&#x3D; maxJump) &#123;</span><br><span class="line">        &#x2F;&#x2F; 剩下的楼梯大于最大可跳跃数</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; maxJump; i++) &#123;</span><br><span class="line">            jump +&#x3D; calculateCount(ladder - i, maxJump);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 剩下的楼梯不足最大可跳跃数</span><br><span class="line">        jump &#x3D; calculateCount(ladder, ladder);</span><br><span class="line">    &#125;</span><br><span class="line">    return jump;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题有一道变体（非递归方式实现）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设一个楼梯有 N 阶台阶，人每次最多可以跨 2 阶，求总共的爬楼梯方案数，要求不用递归实现</span><br></pre></td></tr></table></figure>

<p>随着楼梯数n的增加，爬法总数呈现斐波那契数列规律增加，即f（n） = f（n-1） + f（n-2）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param ladder 台阶数量</span><br><span class="line"> * @return 总的爬法</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int count(int ladder) &#123;</span><br><span class="line">    if (ladder &#x3D;&#x3D; 1 || ladder &#x3D;&#x3D; 2) &#123;</span><br><span class="line">        return ladder;</span><br><span class="line">    &#125;</span><br><span class="line">    int n1 &#x3D; 1;</span><br><span class="line">    int n2 &#x3D; 2;</span><br><span class="line">    for (int i &#x3D; 3; i &lt;&#x3D; ladder; i++) &#123;</span><br><span class="line">        int tmp &#x3D; n2;</span><br><span class="line">        n2 &#x3D; n1 + n2;</span><br><span class="line">        n1 &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-两数之和"><a href="#3-两数之和" class="headerlink" title="3.两数之和"></a>3.两数之和</h4><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>1.解法一：使用for循环遍历</p>
<p>2.解法二：使用HashMap的性质</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if (map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                return new int[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三数之和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     *      时间复杂度：n2</span><br><span class="line">     *      空间复杂度：1</span><br><span class="line">     * 代码执行过程：</span><br><span class="line">     *</span><br><span class="line">     * 总结：</span><br><span class="line">     *</span><br><span class="line">     * ***********************************&#x2F;</span><br><span class="line">public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line"></span><br><span class="line">    if (nums &#x3D;&#x3D; null || nums.length &lt; 3) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">    int comp &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    int result &#x3D; Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果和之前那个数据相同，则会是重复事件</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int leftIndex &#x3D; i + 1;</span><br><span class="line">        int rightIndex &#x3D; nums.length - 1;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 滑动列表</span><br><span class="line">        while (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">            int tmp &#x3D; nums[leftIndex] + nums[rightIndex] + nums[i];</span><br><span class="line">            if (comp &gt; Math.abs(tmp - target)) &#123;</span><br><span class="line">                comp &#x3D; Math.abs(tmp - target);</span><br><span class="line">                result &#x3D; tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (tmp &gt; target) &#123;</span><br><span class="line">                rightIndex--;</span><br><span class="line">            &#125; else if (tmp &lt; target) &#123;</span><br><span class="line">                leftIndex++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 差值为0，最爽了，直接返回</span><br><span class="line">                return tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-最大回撤"><a href="#4-最大回撤" class="headerlink" title="4.最大回撤"></a>4.最大回撤</h4><p>题目形式：有一个数组，求其中两个数x,y，满足x的索引小于y的索引，使得 x-y 最大。例如 arr = [3,7,2,6,4,1,9,8,5]， 最大回撤是6，对应的x=7,y=1。</p>
<p>解法一</p>
<p>算法实现有很多，简单粗暴的方法比如把每一天的值和其他天作差值计算，找到差值最大的那一天，但这个方法并不好。从时间复杂度上看是O(n!)，差不多算是最差的了。</p>
<p>解法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 计算最大回撤</span><br><span class="line"> * </span><br><span class="line"> * @author qcy</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">class FundTools &#123;</span><br><span class="line"> </span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 由净值序列x，直接计算最大回撤</span><br><span class="line">	 * </span><br><span class="line">	 * @param x</span><br><span class="line">	 *            累计份额净值序列</span><br><span class="line">	 * @return 最大回撤</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public double calc_max_dd(double[] x) &#123;</span><br><span class="line">		double max_unit_value &#x3D; x[0];</span><br><span class="line">		double max_dd &#x3D; 0;</span><br><span class="line">		double dd &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">		for (int i &#x3D; 1; i &lt; x.length; i++) &#123;</span><br><span class="line">			max_unit_value &#x3D; Math.max(x[i], max_unit_value);</span><br><span class="line">			dd &#x3D; x[i] &#x2F; max_unit_value - 1;</span><br><span class="line">			max_dd &#x3D; Math.min(dd, max_dd);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		return max_dd;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 根据每日收盘后份额净值和截止前一日的最大回撤、最高水位，计算今日的最大回撤</span><br><span class="line">	 * </span><br><span class="line">	 * @param max_dd</span><br><span class="line">	 *            截止到i-1日的最大回撤</span><br><span class="line">	 * @param max_unit_value</span><br><span class="line">	 *            截止到i-1日的最高累计份额净值</span><br><span class="line">	 * @param today_unit_value</span><br><span class="line">	 *            i日的累计份额净值</span><br><span class="line">	 * @return 第i日的最大回撤</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public double calc_max_dd(double max_dd, double max_unit_value,</span><br><span class="line">			double today_unit_value) &#123;</span><br><span class="line">		max_unit_value &#x3D; Math.max(max_unit_value, today_unit_value);</span><br><span class="line">		double dd &#x3D; today_unit_value &#x2F; max_unit_value - 1;</span><br><span class="line">		return Math.min(dd, max_dd);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-合并两个有序数组"><a href="#5-合并两个有序数组" class="headerlink" title="5.合并两个有序数组"></a>5.合并两个有序数组</h4><p>题目形式：</p>
<p>给定两个按升序排列的有序数组，将它们合并成一个新的有序数组。例如：a = [1,2,6,8], b = [2,4,7,10]，输出为 arr = [1,2,2,4,6,7,8,10]</p>
<p>解法一：开个新的数组，填充上去</p>
<p>解法二：因原数组都是有序数组，只需要从两个数组的最后一个元素开始对比，寻找最大值赋值给最终数组。</p>
<p>如果数组二元素耗尽，则得到最终数组。<br>如果数组一元素耗尽，则需要将原数组二剩余元素赋值给最终数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        if(m &#x3D;&#x3D;0 ) &#123;</span><br><span class="line">            System.arraycopy(nums2,0,nums1,0, n);</span><br><span class="line">        &#125;</span><br><span class="line">        int i1 &#x3D; m -1;</span><br><span class="line">        int i2 &#x3D; n -1;</span><br><span class="line">        while(i2&gt;&#x3D;0)&#123;</span><br><span class="line">            if(i1 &lt; 0)&#123;</span><br><span class="line">                System.arraycopy(nums2,0,nums1,0,i2+1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums1[i1] &gt;&#x3D; nums2[i2]) &#123;</span><br><span class="line">                nums1[i1 + i2 +1]&#x3D;nums1[i1--];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                nums1[i1 + i2 +1]&#x3D;nums2[i2--];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-最大连续子数组和"><a href="#6-最大连续子数组和" class="headerlink" title="6.最大连续子数组和"></a>6.最大连续子数组和</h4><p>题目形式：</p>
<p>给定一个数组，求其最大连续子数组的和。例如：arr = [1,5,-10,2,5,-3,2,6,-3,1]. 输出为：12。对应的连续子数组为 [2,5,-3,2,6]。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int maxSunArray(int[] array) &#123;</span><br><span class="line">       if (array.length&#x3D;&#x3D;0 || array&#x3D;&#x3D;null) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">      int Sum &#x3D; 0;     </span><br><span class="line">      int max &#x3D; 0;            </span><br><span class="line">      for (int i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">          </span><br><span class="line">          if(Sum&lt;&#x3D;0)&#123;      &#x2F;&#x2F;如果当前连续n项的和小于等于0,则没必要与后面的元素相加</span><br><span class="line">              Sum &#x3D; array[i];      &#x2F;&#x2F;Sum重新赋值</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">              Sum +&#x3D; array[i];     &#x2F;&#x2F;如果Sum的值大于0,则继续与后面的元素相加,</span><br><span class="line">          &#125;</span><br><span class="line">          if(Sum&gt;max)&#123;         &#x2F;&#x2F;每次改变Sum的值都有与max进行比较</span><br><span class="line">              max &#x3D; Sum;       &#x2F;&#x2F;如果Sum的值大于max,则将Sum的值赋值给max</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>动态规划</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;解法二：使用动态规划:</span><br><span class="line">&#x2F;&#x2F;F（i）：以array[i]为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变</span><br><span class="line">&#x2F;&#x2F;F（i）&#x3D;max（F（i-1）+array[i] ， array[i]）</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public  int FindGreatestSumOfSubArray(int[] array) &#123;</span><br><span class="line">            int res &#x3D; array[0]; &#x2F;&#x2F;记录当前所有子数组的和的最大值</span><br><span class="line">            int max &#x3D; array[0]; &#x2F;&#x2F;包含array[i]的连续数组最大值</span><br><span class="line">            for (int i &#x3D; 1; i &lt; array.length; i++) &#123;</span><br><span class="line">                 max&#x3D;Math.max(max+array[i], array[i]);</span><br><span class="line">                 res&#x3D;Math.max(max, res);</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-最长不重复子串"><a href="#7-最长不重复子串" class="headerlink" title="7.最长不重复子串"></a>7.最长不重复子串</h4><p>题目形式：</p>
<p>给定一个字符串，找出没有重复字符的最长的子串。例如输入“abcbefgf”，答案是 “cbefg”。</p>
<p>我的方法：（时间复杂度较大）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int start, end;</span><br><span class="line">        String count &#x3D; &quot;&quot;;</span><br><span class="line">        String str &#x3D; &quot;&quot;;</span><br><span class="line">        for(start&#x3D;0; start&lt;s.length(); start++)&#123;</span><br><span class="line">            for(end&#x3D;start+1; end&lt;&#x3D;s.length(); end++)&#123;</span><br><span class="line">                str &#x3D; s.substring(start, end);</span><br><span class="line">                if(end &#x3D;&#x3D; s.length())&#123;</span><br><span class="line">                    if(count.length() &lt; str.length())&#123;&#x2F;&#x2F;对比长度</span><br><span class="line">                        count &#x3D; str;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(str.contains(s.substring(end, end+1)))&#123;&#x2F;&#x2F;当有重复时候，处理，跳出循环让start++</span><br><span class="line">                        if(count.length() &lt; str.length())&#123;&#x2F;&#x2F;对比长度</span><br><span class="line">                            count &#x3D; str;</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2、滑动窗口思想：如果确定子串s[i,j]（假设表示字符串的第i个字符到第j-1个字符表示的子串），那么只需要比较s[j]是否与子串s[i,j]重复即可</p>
<p>若重复：记录此时滑动窗口大小，并与最大滑动窗口比较，赋值。然后滑动窗口大小重定义为1，头位置不变，并右移一个单位。</p>
<p>若不重复：滑动窗口头不变，结尾+1，整个窗口加大1个单位。继续比较下一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int n &#x3D; s.length();</span><br><span class="line">        Set&lt;Character&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        int ans &#x3D; 0, i &#x3D; 0, j &#x3D; 0;</span><br><span class="line">        while (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            &#x2F;&#x2F; try to extend the range [i, j]</span><br><span class="line">            if (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans &#x3D; Math.max(ans, j - i);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                set.remove(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用HashMap(这是一道动态规划+哈希查找的综合应用题)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int n &#x3D; s.length(), ans &#x3D; 0;</span><br><span class="line">        Map&lt;Character, Integer&gt; map &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F; current index of character</span><br><span class="line">        &#x2F;&#x2F; try to extend the range [i, j]</span><br><span class="line">        for (int j &#x3D; 0, i &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i &#x3D; Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            ans &#x3D; Math.max(ans, j - i + 1);</span><br><span class="line">            map.put(s.charAt(j), j + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-全排列-这是一道动态规划-排列组合的综合应用题"><a href="#8-全排列-这是一道动态规划-排列组合的综合应用题" class="headerlink" title="8.全排列(这是一道动态规划+排列组合的综合应用题)"></a>8.全排列(这是一道动态规划+排列组合的综合应用题)</h4><p>题目形式：</p>
<p>给定一个数组，找出其所有可能的排列。例如: arr = [1,1,3]，输出为 [[1,1,3],[1,3,1],[3,1,1]]。</p>
<p>（1）确定第一位的字符<br>数组arr从start到end的所有记录都可以出现在第一个位置，所以直接一个for循环，考虑了这所有的情况。在for循环中，swap方法就是交换i和start位置的数，保证当前i指向的记录出现在第一个位置，也就是start指向的位置</p>
<p>（2）剩下的记录继续做全排列<br>这个就是一个递归函数的调用，只需要修改起始位置，也就是start+1，因为start的位置已经放了记录，所以只需要继续做从start+1到end的全排列即可<br>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123; 1, 2, 3, 4 &#125;;</span><br><span class="line">        fullSort(arr, 0, arr.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void fullSort(int[] arr, int start, int end) &#123;</span><br><span class="line">        &#x2F;&#x2F; 递归终止条件</span><br><span class="line">        if (start &#x3D;&#x3D; end) &#123;</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; start; i &lt;&#x3D; end; i++) &#123;</span><br><span class="line">            swap(arr, i, start);</span><br><span class="line">            fullSort(arr, start + 1, end);</span><br><span class="line">            swap(arr, i, start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int tmp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展应用：图书排列</p>
<p>题目描述：将编号为1~10的10本书排放在书架上，要求编号相邻的书不能放在相邻的位置。<br>请计算一共有多少种不同的排列方案。</p>
<p>注意，需要提交的是一个整数，不要填写任何多余的内容。</p>
<p>解题思路：这个题目有很多解法，这里只说明用全排列怎么解决，先求出全排列，也就是所有的排列方案，然后去掉不满足条件的情况，也就是编号相邻的书不能相邻这一条件。</p>
<p>完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BookSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] &#x3D; &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;</span><br><span class="line">        fullSort(arr, 0, arr.length - 1);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int res &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    static void fullSort(int[] arr, int start, int end) &#123;</span><br><span class="line">        &#x2F;&#x2F; 递归终止条件</span><br><span class="line">        if (start &#x3D;&#x3D; end) &#123;</span><br><span class="line">            &#x2F;&#x2F; 求出了全排列的一种情况，然后检查是否满足条件</span><br><span class="line">            if (check(arr))</span><br><span class="line">                res++;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; start; i &lt;&#x3D; end; i++) &#123;</span><br><span class="line">            swap(arr, start, i);</span><br><span class="line">            fullSort(arr, start + 1, end);</span><br><span class="line">            swap(arr, start, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int tmp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static boolean check(int[] arr) &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (Math.abs(arr[i] - arr[i - 1]) &#x3D;&#x3D; 1)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-穷举法"><a href="#9-穷举法" class="headerlink" title="9.穷举法"></a>9.穷举法</h4><p>平面内有n个矩形, 第i个矩形的左下角坐标为(x1[i], y1[i]), 右上角坐标为(x2[i], y2[i])。<br>如果两个或者多个矩形有公共区域则认为它们是相互重叠的(不考虑边界和角落)。<br>请你计算出平面内重叠矩形数量最多的地方,有多少个矩形相互重叠。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args) throws IOException&#123;</span><br><span class="line">        BufferedReader bf &#x3D; new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        int num &#x3D; Integer.parseInt(bf.readLine());</span><br><span class="line">        int [] x1 &#x3D; new int[num];</span><br><span class="line">        int [] y1 &#x3D; new int[num];</span><br><span class="line">        int [] x2 &#x3D; new int[num];</span><br><span class="line">        int [] y2 &#x3D; new int[num];</span><br><span class="line">        if(num &lt; 2 || num &gt; 50)</span><br><span class="line">            return;</span><br><span class="line">        else&#123;</span><br><span class="line">            String [] str &#x3D; bf.readLine().split(&quot; +&quot;);</span><br><span class="line">            for(int i &#x3D; 0;i&lt;num;i++)&#123;</span><br><span class="line">                x1[i] &#x3D; Integer.parseInt(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            str &#x3D; bf.readLine().split(&quot; +&quot;);</span><br><span class="line">            for(int i &#x3D; 0;i&lt;num;i++)&#123;</span><br><span class="line">                y1[i] &#x3D; Integer.parseInt(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            str &#x3D; bf.readLine().split(&quot; +&quot;);</span><br><span class="line">            for(int i &#x3D; 0;i&lt;num;i++)&#123;</span><br><span class="line">                x2[i] &#x3D; Integer.parseInt(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            str &#x3D; bf.readLine().split(&quot; +&quot;);</span><br><span class="line">            for(int i &#x3D; 0;i&lt;num;i++)&#123;</span><br><span class="line">                y2[i] &#x3D; Integer.parseInt(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(solution(num,x1,y1,x2,y2));</span><br><span class="line">    &#125;</span><br><span class="line">    public static int solution(int num,int[]x1,int[]y1,int[]x2,int[]y2)&#123;</span><br><span class="line">        int temp&#x3D;0,max&#x3D;0;</span><br><span class="line">        for(int x:x1)</span><br><span class="line">            for(int y:y1)&#123;</span><br><span class="line">                for(int i &#x3D; 0; i&lt;num ; i++)&#123;</span><br><span class="line">                    if(x&gt;&#x3D;x1[i] &amp;&amp; x&lt;x2[i]&amp;&amp; y&gt;&#x3D;y1[i]&amp;&amp;y&lt;y2[i])</span><br><span class="line">                        temp++;</span><br><span class="line">                &#125;</span><br><span class="line">                if(max &lt; temp)</span><br><span class="line">                    max &#x3D; temp;</span><br><span class="line">                temp &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        return max;</span><br><span class="line">                 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目描述</p>
<p>牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为w。<br>牛牛家里一共有n袋零食, 第i袋零食体积为v[i]。<br>牛牛想知道在总体积不超过背包容量的情况下,他一共有多少种零食放法(总体积为0也算一种放法)。</p>
<p>输入描述:</p>
<p>输入包括两行<br>第一行为两个正整数n和w(1 &lt;= n &lt;= 30, 1 &lt;= w &lt;= 2 * 10^9),表示零食的数量和背包的容量。<br>第二行n个正整数v[i](0 &lt;= v[i] &lt;= 10^9),表示每袋零食的体积。</p>
<p>输出描述:<br>输出一个正整数, 表示牛牛一共有多少种零食放法。</p>
<p>注意：总数sum要表示成long型，不然会越界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    private static int result &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String strTemp &#x3D; scanner.nextLine();</span><br><span class="line">            if (strTemp.isEmpty())&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] str &#x3D; strTemp.split(&quot; &quot;);</span><br><span class="line">            int n &#x3D; Integer.parseInt(str[0]);</span><br><span class="line">            int m &#x3D;Integer.parseInt(str[1]);</span><br><span class="line"></span><br><span class="line">            String [] size &#x3D; scanner.nextLine().split(&quot; &quot;);</span><br><span class="line">            int [] sizeArray &#x3D; new int[size.length];</span><br><span class="line">            long sum &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size.length; i++) &#123;</span><br><span class="line">                sizeArray[i] &#x3D; Integer.parseInt(size[i]);</span><br><span class="line">                sum +&#x3D; sizeArray[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (sum&lt;&#x3D;m)&#123;</span><br><span class="line">                System.out.println((int)Math.pow(2,n));</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                sum &#x3D; 0;</span><br><span class="line">                result +&#x3D;1;</span><br><span class="line">                dfs(sizeArray, sum, m, 0);</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void dfs(int[] arraySize, long sum, int m, int position)&#123;</span><br><span class="line">        if (position&lt;arraySize.length)&#123;</span><br><span class="line">            if (sum&gt;&#x3D;m)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(arraySize, sum, m, position+1);</span><br><span class="line"></span><br><span class="line">            if (sum+arraySize[position]&lt;m)&#123;</span><br><span class="line">                result +&#x3D;1;</span><br><span class="line">                sum +&#x3D; arraySize[position];</span><br><span class="line">                dfs(arraySize, sum,m,position+1);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目描述</p>
<p>小易有一些立方体，每个立方体的边长为1，他用这些立方体搭了一些塔。<br>现在小易定义：这些塔的不稳定值为它们之中最高的塔与最低的塔的高度差。<br>小易想让这些塔尽量稳定，所以他进行了如下操作：每次从某座塔上取下一块立方体，并把它放到另一座塔上。</p>
<p>注意，小易不会把立方体放到它原本的那座塔上，因为他认为这样毫无意义。<br>现在小易想要知道，他进行了不超过k次操作之后，不稳定值最小是多少。</p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行两个数n,k (1 &lt;&#x3D; n &lt;&#x3D; 100, 0 &lt;&#x3D; k &lt;&#x3D; 1000)表示塔的数量以及最多操作的次数。</span><br><span class="line">第二行n个数，ai(1 &lt;&#x3D; ai &lt;&#x3D; 104)表示第i座塔的初始高度。</span><br></pre></td></tr></table></figure>
<p>输出描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行两个数s, m，表示最小的不稳定值和操作次数(m &lt;&#x3D; k)</span><br><span class="line">接下来m行，每行两个数x,y表示从第x座塔上取下一块立方体放到第y座塔上。</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">5 8 5</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 2</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<p>每次都把数组进行排序，然后最大值-1，最小值+1，用ArrayList记录这一操作的痕迹。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String strTemp &#x3D; scanner.nextLine();</span><br><span class="line"></span><br><span class="line">            String[] str &#x3D; strTemp.split(&quot; &quot;);</span><br><span class="line">            int n &#x3D; Integer.parseInt(str[0]);</span><br><span class="line">            int k &#x3D;Integer.parseInt(str[1]);</span><br><span class="line"></span><br><span class="line">            String [] size &#x3D; scanner.nextLine().split(&quot; &quot;);</span><br><span class="line">            int[] sizeArray &#x3D; new int[n];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size.length; i++) &#123;</span><br><span class="line">                sizeArray[i] &#x3D; Integer.parseInt(size[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            int count &#x3D; 0;</span><br><span class="line">            ArrayList&lt;Integer&gt; list1 &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            ArrayList&lt;Integer&gt; list2 &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">                int max &#x3D; findMaxPosition(sizeArray);</span><br><span class="line">                int min &#x3D; findMinPosition(sizeArray);</span><br><span class="line"></span><br><span class="line">                if (sizeArray[max]-sizeArray[min]&lt;&#x3D;1)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                count++;</span><br><span class="line">                sizeArray[max]--;</span><br><span class="line">                sizeArray[min]++;</span><br><span class="line">                list1.add(max+1);</span><br><span class="line">                list2.add(min+1);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sizeArray[findMaxPosition(sizeArray)] - sizeArray[findMinPosition(sizeArray)] +&quot; &quot;+count);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; list1.size(); i++) &#123;</span><br><span class="line">                System.out.println(list1.get(i) + &quot; &quot; + list2.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int findMaxPosition(int[] arraySize)&#123;</span><br><span class="line">        int[] temp &#x3D; Arrays.copyOfRange(arraySize, 0,arraySize.length);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(temp);</span><br><span class="line">        int max &#x3D; temp[temp.length-1];</span><br><span class="line">        int position &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arraySize.length; i++) &#123;</span><br><span class="line">            if (max &#x3D;&#x3D; arraySize[i])&#123;</span><br><span class="line">                position &#x3D; i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int findMinPosition(int[] arraySize)&#123;</span><br><span class="line">        int[] temp &#x3D; Arrays.copyOfRange(arraySize, 0,arraySize.length);</span><br><span class="line">        Arrays.sort(temp);</span><br><span class="line">        int min &#x3D; temp[0];</span><br><span class="line">        int position &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arraySize.length; i++) &#123;</span><br><span class="line">            if (min &#x3D;&#x3D; arraySize[i])&#123;</span><br><span class="line">                position &#x3D; i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-数学"><a href="#10-数学" class="headerlink" title="10.数学"></a>10.数学</h4><p>今天上课，老师教了小易怎么计算加法和乘法，乘法的优先级大于加法，但是如果一个运算加了括号，那么它的优先级是最高的。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1+2*3&#x3D;7</span><br><span class="line">1*(2+3)&#x3D;5</span><br><span class="line">1*2*3&#x3D;6</span><br><span class="line">(1+2)*3&#x3D;9</span><br></pre></td></tr></table></figure>
<p>现在小易希望你帮他计算给定3个数a，b，c，在它们中间添加”+”， “*”， “(“， “)”符号，能够获得的最大值。</p>
<p>输入描述:<br>一行三个数a，b，c (1 &lt;= a, b, c &lt;= 10)</p>
<p>输出描述:<br>能够获得的最大值</p>
<p>规律：<br>最小的数小于等于1时，那么最大的结果便是a+b的和再乘以c<br>若最小数大于1，则最大结果必然是三数的积</p>
<h4 id="11-动态规划"><a href="#11-动态规划" class="headerlink" title="11.动态规划"></a>11.动态规划</h4><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;String&gt; Permutation(String str) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        if (str !&#x3D; null &amp;&amp; str.length() &gt; 0) &#123;</span><br><span class="line">            PermutationHelper(str.toCharArray(), 0, res);</span><br><span class="line">            Collections.sort(res);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void PermutationHelper(char[] cs, int i, ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">        if(i &#x3D;&#x3D; cs.length - 1) &#123; &#x2F;&#x2F;解空间的一个叶节点</span><br><span class="line">            list.add(String.valueOf(cs)); &#x2F;&#x2F;找到一个解</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for(int j &#x3D; i; j &lt; cs.length; ++j) &#123;</span><br><span class="line">                if(j &#x3D;&#x3D; i || cs[j] !&#x3D; cs[i]) &#123;</span><br><span class="line">                    SwapUtil.swap(cs, i, j);</span><br><span class="line">                    PermutationHelper(cs, i + 1, list);</span><br><span class="line">                    SwapUtil.swap(cs, i, j); &#x2F;&#x2F;复位</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-不用动态规划简单些"><a href="#12-不用动态规划简单些" class="headerlink" title="12.不用动态规划简单些"></a>12.不用动态规划简单些</h4><p>给出2n(n≤100)个自然数(小于等于30000)。将这2n个自然数排成一列，游戏双方A和B从中取数，只允许从两端取数。A先取，然后双方轮流取数。取完时，谁取得数字总和最大为取胜方；若双方和相等，属B胜。试问A方是否有必胜策略？</p>
<p>输入</p>
<p>共2行，第1行一个整数n；第2行有2*n个自然数。</p>
<p>输出</p>
<p>只有1行，若A有必胜策略，则输出“YES”，否则输出“NO”。</p>
<p>样例输入</p>
<p>4<br>7 9 3 6 4 2 5 3</p>
<p>样例输出</p>
<p>YES</p>
<p>思路</p>
<p>因为第一手先走的人有，可以全奇数项或者全拿偶数项，<br>所以只需要判断一下奇数项的和和偶数项的和是不是相等就可以了。</p>
<h4 id="13-拼多多笔试题"><a href="#13-拼多多笔试题" class="headerlink" title="13.拼多多笔试题"></a>13.拼多多笔试题</h4><p>高程图</p>
<p><a href="https://imgchr.com/i/82I09f" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/20/82I09f.png" alt="82I09f.png"></a></p>
<p>思路：使用机器人邹迷宫寻找递归的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Mian1 &#123;</span><br><span class="line">    private static int[][] array;</span><br><span class="line">    private static int N;</span><br><span class="line">    private static int M;</span><br><span class="line">    private static int first &#x3D; 0;</span><br><span class="line">    private static int left &#x3D; 1;</span><br><span class="line">    private static int right &#x3D; 2;</span><br><span class="line">    private static int up &#x3D; 3;</span><br><span class="line">    private static int down &#x3D; 4;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(&quot;5 5\n1 3 1 2 1\n2 1 3 1 1\n1 4 2 6 1\n1 3 1 3 1\n1 1 5 1 1\n&quot;);</span><br><span class="line">        while(scanner.hasNextLine())&#123;</span><br><span class="line">            String [] strings &#x3D; scanner.nextLine().split(&quot; &quot;);</span><br><span class="line">            N &#x3D; Integer.parseInt(strings[0]);</span><br><span class="line">            M &#x3D; Integer.parseInt(strings[1]);</span><br><span class="line">            array &#x3D; new int[N][M];</span><br><span class="line">            int sumStart &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">                String [] str &#x3D; scanner.nextLine().split(&quot; &quot;);</span><br><span class="line">                for (int j &#x3D; 0; j &lt; M; j++) &#123;</span><br><span class="line">                    array[i][j] &#x3D; Integer.parseInt(str[j]);</span><br><span class="line">                    sumStart +&#x3D; array[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 1; i &lt; N-1; i++) &#123;</span><br><span class="line">                for (int j &#x3D; 1; j &lt; M-1; j++) &#123;</span><br><span class="line">                    array[i][j] &#x3D; findMin(array, i, j,first);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int sumEnd &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; M; j++) &#123;</span><br><span class="line">                    sumEnd +&#x3D; array[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(sumEnd-sumStart);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int findMin(int[][] array, int X, int Y,int direction)&#123;</span><br><span class="line">        int nextX &#x3D; X;</span><br><span class="line">        int nextY &#x3D; Y;</span><br><span class="line">        if (nextX &#x3D;&#x3D;0 || nextX &#x3D;&#x3D;N-1 || nextY&#x3D;&#x3D;0 || nextY&#x3D;&#x3D;M-1)&#123;</span><br><span class="line">            return array[X][Y];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (array[X][Y]&gt;array[X][Y-1] &amp;&amp; array[X][Y]&gt;array[X][Y+1] &amp;&amp; array[X][Y]&gt;array[X-1][Y] &amp;&amp; array[X][Y]&gt;array[X+1][Y])</span><br><span class="line">            return array[X][Y];</span><br><span class="line"></span><br><span class="line">        int nextLeft;</span><br><span class="line">        int nextRight;</span><br><span class="line">        int nextUp;</span><br><span class="line">        int nextDown;</span><br><span class="line">        switch (direction)&#123;</span><br><span class="line">            case 0:</span><br><span class="line">                nextLeft &#x3D; findMin(array,X,Y-1,right);</span><br><span class="line">                nextRight &#x3D; findMin(array,X,Y+1, left);</span><br><span class="line">                nextUp &#x3D; findMin(array,X-1,Y, down);</span><br><span class="line">                nextDown &#x3D; findMin(array,X+1,Y, up);</span><br><span class="line">                return Math.max(Math.min(Math.min(nextRight,nextLeft), Math.min(nextDown, nextUp)),array[X][Y]);</span><br><span class="line">            case 1:</span><br><span class="line">                nextRight &#x3D; findMin(array,X,Y+1, left);</span><br><span class="line">                nextUp &#x3D; findMin(array,X-1,Y, down);</span><br><span class="line">                nextDown &#x3D; findMin(array,X+1,Y, up);</span><br><span class="line">                return Math.max(Math.min(nextRight, Math.min(nextDown, nextUp)),array[X][Y]);</span><br><span class="line">            case 2:</span><br><span class="line">                nextLeft &#x3D; findMin(array,X,Y-1,right);</span><br><span class="line">                nextUp &#x3D; findMin(array,X-1,Y, down);</span><br><span class="line">                nextDown &#x3D; findMin(array,X+1,Y, up);</span><br><span class="line">                return Math.max(Math.min(nextLeft, Math.min(nextDown, nextUp)),array[X][Y]);</span><br><span class="line">            case 3:</span><br><span class="line">                nextLeft &#x3D; findMin(array,X,Y-1,right);</span><br><span class="line">                nextRight &#x3D; findMin(array,X,Y+1, left);</span><br><span class="line">                nextDown &#x3D; findMin(array,X+1,Y, up);</span><br><span class="line">                return Math.max(Math.min(Math.min(nextRight,nextLeft), nextDown),array[X][Y]);</span><br><span class="line">            case 4:</span><br><span class="line">                nextLeft &#x3D; findMin(array,X,Y-1,right);</span><br><span class="line">                nextRight &#x3D; findMin(array,X,Y+1, left);</span><br><span class="line">                nextUp &#x3D; findMin(array,X-1,Y, up);</span><br><span class="line">                return Math.max(Math.min(Math.min(nextRight,nextLeft), nextUp),array[X][Y]);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-利用一个数组实现两个栈"><a href="#14-利用一个数组实现两个栈" class="headerlink" title="14.利用一个数组实现两个栈"></a>14.利用一个数组实现两个栈</h4><p>方法1：利用奇偶位，分别存储栈1和栈2的数据；</p>
<p>方法2：从中间开始将数组一分为二，左边为栈1，右边为栈2；</p>
<p>方法3：栈1从头开始增长，栈2从尾向头进行增长，相遇后，增容；</p>
<p><a href="https://imgchr.com/i/8WS2Rg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/21/8WS2Rg.png" alt="8WS2Rg.png"></a></p>
<h4 id="15-装满箱子"><a href="#15-装满箱子" class="headerlink" title="15.装满箱子"></a>15.装满箱子</h4><p>题目描述</p>
<p>有重量分别为3，5，7公斤的三种货物，和一个载重量为X公斤的箱子（不考虑体积等其它因素，只计算重量）需要向箱子内装满X公斤的货物，要求使用的货物个数尽可能少（三种货物数量无限）</p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入箱子载重量X(1 &lt;&#x3D; X &lt;&#x3D; 10000)，一个整数。</span><br></pre></td></tr></table></figure>
<p>输出描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果无法装满，输出 -1。</span><br><span class="line">如果可以装满，输出使用货物的总个数。</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure>
<p>说明:无法装满</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    static int temp &#x3D; 0;</span><br><span class="line">    public static void dfs(int count, int rest) &#123;</span><br><span class="line">        if (rest &lt; 0) &#123;&#x2F;&#x2F;如果-3，-5或者-7小于0了，说明凑不齐，赶紧溜了</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (rest &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            System.out.println(temp*15+count);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(count + 1, rest - 7);</span><br><span class="line">        dfs(count + 1, rest - 5);</span><br><span class="line">        dfs(count + 1, rest - 3);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; sc.nextInt();</span><br><span class="line">        temp &#x3D; n &#x2F; 105;</span><br><span class="line">        dfs(0, n % 105);</span><br><span class="line">        System.out.println(-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-回文子串"><a href="#16-回文子串" class="headerlink" title="16.回文子串"></a>16.回文子串</h4><p>回文子串的个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">链接：https:&#x2F;&#x2F;www.nowcoder.com&#x2F;questionTerminal&#x2F;003482c395bd41c68082f6adc545a600</span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line">public class Solution14_回文子串 &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 方法一：中心扩散法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static int ans &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf &#x3D; new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        String s &#x3D; bf.readLine();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;考虑两种情况：aba 和 abba</span><br><span class="line">            centerSpread(s, i, i);</span><br><span class="line">            centerSpread(s, i, i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;判断回文串的中心扩散法</span><br><span class="line">    private static void centerSpread(String s, int left, int right) &#123;</span><br><span class="line">        while (left &gt;&#x3D; 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) &#x3D;&#x3D; s.charAt(right)) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;方法二：动态规划</span><br><span class="line">    private static int dp(String s) &#123;</span><br><span class="line">        int n &#x3D; s.length(), ans &#x3D; 0;</span><br><span class="line">        boolean[][] dp &#x3D; new boolean[n][n];</span><br><span class="line">        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            for (int j &#x3D; i; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] &#x3D; (s.charAt(i) &#x3D;&#x3D; s.charAt(j)) &amp;&amp; (j - i &lt;&#x3D; 2 || dp[i + 1][j - 1]);</span><br><span class="line">                if (dp[i][j]) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最长回文子串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">链接：https:&#x2F;&#x2F;www.nowcoder.com&#x2F;questionTerminal&#x2F;003482c395bd41c68082f6adc545a600</span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;1.动态规划</span><br><span class="line">    public static String longestPalindrome(String s) &#123;</span><br><span class="line">        int n &#x3D; s.length();</span><br><span class="line">        if (n &lt; 2) return s;</span><br><span class="line">        int maxLen &#x3D; 1;</span><br><span class="line">        String res &#x3D; s.substring(0, 1);</span><br><span class="line">        boolean[][] dp &#x3D; new boolean[n][n];</span><br><span class="line">        &#x2F;&#x2F;左边界一定小于右边界，因此从右边界开始</span><br><span class="line">        for (int r &#x3D; 1; r &lt; n; r++) &#123; &#x2F;&#x2F;表示右边界</span><br><span class="line">            for (int l &#x3D; 0; l &lt; r; l++) &#123; &#x2F;&#x2F;表示左边界</span><br><span class="line">                &#x2F;&#x2F; 区间应该慢慢放大</span><br><span class="line">                &#x2F;&#x2F; 状态转移方程：如果头尾字符相等并且中间也是回文</span><br><span class="line">                &#x2F;&#x2F; 在头尾字符相等的前提下，如果收缩以后不构成区间（最多只有 1 个元素），直接返回 True 即可</span><br><span class="line">                &#x2F;&#x2F; 否则要继续看收缩以后的区间的回文性</span><br><span class="line">                if (s.charAt(l) &#x3D;&#x3D; s.charAt(r) &amp;&amp; ((r - l) &lt;&#x3D; 2 || dp[l + 1][r - 1])) &#123;</span><br><span class="line">                    dp[l][r] &#x3D; true;</span><br><span class="line">                    if (r - l + 1 &gt; maxLen) &#123;</span><br><span class="line">                        maxLen &#x3D; r - l + 1;</span><br><span class="line">                        res &#x3D; s.substring(l, r + 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最长不连续回文子串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">链接：https:&#x2F;&#x2F;www.nowcoder.com&#x2F;questionTerminal&#x2F;003482c395bd41c68082f6adc545a600</span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line">public int longestPalindrome(String s) &#123;</span><br><span class="line">    int n &#x3D; s.length();</span><br><span class="line">    int[][] dp &#x3D; new int[n][n];&#x2F;&#x2F;dp[l][r]表示l-r中的最长回文串</span><br><span class="line">    for (int r &#x3D; 0; r &lt; n; r++) &#123;</span><br><span class="line">        dp[r][r] &#x3D; 1;</span><br><span class="line">        for (int l &#x3D; r - 1; l &gt;&#x3D; 0; l--) &#123;</span><br><span class="line">            if (s.charAt(l) &#x3D;&#x3D; s.charAt(r)) &#123;</span><br><span class="line">                dp[l][r] &#x3D; dp[l + 1][r - 1] + 2;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[l][r] &#x3D; Math.max(dp[l + 1][r], dp[l][r - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试笔记</category>
      </categories>
      <tags>
        <tag>面试笔记</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>面试基础笔记</title>
    <url>/2020/06/22/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/ox1jqm.png">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">一抹光</div>
</center>


<blockquote>
<p>本科面试笔记</p>
</blockquote>
<a id="more"></a>

<h2 id="一、Java面试笔记"><a href="#一、Java面试笔记" class="headerlink" title="一、Java面试笔记"></a>一、Java面试笔记</h2><h3 id="Java知识点"><a href="#Java知识点" class="headerlink" title="Java知识点"></a>Java知识点</h3><h4 id="1-onCreate和onStart的区别？"><a href="#1-onCreate和onStart的区别？" class="headerlink" title="1.onCreate和onStart的区别？"></a>1.onCreate和onStart的区别？</h4><ul>
<li>onCreate创建与onDestroy销毁；</li>
<li>onStart可见与onStop不可见；</li>
<li>onResume可编辑（即焦点）与onPause；</li>
<li>onCreate只会被调用一次，onStart可以调用多次</li>
</ul>
<h4 id="2-looper-prepare做了什么事情？"><a href="#2-looper-prepare做了什么事情？" class="headerlink" title="2.looper prepare做了什么事情？"></a>2.looper prepare做了什么事情？</h4><ul>
<li>默认情况下一个线程是不存在消息循环（message loop）的</li>
<li>需要调用Looper.prepare()来给线程创建一个消息循环，调用Looper.loop()来使消息循环起作用</li>
</ul>
<h4 id="3-Https原理及流程"><a href="#3-Https原理及流程" class="headerlink" title="3.Https原理及流程"></a>3.Https原理及流程</h4><p>1.客户端向服务器发起HTTPS请求，连接到服务器的443端口</p>
<p>2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</p>
<p>3.服务器将自己的公钥发送给客户端。</p>
<p>4.客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</p>
<p>5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</p>
<p>6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</p>
<p>7.然后服务器将加密后的密文发送给客户端。</p>
<p>8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</p>
<hr>
<p>证书：直观的看，证书包括以下这些内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 证书序列号</span><br><span class="line"></span><br><span class="line">2. 证书过期时间</span><br><span class="line"></span><br><span class="line">3. 站点组织名</span><br><span class="line"></span><br><span class="line">4. 站点DNS主机名</span><br><span class="line"></span><br><span class="line">5. 站点公钥</span><br><span class="line"></span><br><span class="line">6. 证书颁发者名</span><br><span class="line"></span><br><span class="line">7. 证书签名</span><br></pre></td></tr></table></figure>

<p>证书链：证书链的出现，其本质是因为如果证书颁发机构过多的话，不容易识别，防伪和管理，于是形成了少数几家国际权威的证书颁发机构，这些机构非常权威，默认是所有人都可信的，它们成为根证书。但是除了这些机构外，其他的机构也需要被信任，因而，需要这些权威的机构去授信颁发证书，于是就形成了一级证书机构，一级证书机构又可以继续授信下级机构，于是成为树状结构，对于任何一个组织到根证书就是链状结构。</p>
<p>假设你想要成为一个受信任的网站或机构，只需要找你的上级机构去颁发证书给你，颁发时你将自己的公钥，host等信息发送到颁发机构，该机构会将自己的证书附上你的信息，并用自己的私钥签名，做成一张新的证书发给你；而这个上级机构他的证书又是同样的方法由CA颁发的。</p>
<p>  那么，其他人怎么确认你的证书是合法的呢。首先你的证书会在https握手过程中被传递到浏览器，浏览器从你的证书中找到了颁发者，从颁发者的证书（如果你电脑上有的话）又找到了CA的证书（CA证书会在操作系统安装时就安装好，所以每个人电脑上都有根证书），使用CA证书中带的公钥来对颁发者证书做验签，一旦匹配，说明你电脑上的颁发者证书不是伪造的，同理，再用颁发者证书中的公钥去验证你的证书，以此证明你的证书不是伪造的。这样整个链状的验证，从而确保你的证书一定是直接或间接从CA签发的，这样浏览器地址栏会显示一个绿色的盾牌，表示你的网站能通过证书验证</p>
<p>  如果你的电脑上没有颁发者证书（断链）或者你自己本身就是自签名证书（自己做CA，但是要记得，人家电脑上并没有装你的自签名根证书），那么浏览器会报警提示不能验证证书，问你是否还需要继续。</p>
<p>  <a href="https://imgchr.com/i/8WPGOH" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/21/8WPGOH.png" alt="8WPGOH.png"></a></p>
<hr>
<ol>
<li>什么是TCP粘包背景</li>
</ol>
<p>在socket网络编程中，都是端到端通信，由客户端端口+服务端端口+客户端IP+服务端IP+传输协议组成的五元组可以明确的标识一条连接。在TCP的socket编程中，发送端和接收端都有成对的socket。发送端为了将多个发往接收端的包，更加高效的的发给接收端，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。那么这样一来，接收端就必须使用高效科学的拆包机制来分辨这些数据。</p>
<ol start="2">
<li>什么是TCP粘包问题？</li>
</ol>
<p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。</p>
<ol start="3">
<li>造成TCP粘包的原因</li>
</ol>
<p>（1）发送方原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：</span><br><span class="line"></span><br><span class="line">1.只有上一个分组得到确认，才会发送下一个分组收集多个小分组，在一个确认到来时一起发送</span><br><span class="line"></span><br><span class="line">2.agle算法造成了发送方可能会出现粘包问题</span><br></pre></td></tr></table></figure>
<p>（2）接收方原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如</span><br><span class="line">果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>什么时候需要处理粘包现象？</li>
</ol>
<ul>
<li><p>如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象</p>
</li>
<li><p>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了</p>
</li>
</ul>
<ol start="5">
<li>如何处理粘包现象？<br>（1）发送方</li>
</ol>
<p>对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</p>
<p>（2）接收方</p>
<p>接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。</p>
<p>（3）应用层</p>
<p>应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。</p>
<p>解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？</p>
<p>格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。<br>发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。</p>
<ol start="6">
<li>DP会不会产生粘包问题呢？</li>
</ol>
<p>TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。</p>
<p>UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<p>举个例子：有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕。</p>
<hr>
<p>慢启动（Slow Start）</p>
<p>是传输控制协议（TCP）使用的一种阻塞控制机制。慢启动也叫做指数增长期。慢启动是指每次TCP接收窗口收到确认时都会增长。增加的大小就是已确认段的数目。这种情况一直保持到要么没有收到一些段，要么窗口大小到达预先定义的阈值。如果发生丢失事件，TCP就认为这是网络阻塞，就会采取措施减轻网络拥挤。一旦发生丢失事件或者到达阈值，TCP就会进入线性增长阶段。这时，每经过一个RTT窗口增长一个段</p>
<h4 id="4-HashMap原理"><a href="#4-HashMap原理" class="headerlink" title="4.HashMap原理"></a>4.HashMap原理</h4><p>哈希概念</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。</span><br></pre></td></tr></table></figure>
<p>哈希存储中的碰撞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对不同的关键字可能得到同一哈希值，即key1≠key2，而f(key1)&#x3D;f(key2)，这种现象称碰撞</span><br></pre></td></tr></table></figure>
<p>碰撞解决方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开放定址法：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</span><br><span class="line"></span><br><span class="line">链地址:HashMap中同样哈希值的位置以一串链表存储起来数据</span><br></pre></td></tr></table></figure>

<p>HashMap的存储结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组、链表、红黑树</span><br></pre></td></tr></table></figure>

<p>HashMap原理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基于hashing原理，通过put()和get()方法储存和获取对象。put()方法: 它调用键对象的hashCode()方法来计算hashcode值，</span><br><span class="line">系统根据hashcode值决定该元素在bucket位置。如果两个对象key的hashcode返回值相同，那他们的存储位置相同，如果这两个Entry的key通过equals比较返回t</span><br><span class="line">rue，新添加Entry的value将覆盖集合中原有Entry的value，但key不会覆盖；如果这两个Entry的key通过equals比较返回false，新添加的Entry将与集合中原有Entry形成Entry链，而且新添加Entry位于Entry链的头部。put源码如下:</span><br></pre></td></tr></table></figure>
<p>HashMap和Hashtable的区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap和Hashtable都实现了Map接口，主要的区别有：线程安全性，同步(synchronization)，以及速度。HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)</span><br></pre></td></tr></table></figure>
<p>HashMap和HashSet的区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashSet实现了Set接口，它不允许集合中有重复的值，HashMap实现了Map接口，Map接口对键值对进行映射。</span><br><span class="line">HashSet扩展了HashMap,所以底层还是用到map存储，存储实现同map一致，HashMap储存键值，HashSet存储对象。</span><br></pre></td></tr></table></figure>

<p>重写equals不重写hashcode会出现什么问题</p>
<p>在存储散列集合时(如Set类)，如果原对象.equals(新对象)，但没有对hashCode重写，即两个对象拥有不同的hashcode，则在集合中将会存储两个值相同的对象，从而导致混淆。因此在重写equals方法时，必须重写hashcode方法。</p>
<h4 id="5-gc的几种算法"><a href="#5-gc的几种算法" class="headerlink" title="5.gc的几种算法"></a>5.gc的几种算法</h4><p>引用计数法、标记-清除法、复制算法、标记-清除算法</p>
<h4 id="6-ArrayList-和-LinkedList-区别"><a href="#6-ArrayList-和-LinkedList-区别" class="headerlink" title="6.ArrayList 和 LinkedList 区别"></a>6.ArrayList 和 LinkedList 区别</h4><p>ArrayList是基于数组实现的，LinkedList是基于双链表实现的</p>
<h4 id="7-gc-root-的对象有哪些？"><a href="#7-gc-root-的对象有哪些？" class="headerlink" title="7.gc root 的对象有哪些？"></a>7.gc root 的对象有哪些？</h4><p>1 、 虚拟机栈（栈帧中的本地变量表）中引用的对象。</p>
<p>2、 本地方法栈中JNI（即一般说的native方法）引用的对象。</p>
<p>3、 方法区中的静态变量和常量引用的对象。</p>
<h4 id="8-java-为什么采用可达性分析不用引用计数器"><a href="#8-java-为什么采用可达性分析不用引用计数器" class="headerlink" title="8.java 为什么采用可达性分析不用引用计数器"></a>8.java 为什么采用可达性分析不用引用计数器</h4><p>1 jdk从1.2开始增加了多种引用方式：软引用、弱引用、虚引用，且在不同引用情况下程序应进行不同的操作。如果我们只采用一个引用计数法来计数无法准确的区分这么多种引用的情况。</p>
<p>2 如果一个对象A持有对象B，而对象B也持有一个对象A，那发生了类似操作系统中死锁的循环持有，这种情况下A与B的counter恒大于1，会使得GC永远无法回收这两个对象。</p>
<h4 id="9-线程间通信的几种实现方式"><a href="#9-线程间通信的几种实现方式" class="headerlink" title="9.线程间通信的几种实现方式"></a>9.线程间通信的几种实现方式</h4><p>1.使用 volatile 关键字。<br>基于 volatile 关键字来实现线程间相互通信是使用共享内存的思想，大致意思就是多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。这也是最简单的一种实现方式</p>
<p>2.使用Object类的wait() 和 notify() 方法。<br>众所周知，Object类提供了线程间通信的方法：wait()、notify()、notifyaAl()，它们是多线程通信的基础，而这种实现方式的思想自然是线程间通信。</p>
<p>3.使用JUC工具类 CountDownLatch。<br>jdk1.5之后在java.util.concurrent包下提供了很多并发编程相关的工具类，简化了我们的并发编程代码的书写，<strong><em>CountDownLatch</em></strong>基于AQS框架，相当于也是维护了一个线程间共享变量state</p>
<h4 id="10-synchronized和volatile的区别"><a href="#10-synchronized和volatile的区别" class="headerlink" title="10.synchronized和volatile的区别"></a>10.synchronized和volatile的区别</h4><p>1.volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；</p>
<p>2.从内存可见性角度，volatile读相当于加锁，volatile写相当于解锁；</p>
<p>3.synchronized既能够保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。</p>
<h4 id="11-Java对象的4种引用方式"><a href="#11-Java对象的4种引用方式" class="headerlink" title="11.Java对象的4种引用方式"></a>11.Java对象的4种引用方式</h4><p>1.强引用。<br>我们平日里面的用到的new了一个对象就是强引用，例如 Object obj = new Object();当JVM的内存空间不足时，宁愿抛出OutOfMemoryError使得程序异常终止也不愿意回收具有强引用的存活着的对象！</p>
<p>2.软引用。<br>当JVM认为内存空间不足时，就回去试图回收软引用指向的对象，也就是说在JVM抛出OutOfMemoryError之前，会去清理软引用对象。软引用可以与引用队列(ReferenceQueue)联合使用。</p>
<p>3.弱引用。在GC的时候，不管内存空间足不足都会回收这个对象，同样也可以配合ReferenceQueue 使用，也同样适用于内存敏感的缓存。ThreadLocal中的key就用到了弱引用。</p>
<p>4.幻象引用。虚引用仅仅只是提供了一种确保对象被finalize以后来做某些事情的机制。比如说这个对象被回收之后发一个系统通知啊啥的。虚引用是必须配合ReferenceQueue 使用的，具体使用方法和上面提到软引用的一样。主要用来跟踪对象被垃圾回收的活动。</p>
<h4 id="12-final、finally、finalize的区别"><a href="#12-final、finally、finalize的区别" class="headerlink" title="12.final、finally、finalize的区别"></a>12.final、finally、finalize的区别</h4><p>final用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。</p>
<p>finally是异常处理语句结构的一部分，表示总是执行。</p>
<p>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。</p>
<h4 id="13-finally什么时候使用"><a href="#13-finally什么时候使用" class="headerlink" title="13.finally什么时候使用"></a>13.finally什么时候使用</h4><p>finally可以没有，也可以只有一个。无论有没有发生异常，它总会在这个异常处理结构的最后运行。即使你在try块内用return返回了，在返回前，finally总是要执行，这以便让你有机会能够在异常处理最后做一些清理工作。如关闭数据库连接等等。 </p>
<h4 id="14-UDP如何实现可靠传输"><a href="#14-UDP如何实现可靠传输" class="headerlink" title="14.UDP如何实现可靠传输"></a>14.UDP如何实现可靠传输</h4><p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<p>1、添加seq/ack机制，确保数据发送到对端</p>
<p>2、添加发送和接收缓冲区，主要是用户超时重传。</p>
<p>3、添加超时重传机制。</p>
<p>详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>
<h4 id="15-怎么监控卡顿"><a href="#15-怎么监控卡顿" class="headerlink" title="15.怎么监控卡顿?"></a>15.怎么监控卡顿?</h4><p>ANR-WatchDog是参考Android WatchDog机制（com.android.server.WatchDog.java）起个单独线程向主线程发送一个变量+1操作，自我休眠自定义ANR的阈值，休眠过后判断变量是否+1完成，如果未完成则告警。</p>
<p>FileObserve<br>有ANR的流程就可以知道/data/anr文件夹的变化代表着ANR的发生，AMS在dumpStackTrace方法中给了我们一些提示。</p>
<h4 id="16-java单例模式大全"><a href="#16-java单例模式大全" class="headerlink" title="16.java单例模式大全"></a>16.java单例模式大全</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Writer &#123;</span><br><span class="line"></span><br><span class="line">        private Writer()&#123;&#125;</span><br><span class="line">        private static volatile Writer writer;</span><br><span class="line">        public static Writer getInstance()&#123;</span><br><span class="line">            if(wrter &#x3D;&#x3D; null)&#123;</span><br><span class="line">                synchronized(Writer.class)&#123;</span><br><span class="line">                    if(wrter &#x3D;&#x3D; null)&#123;</span><br><span class="line">                        writer &#x3D; new Writer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return writer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-Java内存泄漏"><a href="#17-Java内存泄漏" class="headerlink" title="17.Java内存泄漏"></a>17.Java内存泄漏</h4><p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p>
<p>在C ++ 中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。</p>
<h4 id="18-JVM中的内存是怎么划分的？"><a href="#18-JVM中的内存是怎么划分的？" class="headerlink" title="18.JVM中的内存是怎么划分的？"></a>18.JVM中的内存是怎么划分的？</h4><p>答：JVM中的内存主要划分为5个区域，即方法区，堆内存，程序计数器，虚拟机栈以及本地方法栈。下边是Java虚拟机运行时数据区示意图</p>
<p>方法区：方法区是一个线程之间共享的区域。常量，静态变量以及JIT编译后的代码都在方法区。主要用于存储已被虚拟机加载的类信息，也可以称为“永久代”，垃圾回收效果一般，通过-XX：MaxPermSize控制上限。</p>
<p>堆内存：堆内存是垃圾回收的主要场所，也是线程之间共享的区域，主要用来存储创建的对象实例，通过-Xmx 和-Xms 可以控制大小。</p>
<p>虚拟机栈（栈内存）：栈内存中主要保存局部变量、基本数据类型变量以及堆内存中某个对象的引用变量。每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表，操作数栈，动态链接，方法出口等信息。栈中的栈帧随着方法的进入和退出有条不紊的执行着出栈和入栈的操作。</p>
<p>程序计数器： 程序计数器是当前线程执行的字节码的位置指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，是内存区域中唯一一个在虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<p>本地方法栈： 主要是为JVM提供使用native 方法的服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">栈就像装数据的桶或箱子</span><br><span class="line"> </span><br><span class="line"> 我们先从大家比较熟悉的栈说起吧，它是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。这就如同我们要取出放在箱子里面底下的东西（放入的比较早的物体），我</span><br><span class="line"> 们首先要移开压在它上面的物体（放入的比较晚的物体）。</span><br><span class="line"></span><br><span class="line">堆像一棵倒过来的树</span><br><span class="line"></span><br><span class="line">而堆就不同了，堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。</span><br><span class="line">由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</span><br></pre></td></tr></table></figure>
<h4 id="19-对象创建过程中的内存分配吗？"><a href="#19-对象创建过程中的内存分配吗？" class="headerlink" title="19.对象创建过程中的内存分配吗？"></a>19.对象创建过程中的内存分配吗？</h4><p>1.1new指令</p>
<p>虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那么须先执行相应的类加载过程。</p>
<p>1.2分配内存</p>
<p>接下来虚拟机将为新生代对象分配内存。对象所需的内存的大小在类加载完成后便可完全确定。分配方式有“指针碰撞（Bump the Pointer）”和“空闲列表（Free List）”两种方式，具体由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p>1.3初始化</p>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>1.4对象的初始设置</p>
<p>接下来虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如对否启用偏向锁等，对象头会有不同的设置方式。</p>
<p>1.5<init>方法</init></p>
<p>在上面的工作都完成了之后，从虚拟机的角度看，一个新的对象已经产生了，但是从Java程序的角度看，对象创建才刚刚开始—<init>方法还没有执行，所有的字段都还为零。所以，一般来说，执行new指令后悔接着执行init方法，把对象按照程序员的意愿进行初始化（应该是将构造函数中的参数赋值给对象的字段），这样一个真正可用的对象才算完全产生出来。</init></p>
<p>2.1对象头</p>
<p>HotSpot虚拟机的对象头包含两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p>
<p>对象的另一部分类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例（并不是所有的虚拟机实现都必须在对象数据上保留类型指针，也就是说，查找对象的元数据信息并不一定要经过对象本身）。</p>
<p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。</p>
<p>元数据：描述数据的数据。对数据及信息资源的描述信息。在Java中，元数据大多表示为注解。</p>
<p>2.2实例数据</p>
<p>实例数据部分是对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容，无论从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会虚拟机默认的分配策略参数和字段在Java源码中定义的顺序影响（相同宽度的字段总是被分配到一起）。</p>
<p>2.3对齐填充</p>
<p>对齐填充部分并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，也就是说，对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h4 id="20-JVM如何判定一个对象是否应该被回收？"><a href="#20-JVM如何判定一个对象是否应该被回收？" class="headerlink" title="20.JVM如何判定一个对象是否应该被回收？"></a>20.JVM如何判定一个对象是否应该被回收？</h4><p>答： 判断一个对象是否应该被回收，主要是看其是否还有引用。判断对象是否存在引用关系的方法包括引用计数法以及root根搜索方法。</p>
<p>引用计数法：<br>是一种比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只需要收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</p>
<p>root根搜索方法：<br>root搜索方法的基本思路就是通过一系列可以做为root的对象作为起始点，从这些节点开始向下搜索。当一个对象到root节点没有任何引用链接时，则证明此对象是可以被回收的。以下对象会被认为是root对象：</p>
<p>栈内存中引用的对象方法区中静态引用和常量引用指向的对象<br>被启动类（bootstrap加载器）加载的类和创建的对象<br>Native方法中JNI引用的对象。</p>
<h4 id="21-JVM垃圾回收算法有哪些？"><a href="#21-JVM垃圾回收算法有哪些？" class="headerlink" title="21.JVM垃圾回收算法有哪些？"></a>21.JVM垃圾回收算法有哪些？</h4><p>答：HotSpot 虚拟机采用了root根搜索方法来进行内存回收，常见的回收算法有标记-清除算法，复制算法和标记整理算法。</p>
<p>标记-清除算法（Mark-Sweep）：</p>
<p>标记-清除算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，并且会产生内存碎片。</p>
<p>复制算法：</p>
<p>复制算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。复制算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</p>
<p>标记-整理算法：</p>
<p>标记-整理算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p>
<h4 id="22-JVM中的垃圾收集器CMS收集器"><a href="#22-JVM中的垃圾收集器CMS收集器" class="headerlink" title="22.JVM中的垃圾收集器CMS收集器"></a>22.JVM中的垃圾收集器CMS收集器</h4><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于标记-清除算法实现的，是一种老年代收集器，通常与ParNew一起使用。</p>
<p>CMS的垃圾收集过程分为4步：</p>
<ul>
<li>初始标记：需要“Stop the World”，初始标记仅仅只是标记一下GC Root能直接关联到的对象，速度很快。</li>
<li>并发标记：是主要标记过程，这个标记过程是和用户线程并发执行的。</li>
<li>重新标记：需要“Stop the World”，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（停顿时间比初始标记长，但比并发标记短得多）。</li>
<li>并发清除：和用户线程并发执行的，基于标记结果来清理对象。</li>
</ul>
<h4 id="23-覆盖（-Override）代码"><a href="#23-覆盖（-Override）代码" class="headerlink" title="23.覆盖（@Override）代码"></a>23.覆盖（@Override）代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OverrideTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Son().say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Parent &#123;</span><br><span class="line">    public void say()&#123;</span><br><span class="line">        System.out.println(&quot;我是父类中的say方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son extends Parent &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void say()&#123;</span><br><span class="line">        System.out.println(&quot;我是子类中的say方法，我覆盖了父类的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="24-重载代码"><a href="#24-重载代码" class="headerlink" title="24.重载代码"></a>24.重载代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OverLoadTest &#123;</span><br><span class="line"> </span><br><span class="line">    public void method1(String name, int age)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 两个方法的参数顺序不同，可以构成方法的重载</span><br><span class="line">    public void method1(int age, String name)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------</span><br><span class="line">    public void method2(String name)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 两个方法的参数类型不同，可以构成方法的重载</span><br><span class="line">    public void method2(int age)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------</span><br><span class="line">    public void method3(String name)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 两个方法的参数个数不同，可以构成方法的重载</span><br><span class="line">    public void method3(int age, int num)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-Java中的值传递和引用传递可以解释下吗？"><a href="#25-Java中的值传递和引用传递可以解释下吗？" class="headerlink" title="25.Java中的值传递和引用传递可以解释下吗？"></a>25.Java中的值传递和引用传递可以解释下吗？</h4><p>答：值传递和引用传递的解释可以概括如下。</p>
<p>值传递，意味着传递了对象的一个副本，即使副本被改变，也不会影响源对象。</p>
<p>引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象的改变会反映到所有的对象上。</p>
<h4 id="26-哪些对象可以被看做是-GC-Roots-呢？"><a href="#26-哪些对象可以被看做是-GC-Roots-呢？" class="headerlink" title="26.哪些对象可以被看做是 GC Roots 呢？"></a>26.哪些对象可以被看做是 GC Roots 呢？</h4><p>1）虚拟机栈（栈帧中的本地变量表）中引用的对象；</p>
<p>2）方法区中的类静态属性引用的对象，常量引用的对象； </p>
<p>3）本地方法栈中 JNI(Native 方法）引用的对象</p>
<h4 id="27-说下-java-中的线程创建方式，线程池的工作原理。"><a href="#27-说下-java-中的线程创建方式，线程池的工作原理。" class="headerlink" title="27.说下 java 中的线程创建方式，线程池的工作原理。"></a>27.说下 java 中的线程创建方式，线程池的工作原理。</h4><p>java 中有三种创建线程的方式，或者说四种 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.继承 Thread 类实现多线程 </span><br><span class="line">2.实现 Runnable 接口 </span><br><span class="line">3.实现 Callable 接口 </span><br><span class="line">4.通过线程池</span><br></pre></td></tr></table></figure>
<p>线程池的工作原理：</p>
<p>1）当提交一个新任务到线程池时，线程池判断corePoolSize线程池是否都在执行任务，如果有空闲线程，则创建一个新的工作线程来执行任务，直到当前线程数等于corePoolSize；</p>
<p>2）如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；</p>
<p>3）如果阻塞队列满了，那就创建新的线程执行当前任务，直到线程池中的线程数达到maxPoolSize，这时再有任务来，由饱和策略来处理提交的任务</p>
<h4 id="28-java中存在三种调用机制"><a href="#28-java中存在三种调用机制" class="headerlink" title="28.java中存在三种调用机制"></a>28.java中存在三种调用机制</h4><p>1：同步调用：一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用</p>
<p>2：回调：一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；</p>
<p>3：异步调用：一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）</p>
<p>具体说来：就是A类中调用B类中的某个方法C，然后B类中反过来调用A类中的方法D，D这个方法就叫回调方法，</p>
<p>举例：老师平时学生布置任务后不可能一直等待和监督学生完成，老师通常会告诉学生，任务完成后给他打个电话或者发个信息，那么学生给老师返回结果的过程需要老师信息，这就是一个回调的过程。</p>
<h4 id="29-新生代和老年代"><a href="#29-新生代和老年代" class="headerlink" title="29.新生代和老年代"></a>29.新生代和老年代</h4><p>新生代</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java新生代垃圾回收运用的是复制算法。</span><br><span class="line"></span><br><span class="line">java新生代分为两部分：Eden区和两个Survivor区，它们的比例是8:1:1，两个Survivor区又分为 fromSurvivor区和to Survivor区，其中新生代每次进行Minor GC（新生代的GC）之前，to Survivor区一定是空的。</span><br><span class="line"></span><br><span class="line">每当新创建一个对象而此时Eden区内存不足的时候，就会进行Minor GC，然后Eden区仍然活着的对象会复制到to Survivor区，而from Survivor区中年龄超过阀值的对象会保存到老年代中，没有超过阀值的对象会保存到to Survivor区中，然后to Survivor区和from Survivor区互换位置，保证每次都有一块Survivor区是空闲的。</span><br><span class="line"></span><br><span class="line">在Survivor区中的对象每经过一次Minor GC年龄就会加1，默认年龄阀值为15，这个阀值可自行设置，设置方法请自行百度。</span><br><span class="line"></span><br><span class="line">当Survivor区中年龄相同的对象加起来超过Survivor区一半内存大小的时候，Survivor区就会提前把大于等于此年龄的对象复制到老年代中。</span><br><span class="line"></span><br><span class="line">某些大对象（内存大）创建的时候不经过新生代，而是直接放在老年代中，原因是减少每次复制大对象时浪费是时间，所以尽可能减少大对象的创建。</span><br><span class="line"></span><br><span class="line">超大的对象直接不经过新生代就进入老年代</span><br></pre></td></tr></table></figure>
<p>老年代</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在进行Minor GC之前，JVM会先检查老年代最大可用连续空间是否大于新生代历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，否则就进行Full GC（全局GC）。</span><br><span class="line">老年代运用标记-整理算法回收垃圾，将存活的对象向一端移动，清楚边界以外的部分。</span><br></pre></td></tr></table></figure>

<p>永久代</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你可以认为是存放一些类的信息，在上一个章节我们知道我们生成的.class就是存放在这个区域的。一般情况下，我们对于jvm调优都是对新生代和老年代进行调优。一般而言永久代保持默认配置就可以了。</span><br></pre></td></tr></table></figure>

<h4 id="30-线程死锁：（重点掌握）"><a href="#30-线程死锁：（重点掌握）" class="headerlink" title="30.线程死锁：（重点掌握）"></a>30.线程死锁：（重点掌握）</h4><p>死锁是最常见的一种线程活性故障。死锁的起因是多个线程之间相互等待对方而被永远暂停（处于非Runnable）。死锁的产生必须满足如下四个必要条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">资源互斥：一个资源每次只能被一个线程使用</span><br><span class="line"></span><br><span class="line">请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放</span><br><span class="line"></span><br><span class="line">不剥夺条件：线程已经获得的资源，在未使用完之前，不能强行剥夺</span><br><span class="line"></span><br><span class="line">循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系</span><br></pre></td></tr></table></figure>
<p>如何避免死锁的发生？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">粗锁法：使用一个粒度粗的锁来消除“请求与保持条件”，缺点是会明显降低程序的并发性能并且会导致资源的浪费。</span><br><span class="line"></span><br><span class="line">锁排序法：（必须回答出来的点）</span><br><span class="line">指定获取锁的顺序，比如某个线程只有获得A锁和B锁，才能对某资源进行操作，在多线程条件下，如何避免死锁？</span><br><span class="line"></span><br><span class="line">通过指定锁的获取顺序，比如规定，只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可以避免死锁。这通常被认为是解决死锁很好的一种方法。</span><br><span class="line"></span><br><span class="line">使用显式锁中的ReentrantLock.try(long,TimeUnit)来申请锁</span><br></pre></td></tr></table></figure>
<h4 id="31-Java单例写法"><a href="#31-Java单例写法" class="headerlink" title="31.Java单例写法"></a>31.Java单例写法</h4><p>单线程环境懒汉式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *懒汉式的单例模式   </span><br><span class="line"> * @author ywq</span><br><span class="line">*&#x2F;</span><br><span class="line">class Single&#123; </span><br><span class="line">    private static Single s &#x3D; null; </span><br><span class="line">    private Single()&#123;&#125; </span><br><span class="line">    public static  Single getInstance()&#123; </span><br><span class="line">        if(null&#x3D;&#x3D;s) </span><br><span class="line">           s &#x3D; new Single(); </span><br><span class="line">        return s; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized内部锁来解决多线程环境下的线程安全问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 多线程环境下的懒汉式单例模式(DCL，双检锁实现)</span><br><span class="line"> * @author ywq</span><br><span class="line">*&#x2F;</span><br><span class="line">class Single&#123; </span><br><span class="line">    private static Single s &#x3D; null; </span><br><span class="line">    private Single()&#123;&#125; </span><br><span class="line"> </span><br><span class="line">    public static  Single getInstance()&#123;</span><br><span class="line">        if(null&#x3D;&#x3D;s)&#123;</span><br><span class="line">            synchronized(Single.class)&#123;</span><br><span class="line">                if(null&#x3D;&#x3D;s) </span><br><span class="line">                    s &#x3D; new Single(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Instance instance = new Instance()都发生了啥？</p>
<p>具体步骤如下三步所示：</p>
<p>在堆内存上分配对象的内存空间</p>
<p>在堆内存上初始化对象</p>
<p>设置instance指向刚分配的内存地址</p>
<p>第二步和第三步可能会发生重排序，导致引用型变量指向了一个不为null但是也不完整的对象。所以，在多线程下上述的代码会返回一个不完整的对象。根据前面章节所学的内容，我们需要加入一个volatile关键字来禁止指令重排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 多线程环境下的懒汉式单例模式(DCL，双检锁+volatile实现)</span><br><span class="line"> * 加入了volatile变量来禁止指令重排序  </span><br><span class="line"> * @author ywq</span><br><span class="line">*&#x2F;</span><br><span class="line">class Single&#123; </span><br><span class="line">    private static volatile Single s &#x3D; null; </span><br><span class="line">    private Single()&#123;&#125; </span><br><span class="line"> </span><br><span class="line">    public static  Single getInstance()&#123;</span><br><span class="line">        if(null&#x3D;&#x3D;s)&#123;</span><br><span class="line">            synchronized(Single.class)&#123;</span><br><span class="line">                if(null&#x3D;&#x3D;s) </span><br><span class="line">                    s &#x3D; new Single(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>单例模式的优点：单例模式保证了一个类在一个系统中有且只有一个对象实例，减少了系统内存和性能的开销。</p>
<h4 id="32-Thread类的常用方法"><a href="#32-Thread类的常用方法" class="headerlink" title="32.Thread类的常用方法"></a>32.Thread类的常用方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String getName()　　返回该线程的名称。</span><br><span class="line"></span><br><span class="line">void setName(String name)　　改变线程名称，使之与参数 name 相同。</span><br><span class="line"></span><br><span class="line">int getPriority() 　　返回线程的优先级。</span><br><span class="line"></span><br><span class="line">void setPriority(int newPriority) 　　更改线程的优先级。</span><br><span class="line"></span><br><span class="line">boolean isDaemon() 　　测试该线程是否为守护线程。</span><br><span class="line"></span><br><span class="line">void setDaemon(boolean on)　　将该线程标记为守护线程或用户线程。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">static void sleep(long millis)</span><br><span class="line"></span><br><span class="line">void interrupt()　　中断线程。</span><br><span class="line"></span><br><span class="line">static void yield()　　暂停当前正在执行的线程对象，并执行其他线程。</span><br><span class="line"></span><br><span class="line">void join()　　等待该线程终止。</span><br><span class="line"></span><br><span class="line">void run()</span><br><span class="line"></span><br><span class="line">void start()  </span><br><span class="line"></span><br><span class="line">从Object类继承来的方法　　void notify()         void wait()</span><br></pre></td></tr></table></figure>

<h4 id="33-线程交互：互斥与同步"><a href="#33-线程交互：互斥与同步" class="headerlink" title="33. 线程交互：互斥与同步"></a>33. 线程交互：互斥与同步</h4><p>互斥：同一时间只能有一个线程去对临界区进行操作，通过synchronized（intrinsic lock）实现，只有获得lock的线程才能进入synchronized声明的代码块；</p>
<p>同步：线程之间的通信机制；当某些条件不具备时线程处于等待状态，条件满足，需要发出消息来唤醒所有线程；通过wait（）/notify（）/notifyAll（）实现。</p>
<p>Wait Set：可以理解为线程休息室；</p>
<p>　　共享资源/数据又被称为临界区（Critical Section），当有一个线程想要访问共享资源的时候，首先，他需要获得锁，获得锁后进入我们的临界区进行操作，操作过程中，如果发现某些情况不被满足，将调用锁对象上的wait()方法，此时，该线程释放掉锁资源，然后进入到锁对象上的Wait Set，由于这个线程释放掉了我们的锁资源，使得其他线程可以来竞争多资源，所以其他线程获得锁并进入临界区，同时在锁对象上的wait set中有多条线程在等待条件的满足，当我们的当前运行线程执行完某些操作需要通知等待的线程时，调用notify方法将会唤醒所资源所持有的等待区域中的一条线程，是这条线程有机会去进行竞争CPU资源；或者调用notifyAll方法，这时会使wait set中的所有线程被唤醒，从而使得它们有机会在当前线程离开临界资源释放锁之后去竞争临界资源的锁对象。</p>
<h4 id="34-守护线程"><a href="#34-守护线程" class="headerlink" title="34.守护线程"></a>34.守护线程</h4><p>Java线程有两类：</p>
<p>用户线程：运行在前台，执行具体的任务；程序的主线程，连接网络的子线程等都是用户线程；</p>
<p>守护线程：运行在后台，为其他前台线程服务；　</p>
<p>守护线程的特点：一旦所有用户线程都结束运行，守护线程会随JVm一起结束工作；</p>
<p>守护线程的应用：数据库连接池中的监测线程；JVM虚拟机启动后的监测线程，最常见的是垃圾回收线程；<br>　　守护线程的设置：通过调用Thread类的setDaemon(true)方法来设置当前的线程为守护线程；</p>
<p>注意：setDaemon（true）必须在start（）方法之前调用，否则会抛出IllegalThreadStateException异常；守护线程中产生的新线程也是守护线程；不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑；</p>
<h4 id="35-synchronized的使用"><a href="#35-synchronized的使用" class="headerlink" title="35.synchronized的使用"></a>35.synchronized的使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class T &#123;</span><br><span class="line">    private static int count &#x3D; 10;</span><br><span class="line">    public synchronized static void m()&#123; &#x2F;&#x2F;这里等同于synchronized(packagename.T.class)</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;count&#x3D;&quot;+count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void nm()&#123;</span><br><span class="line">        synchronized (T.class)&#123; &#x2F;&#x2F;是class类的对象</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的运行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread0count&#x3D;9</span><br><span class="line">Thread2count&#x3D;8</span><br><span class="line">Thread1count&#x3D;7</span><br><span class="line">Thread3count&#x3D;6</span><br><span class="line">Thread4count&#x3D;5</span><br></pre></td></tr></table></figure>
<p>不加synchronized的运行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread0count&#x3D;9</span><br><span class="line">Thread2count&#x3D;7</span><br><span class="line">Thread1count&#x3D;8</span><br><span class="line">Thread3count&#x3D;6</span><br><span class="line">Thread4count&#x3D;5</span><br></pre></td></tr></table></figure>

<h4 id="36-同步方法和非同步方法是否可以同时调用？–-gt-可以"><a href="#36-同步方法和非同步方法是否可以同时调用？–-gt-可以" class="headerlink" title="36.同步方法和非同步方法是否可以同时调用？–&gt;可以"></a>36.同步方法和非同步方法是否可以同时调用？–&gt;可以</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class T &#123;</span><br><span class="line">    public synchronized void m1()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;m1 start...&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;m1 end...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void m2()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;m2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        T t &#x3D; new T();</span><br><span class="line">        new Thread(t::m1,&quot;t1&quot;).start();</span><br><span class="line">        new Thread(t::m2,&quot;t2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1m1 start...</span><br><span class="line">t2m2</span><br><span class="line">t1m1 end...</span><br></pre></td></tr></table></figure>
<p>　原子变量最主要的一个特点是所有的操作都是原子的，synchronized关键字也能做到对变量的原子操作，但是成本相对较高，需要获取锁对象，释放锁对象，如果不能获取到锁，还需要阻塞在阻塞队列上进行等待</p>
<h4 id="37-对业务写方法加锁，对业务读方法不加锁，容易产生脏读"><a href="#37-对业务写方法加锁，对业务读方法不加锁，容易产生脏读" class="headerlink" title="37.对业务写方法加锁，对业务读方法不加锁，容易产生脏读"></a>37.对业务写方法加锁，对业务读方法不加锁，容易产生脏读</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">    String name;</span><br><span class="line">    double balance;</span><br><span class="line">    public synchronized void set(String name,double balance)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        try&#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        this.balance &#x3D; balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getBalance(String name)&#123;</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Account a &#x3D; new Account();</span><br><span class="line">        new Thread(()-&gt;a.set(&quot;zhangsan&quot;,100.0)).start();</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(a.getBalance(&quot;zhangsan&quot;));&#x2F;&#x2F;0.0</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(a.getBalance(&quot;zhangsan&quot;));&#x2F;&#x2F;100.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="38-在继承中，子类重写的同步方法可以调用父类的同步方法"><a href="#38-在继承中，子类重写的同步方法可以调用父类的同步方法" class="headerlink" title="38.在继承中，子类重写的同步方法可以调用父类的同步方法"></a>38.在继承中，子类重写的同步方法可以调用父类的同步方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class T &#123;</span><br><span class="line">    synchronized void m()&#123;</span><br><span class="line">        System.out.println(&quot;m start&quot;);</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;m end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new TT().m();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class TT extends T&#123;</span><br><span class="line">    synchronized void m()&#123;</span><br><span class="line">        System.out.println(&quot;child m start&quot;);</span><br><span class="line">        super.m();&#x2F;&#x2F;可以调用父类的同步方法</span><br><span class="line">        System.out.println(&quot;child m end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="39-出现异常，默认情况下锁会被释放"><a href="#39-出现异常，默认情况下锁会被释放" class="headerlink" title="39.出现异常，默认情况下锁会被释放"></a>39.出现异常，默认情况下锁会被释放</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 程序在执行过程中如果出现异常，默认情况下锁会被释放</span><br><span class="line"> * 所以在执行并发处理的过程中，有异常要小心，不然可能会发生不一致的情况；</span><br><span class="line"> * 比如，在一个web app处理过程中，多个servlet线程共同访问一个资源</span><br><span class="line"> * 这是如果异常处理不合适，在第一个线程中抛出异常，其他线程就会进入同步代码区，</span><br><span class="line"> * 有可能会访问到异常产生时的数据（处理了一半的数据），</span><br><span class="line"> * 因此要非常小心处理同步业务逻辑中的异常</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">public class T &#123;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    synchronized void m()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;start&quot;);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;count&quot;+count);</span><br><span class="line">            try&#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if(count&#x3D;&#x3D;5)&#123;</span><br><span class="line">                int i&#x3D;1&#x2F;0;&#x2F;&#x2F;此处抛出异常，锁被释放，要想不被释放，可以在这里进行catch，然后让循环继续</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        T t &#x3D; new T();</span><br><span class="line">        Runnable r &#x3D; new Runnable()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r,&quot;t1&quot;).start();</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread(r,&quot;t2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="40-volatile的可见性"><a href="#40-volatile的可见性" class="headerlink" title="40.volatile的可见性"></a>40.volatile的可见性</h4><p> volatile 关键字，使一个变量在多个线程间可见，A B 线程都用到一个变量，java默认是A线程中保存一份copy，这样如果B线程修改了该变量，则A未必知道，使用volatile关键字，会让所有线程都会读到变量的修改值；</p>
<p>原理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一：使用volatile关键字会强制将修改的值立即写入主存；</span><br><span class="line">第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</span><br><span class="line">第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</span><br></pre></td></tr></table></figure>

<p>volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说 volatile不能代替synchronized；</p>
<p>volatile 只保证了原子性，而synchronized既保证可见性有保证原子性，但是synchronized太重了；</p>
<h4 id="41-面试题：实现一个容器，提供两个方法add，size，线程1添加10个元素到容器，线程2监控元素的个数，当个数为5时，线程2提示并结束"><a href="#41-面试题：实现一个容器，提供两个方法add，size，线程1添加10个元素到容器，线程2监控元素的个数，当个数为5时，线程2提示并结束" class="headerlink" title="41.面试题：实现一个容器，提供两个方法add，size，线程1添加10个元素到容器，线程2监控元素的个数，当个数为5时，线程2提示并结束"></a>41.面试题：实现一个容器，提供两个方法add，size，线程1添加10个元素到容器，线程2监控元素的个数，当个数为5时，线程2提示并结束</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyContainerVolatile &#123;</span><br><span class="line">    volatile List list &#x3D; new ArrayList();</span><br><span class="line">    public void add(Object o) &#123;  &#x2F;&#x2F;add</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    public int size() &#123;   &#x2F;&#x2F;size</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyContainerVolatile mcv &#x3D; new MyContainerVolatile();</span><br><span class="line">        new Thread( () -&gt; &#123;  &#x2F;&#x2F;该线程负责往list里添加</span><br><span class="line">           for (int i&#x3D;0; i&lt;10; i++) &#123;</span><br><span class="line">               mcv.add(new Object());</span><br><span class="line">               System.out.print(&quot; add-&quot; + i);</span><br><span class="line">               try &#123;</span><br><span class="line">                   Thread.sleep(500);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,&quot;t1&quot;).start();</span><br><span class="line">        new Thread( () -&gt; &#123; &#x2F;&#x2F;该线程一直监测list的size，直到size&#x3D;5</span><br><span class="line">            while(true) &#123;  &#x2F;&#x2F;一直监测着，很浪费CPU</span><br><span class="line">                if(mcv.size() &#x3D;&#x3D; 5) &#123;  &#x2F;&#x2F;此处未加同步，仍然可能会出现t1中又一次++为6了，才break</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot; t2结束 &quot;);</span><br><span class="line">        &#125;,&quot;t2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码能解决问题，但t2线程的死循环很浪费CPU，影响性能！更优方法是使用wait和notify，请参看下例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyContainerWaitNotify &#123;</span><br><span class="line">    volatile List list &#x3D; new ArrayList();</span><br><span class="line">    public void add(Object o) &#123;</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyContainerWaitNotify mcwn &#x3D; new MyContainerWaitNotify();</span><br><span class="line">        final Object lock &#x3D; new Object();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.print(&quot; ***线程t2启动*** &quot;);</span><br><span class="line">                if (mcwn.size() !&#x3D; 5) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        lock.wait();  &#x2F;&#x2F;size不等于5时，就一直在那等着，直到被t1叫醒</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(&quot; ***线程t2结束*** &quot;);</span><br><span class="line">                lock.notify();  &#x2F;&#x2F;通知t1继续执行</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t2&quot;).start();</span><br><span class="line"> </span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                for(int i&#x3D;0; i&lt;10; i++) &#123;</span><br><span class="line">                    mcwn.add(new Object());</span><br><span class="line">                    System.out.print(&quot; add-&quot;  + i);</span><br><span class="line">                    if (mcwn.size() &#x3D;&#x3D; 5) &#123;</span><br><span class="line">                        lock.notify();  &#x2F;&#x2F;唤醒另一个线程t2，本线程继续执行，直至synchronized包裹的代码块结束或者调用了wait</span><br><span class="line">                        try &#123;</span><br><span class="line">                            lock.wait(); &#x2F;&#x2F;释放锁，让t2得以执行</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;t1&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：wait会释放锁，但notify不会，本代码会执行到wait或synchronized块结束才释放锁；</p>
<p>但是，上述的方法还是过于繁琐，Java提供了门闩；</p>
<p>使用CountDownLatch（门闩）的await和countdown方法替代wait和notify方法来进行通知：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyContainerLatch &#123;</span><br><span class="line">    volatile List list &#x3D; new ArrayList(); &#x2F;&#x2F;添加volatile，使t2能够得到通知</span><br><span class="line">    public void add(Object o) &#123;</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyContainerLatch mcl &#x3D; new MyContainerLatch();</span><br><span class="line">        CountDownLatch latch &#x3D; new CountDownLatch(1);  &#x2F;&#x2F;当1变成0时，门就开了</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.print(&quot; *t2启动* &quot;);</span><br><span class="line">            if (mcl.size() !&#x3D; 5) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    latch.await();  &#x2F;&#x2F;等待不需要锁定一个对象</span><br><span class="line">                    &#x2F;&#x2F;latch.await(5000,TimeUnit.MILLISECONDS); &#x2F;&#x2F;也可以指定等待时间</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot; *t2结束* &quot;);</span><br><span class="line">        &#125;,&quot;t2&quot;).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            System.out.print(&quot; *t1启动* &quot;);</span><br><span class="line">            for (int i&#x3D;0; i&lt;10; i++) &#123;</span><br><span class="line">                mcl.add(new Object());</span><br><span class="line">                System.out.print(&quot; add-&quot; + i);</span><br><span class="line">                if (mcl.size() &#x3D;&#x3D; 5) &#123;</span><br><span class="line">                    latch.countDown(); &#x2F;&#x2F;打开门闩，让t2得以执行。调用一次countDown，就减1</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot; *t1结束* &quot;);</span><br><span class="line"> </span><br><span class="line">        &#125;,&quot;t1&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当不涉及同步，只涉及锁定，用synchronized+wait/notify就显得太重了。这时应该考虑CountDownLatch/cyclicbarrier/semephore</p>
<h4 id="42-ReentrantLock-重入锁"><a href="#42-ReentrantLock-重入锁" class="headerlink" title="42.ReentrantLock-重入锁"></a>42.ReentrantLock-重入锁</h4><p>Java中实现锁通常有两种方式，一种是使用synchronized关键字，另一种是Lock：</p>
<p><a href="https://img2018.cnblogs.com/blog/636698/201905/636698-20190527070802872-536965764.png" target="_blank" rel="noopener">synchronized和Lock的区别</a></p>
<p> ReentrantLock替代synchronized</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReentrantLockTest1 &#123;</span><br><span class="line">    Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">    void m1() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();  &#x2F;&#x2F;加锁  &#x2F;&#x2F;相当于synchronized(this)</span><br><span class="line">            for (int i&#x3D;0; i&lt;10; i++) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                System.out.print(&quot; &quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();  &#x2F;&#x2F;释放锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void m2() &#123;</span><br><span class="line">        lock.lock();  &#x2F;&#x2F;加锁</span><br><span class="line">        System.out.print(&quot; m2()... &quot;);</span><br><span class="line">        lock.unlock();  &#x2F;&#x2F;释放锁</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLockTest1 r1 &#x3D; new ReentrantLockTest1();</span><br><span class="line">        new Thread(r1::m1).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread(r1::m2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="43-写一个固定容量的同步容器，有put和get方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用"><a href="#43-写一个固定容量的同步容器，有put和get方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用" class="headerlink" title="43.写一个固定容量的同步容器，有put和get方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用"></a>43.写一个固定容量的同步容器，有put和get方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用</h4><p>使用wait和notify/notifyAll来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyContainer1&lt;T&gt; &#123;</span><br><span class="line">    final private LinkedList&lt;T&gt; lists &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    final private int MAX &#x3D;10;</span><br><span class="line">    private int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void put(T t)&#123;</span><br><span class="line">        while(lists.size()&#x3D;&#x3D;MAX)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lists.add(t);</span><br><span class="line">        ++count;</span><br><span class="line">        this.notifyAll();&#x2F;&#x2F;通知消费者线程进行消费</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized T get()&#123;</span><br><span class="line">        T t &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;为什么用while? wait 99.9%情况下都是和while一起用的</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        while(lists.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t &#x3D; lists.removeFirst();</span><br><span class="line">        count--;</span><br><span class="line">        this.notifyAll();</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        MyContainer1&lt;String&gt; c &#x3D; new MyContainer1&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;启动消费者线程</span><br><span class="line">        for(int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                for(int j&#x3D;0; j&lt;5; j++)&#123;</span><br><span class="line">                    System.out.println(c.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;c&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;启动生产者线程</span><br><span class="line">        for(int i&#x3D;0;i&lt;2;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                for(int j &#x3D;0;j&lt;25;j++)&#123;</span><br><span class="line">                    c.put(Thread.currentThread().getName()+&quot; &quot;+j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;p&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Lock和Condition的方式可以更加精确地指定哪些线程被唤醒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyContainer2&lt;T&gt; &#123;</span><br><span class="line">    final private LinkedList&lt;T&gt; lists&#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    final private int MAX &#x3D;20;</span><br><span class="line">    private int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">    private Condition producer &#x3D; lock.newCondition();</span><br><span class="line">    private Condition consumer &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void put(T t)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            while(lists.size()&#x3D;&#x3D;MAX)&#123;</span><br><span class="line">                producer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            lists.add(t);</span><br><span class="line">            ++count;</span><br><span class="line">            consumer.signalAll();</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T get()&#123;</span><br><span class="line">        T t &#x3D; null;</span><br><span class="line">        try&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            while(lists.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            t&#x3D;lists.removeFirst();</span><br><span class="line">            count--;</span><br><span class="line">            producer.signalAll();</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        MyContainer2&lt;String&gt; c &#x3D; new MyContainer2();</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                for(int j&#x3D;0; j&lt;5; j++)&#123;</span><br><span class="line">                    System.out.println(c.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;c&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;启动生产者线程</span><br><span class="line">        for(int i&#x3D;0;i&lt;2;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                for(int j &#x3D;0;j&lt;25;j++)&#123;</span><br><span class="line">                    c.put(Thread.currentThread().getName()+&quot; &quot;+j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;p&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="44-有N张火车票，每张票都有一个编号，同时有10个窗口对外售票"><a href="#44-有N张火车票，每张票都有一个编号，同时有10个窗口对外售票" class="headerlink" title="44.有N张火车票，每张票都有一个编号，同时有10个窗口对外售票"></a>44.有N张火车票，每张票都有一个编号，同时有10个窗口对外售票</h4><p>以下程勋存在重复销售，超量销售问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TicketSeller1 &#123;</span><br><span class="line">    static List&lt;String&gt; tickets &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F;初始化，放票</span><br><span class="line">    static&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;10000; i++)</span><br><span class="line">            tickets.add(&quot;票编号：&quot;+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        &#x2F;&#x2F;启动10个线程不断往外卖票</span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                while(tickets.size()&gt;0)&#123;</span><br><span class="line">                    System.out.println(&quot;销售了--&quot;+tickets.remove(0));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进人存在判断与操作分离了（虽然在vector中size和remove方法都是原子的）问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TicketSeller2 &#123;</span><br><span class="line">    &#x2F;&#x2F;vector本身就是一个同步容器，它所有的方法都是加锁的</span><br><span class="line">    static Vector&lt;String&gt; tickets &#x3D; new Vector&lt;&gt;();</span><br><span class="line">    static&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;10000; i++)</span><br><span class="line">            tickets.add(&quot;票编号：&quot;+i);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                while(tickets.size()&gt;0)&#123;</span><br><span class="line">                    &#x2F;*</span><br><span class="line">                    try&#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(10);</span><br><span class="line">                    &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;*&#x2F;</span><br><span class="line">                    System.out.println(&quot;销售了--&quot;+tickets.remove(0));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再改进仍存在加锁效率不高，尤其是每销售一张票都要把整个队列给锁定；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TicketSeller3 &#123;</span><br><span class="line">    static List&lt;String&gt; tickets &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    static&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;10000; i++)</span><br><span class="line">            tickets.add(&quot;票编号：&quot;+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        &#x2F;&#x2F;启动10个线程不断往外卖票</span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    synchronized (tickets)&#123;</span><br><span class="line">                        if(tickets.size()&lt;&#x3D;0) break;</span><br><span class="line">                        try&#123;</span><br><span class="line">                            TimeUnit.SECONDS.sleep(10);</span><br><span class="line">                        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.out.println(&quot;销售了--&quot;+tickets.remove(0));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入并发容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TicketSeller4 &#123;</span><br><span class="line">    &#x2F;&#x2F;并发容器</span><br><span class="line">    static Queue&lt;String&gt; tickets &#x3D; new ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">    static&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;1000; i++)&#123;</span><br><span class="line">            tickets.add(&quot;票编号：&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        for(int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    &#x2F;&#x2F;poll从头往外拿一个数据，是同步的</span><br><span class="line">                    String s &#x3D; tickets.poll();</span><br><span class="line">                    if(s&#x3D;&#x3D;null) break;</span><br><span class="line">                    else System.out.println(&quot;销售了--&quot;+s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if(s==null) break;虽然不是原子性的，但是我们判断以后没有对队列作修改操作，所以这里不会出错。</p>
<h4 id="45-类的加载机制"><a href="#45-类的加载机制" class="headerlink" title="45.类的加载机制"></a>45.类的加载机制</h4><p>类的生命周期一共分为5个阶段，加载、连接、初始化、使用、卸载。</p>
<p><a href="https://imgchr.com/i/8wNbWt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/18/8wNbWt.md.png" alt="8wNbWt.md.png"></a></p>
<p>加载：类的加载过程主要完成3件事件，1.通过类的全限定名来获取定义此类的二进制字节流，2.将这个类字节流代表的静态存储结构转为方法区的运行时数据结构，3.在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。这个过程主要是类加载器完成的。</p>
<p>连接：这个过程分3个阶段(校验，准备，解析)完成。首先是校验，此阶段主要校验class文件包含的信息是否符合jvm的规范。具体的校验通过对文件格式，元数据，字节码，符号引用验证来完成。然后是准备，此阶段为类变量分配内存，并将其初始化为默认值。最后是解析，即把类型中的符号引用转换成为直接引用。具体的解析有4种，1.类或接口的解析，2.字段解析，3.类方法解析，4.接口方法解析。完成这3个阶段就完成了类的连接。</p>
<p>初始化：即执行类的构造器方法的过程。有5种方法可以完成初始化：1.调用new方法，2.使用Class类的newInstance方法(反射机制)，3.使用Constructor类的newInstance方法(反射机制)，4.使用Clone方法创建对象，5.使用(反)序列化机制创建对象</p>
<p>使用：完成类的初始化后，就可以对类进行实例化，在程序中进行使用了</p>
<p>卸载：当类被加载，连接和初始化后，它的生命周期就始了，当代表类的class对象不在被引用时，class对象就会结束生命周期，类在方法区内的数据就会被卸载。因此一个类何时结束生命，取决于代表它的class对象何时结束生命。</p>
<h4 id="46-JVM调优"><a href="#46-JVM调优" class="headerlink" title="46.JVM调优"></a>46.JVM调优</h4><p>jvm调优没有一个固定模板配置说必须如何操作，它需要根据系统的情况不同对待。</p>
<p>但是可以有如下建议：</p>
<p>1、初始化内存和最大内存尽量保持一致，避免内存不够用继续扩充内存。最大内存不要超过物理内存，例如内存8g，你可以设置最大内存4g/6g但是不能超过8g否则加载类的时候没有空间会报错。</p>
<p>2、gc/full gc频率不要太高、每次gc时间不要太长、根据系统应用来定。</p>
<h4 id="47-对象的内存布局"><a href="#47-对象的内存布局" class="headerlink" title="47.对象的内存布局"></a>47.对象的内存布局</h4><p>对象头(Header)：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p>
<p>实例数据(Instance Data)：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p>
<p>对齐填充(Padding)：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</p>
<h4 id="48-对象的访问定位"><a href="#48-对象的访问定位" class="headerlink" title="48.对象的访问定位"></a>48.对象的访问定位</h4><p>通过句柄访问</p>
<p>Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。详情见图</p>
<p><a href="https://imgchr.com/i/8wYPW6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/18/8wYPW6.png" alt="8wYPW6.png"></a></p>
<p>使用直接指针访问</p>
<p>reference 中直接存储对象地址</p>
<p><a href="https://imgchr.com/i/8wYKYt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/18/8wYKYt.md.png" alt="8wYKYt.md.png"></a></p>
<p>比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p>
<h4 id="49-Thread-类中的start-和-run-方法有什么区别？"><a href="#49-Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="49.Thread 类中的start() 和 run() 方法有什么区别？"></a>49.Thread 类中的start() 和 run() 方法有什么区别？</h4><p>这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部 调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启 动，start()方法才会启动新线程。</p>
<h4 id="50-Java中Runnable和Callable有什么不同？"><a href="#50-Java中Runnable和Callable有什么不同？" class="headerlink" title="50. Java中Runnable和Callable有什么不同？"></a>50. Java中Runnable和Callable有什么不同？</h4><p>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在 JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。</p>
<h4 id="51-Java中CyclicBarrier-和-CountDownLatch有什么不同？"><a href="#51-Java中CyclicBarrier-和-CountDownLatch有什么不同？" class="headerlink" title="51.Java中CyclicBarrier 和 CountDownLatch有什么不同？"></a>51.Java中CyclicBarrier 和 CountDownLatch有什么不同？</h4><p>CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。</p>
<h4 id="52-如何在两个线程间共享数据？"><a href="#52-如何在两个线程间共享数据？" class="headerlink" title="52.如何在两个线程间共享数据？"></a>52.如何在两个线程间共享数据？</h4><p>你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。</p>
<h4 id="53-为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#53-为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="53.为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>53.为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h4><p>这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在 Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通 过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁 就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象</p>
<h4 id="52-什么是线程安全？Vector是一个线程安全类吗？"><a href="#52-什么是线程安全？Vector是一个线程安全类吗？" class="headerlink" title="52. 什么是线程安全？Vector是一个线程安全类吗？"></a>52. 什么是线程安全？Vector是一个线程安全类吗？</h4><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量 的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分 成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的</p>
<h4 id="53-什么是ThreadLocal变量？"><a href="#53-什么是ThreadLocal变量？" class="headerlink" title="53.什么是ThreadLocal变量？"></a>53.什么是ThreadLocal变量？</h4><p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被 彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因 为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通 过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是 ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。</p>
<h4 id="54-为什么你应该在循环中检查等待条件"><a href="#54-为什么你应该在循环中检查等待条件" class="headerlink" title="54.为什么你应该在循环中检查等待条件?"></a>54.为什么你应该在循环中检查等待条件?</h4><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来 时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方 法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《Effective Java》这本书中的线程和同步章节。</p>
<h4 id="55-Java中的同步集合与并发集合有什么区别？"><a href="#55-Java中的同步集合与并发集合有什么区别？" class="headerlink" title="55.Java中的同步集合与并发集合有什么区别？"></a>55.Java中的同步集合与并发集合有什么区别？</h4><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在 多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分 区等现代技术提高了可扩展性。</p>
<h4 id="56-Java中堆和栈有什么不同？"><a href="#56-Java中堆和栈有什么不同？" class="headerlink" title="56.Java中堆和栈有什么不同？"></a>56.Java中堆和栈有什么不同？</h4><p>为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈 调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己 的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p>
<h4 id="57-Java中活锁和死锁有什么区别？"><a href="#57-Java中活锁和死锁有什么区别？" class="headerlink" title="57.Java中活锁和死锁有什么区别？"></a>57.Java中活锁和死锁有什么区别？</h4><p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个 人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者 进程的状态可以改变但是却不能继续执行.</p>
<h4 id="58-怎么检测一个线程是否拥有锁？"><a href="#58-怎么检测一个线程是否拥有锁？" class="headerlink" title="58.怎么检测一个线程是否拥有锁？"></a>58.怎么检测一个线程是否拥有锁？</h4><p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p>
<h4 id="59-JVM中哪个参数是用来控制线程的栈堆栈小的"><a href="#59-JVM中哪个参数是用来控制线程的栈堆栈小的" class="headerlink" title="59.JVM中哪个参数是用来控制线程的栈堆栈小的"></a>59.JVM中哪个参数是用来控制线程的栈堆栈小的</h4><p>这个问题很简单， -Xss参数用来控制线程的堆栈大小。</p>
<h4 id="60-Java中synchronized-和-ReentrantLock-有什么不同？"><a href="#60-Java中synchronized-和-ReentrantLock-有什么不同？" class="headerlink" title="60. Java中synchronized 和 ReentrantLock 有什么不同？"></a>60. Java中synchronized 和 ReentrantLock 有什么不同？</h4><p>Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法</p>
<h4 id="61-有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#61-有三个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="61.有三个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>61.有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h4><p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。</p>
<h4 id="62-Java中Semaphore是什么？"><a href="#62-Java中Semaphore是什么？" class="headerlink" title="62.Java中Semaphore是什么？"></a>62.Java中Semaphore是什么？</h4><p>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前 会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采 取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。</p>
<h4 id="63-volatile-变量和-atomic-变量有什么不同？"><a href="#63-volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="63.volatile 变量和 atomic 变量有什么不同？"></a>63.volatile 变量和 atomic 变量有什么不同？</h4><p>这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性 的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<h4 id="64-写出3条你遵循的多线程最佳实践"><a href="#64-写出3条你遵循的多线程最佳实践" class="headerlink" title="64.写出3条你遵循的多线程最佳实践"></a>64.写出3条你遵循的多线程最佳实践</h4><p>给你的线程起个有意义的名字。<br>这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</p>
<p>避免锁定和缩小同步的范围。<br>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</p>
<p>多用同步类少用wait 和 notify。<br>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断 优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</p>
<p>多用并发集合少用同步集合。<br>这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。</p>
<h4 id="65-Java多线程中调用wait-和-sleep-方法有什么不同？"><a href="#65-Java多线程中调用wait-和-sleep-方法有什么不同？" class="headerlink" title="65.Java多线程中调用wait() 和 sleep()方法有什么不同？"></a>65.Java多线程中调用wait() 和 sleep()方法有什么不同？</h4><p>Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而 sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。</p>
<h4 id="66-java的反射机制"><a href="#66-java的反射机制" class="headerlink" title="66.java的反射机制"></a>66.java的反射机制</h4><p>java的反射机制是在运行状态中，对于任意一个类（Class）都能知道他的属性（Field）和方法（Method），对于任意一个对象都能够调用它的方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。它允许正在运行的java程序观测甚至是修改程序的动态行为。</p>
<p>Java中反射有如下几种实现方式：</p>
<p>1、通过Class.forName()方法加载字符串，就可以得到该字符串做代表的Class对象。</p>
<p>2、通过类名调用class属性得到该类的Class对象。</p>
<p>3、调用实例的getClass()方法。</p>
<p>4、如果是基本类型的包装类，则可以通过调用包装类的Type属性来获得该包装类的Class对象。</p>
<p>反射在java中的应用</p>
<p>1、java集成开发环境，每当我们敲入点号时，IDE便会根据点号前的内容，动态展示可以访问的字段和方法。</p>
<p>2、java调试器，它能够在调试过程中枚举某一对象所有字段的值。</p>
<p>3、web开发中，我们经常接触到各种配置的通用框架。为保证框架的可扩展性，他往往借助java的反射机制。例如Spring框架的依赖反转（IOC）便是依赖于反射机制。</p>
<h4 id="67-三大集合接口的引出"><a href="#67-三大集合接口的引出" class="headerlink" title="67.三大集合接口的引出"></a>67.三大集合接口的引出</h4><p>Java中的常见集合可以概括如下。</p>
<ul>
<li>Map接口和Collection接口是所有集合框架的父接口</li>
<li>Collection接口的子接口包括：Set接口和List接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、LinkedHashMap、ConcurrentHashMap以及Properties等</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ul>
<h2 id="二、C-面试笔记"><a href="#二、C-面试笔记" class="headerlink" title="二、C++面试笔记"></a>二、C++面试笔记</h2><h3 id="C-内容"><a href="#C-内容" class="headerlink" title="C++内容"></a>C++内容</h3><h4 id="1-物理内存和虚拟内存"><a href="#1-物理内存和虚拟内存" class="headerlink" title="1.物理内存和虚拟内存"></a>1.物理内存和虚拟内存</h4><ul>
<li>每个进程都认为自己独立的享有着计算机的内存</li>
<li>虚拟内存：程序运行时，会进行一系列的操作。<br>进程会构建自己的虚拟地址空间（进程地址空间），该地址空间所有进程都独立的享有一份，如果是32位机器，则会创建2^32（4G）大小的地址空间 ，如果是64位机器，可以创建2^64大小的地址空间（目前所有的程序都没有这么大），创建出来的虚拟地址空间中（以32位机器为例，一般编译器可以选择使用32位或者64位），其中1G为操作系统所用，剩下3G空间为用户所用</li>
<li>进程的虚拟地址通过页表访问物理内存，保证了多个进程访问物理内存之间的不冲突性。</li>
<li>每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址</li>
<li>当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。</li>
<li>在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</li>
</ul>
<h4 id="2-虚拟内存机制的优点"><a href="#2-虚拟内存机制的优点" class="headerlink" title="2.虚拟内存机制的优点"></a>2.虚拟内存机制的优点</h4><ul>
<li>在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</li>
<li>当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存</li>
<li>在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。</li>
</ul>
<h4 id="3-C-中的堆栈"><a href="#3-C-中的堆栈" class="headerlink" title="3.C++中的堆栈"></a>3.C++中的堆栈</h4><p><img src="https://img-blog.csdnimg.cn/20191031203641608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5NjY4NQ==,size_16,color_FFFFFF,t_70" alt></p>
<ul>
<li>栈又叫做堆栈，非静态局部变量/函数参数/返回值等，都在其中存放，栈是向下增长的。</li>
<li>内存映射段是装在动静态库，用户使用系统接口创建空想内存的地址区。（本节不详细说明）</li>
<li>堆，用于程序运行时动态内存管理分配的区域，与栈区相对，向上增长。</li>
<li>数据段是用来存储全局变量和静态数据的区域</li>
<li>代码段是用来存储代码的区域。</li>
</ul>
<h4 id="4-C语言中管理内存的方式"><a href="#4-C语言中管理内存的方式" class="headerlink" title="4.C语言中管理内存的方式"></a>4.C语言中管理内存的方式</h4><ul>
<li>malloc函数：分配一个大小size字节的内存块，返回指向该块开头的指针。</li>
<li>alloc函数：分配num个元素组成的内存块，每个元素的大小都是size大小，并将其所有位初始化为零。分配一个(num * size)字节的零初始化内存块</li>
<li>realloc：先判断当前的指针是否有足够的连续空间，如果有，扩大指针指向的地址，并且将新地址的指针返回，如果空间不够，先按照size指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来内存区域（注意：原来指针是自动释放，不需要使用free），同时返回新分配的内存区域的首地址。即重新分配存储器块的地址</li>
<li>free：简单来说，释放一个指针所指向的空间</li>
</ul>
<h4 id="5-free-与delete的区别"><a href="#5-free-与delete的区别" class="headerlink" title="5.free()与delete的区别"></a>5.free()与delete的区别</h4><ul>
<li><p>1、new/delete是C++的操作符，而malloc/free是C中的函数。</p>
</li>
<li><p>2、new做两件事，一是分配内存，二是调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。</p>
</li>
<li><p>3、new建立的是一个对象，而malloc分配的是一块内存；new建立的对象可以用成员函数访问，不要直接访问它的地址空间；malloc分配的是一块内存区域，用指针访问，可以在里面移动指针；new出来的指针是带有类型信息的，而malloc返回的是void指针。</p>
</li>
<li><p>4、new/delete是保留字，不需要头文件支持；malloc/free需要头文件库函数支持</p>
</li>
</ul>
<h4 id="6-进程和程序的区别和联系"><a href="#6-进程和程序的区别和联系" class="headerlink" title="6.进程和程序的区别和联系"></a>6.进程和程序的区别和联系</h4><ul>
<li>1、进程是动态的，而程序是静态的。</li>
<li>2、进程有一定的生命期，而程序是指令的集合，本身无“运动”的含义。没有建立进程的程序不能作为1个独立单位得到操作系统的认可。</li>
<li>3、1个程序可以对应多个进程，但1个进程只能对应1个程序。进程和程序的关系犹如演出和剧本的关系。</li>
<li>4、进程和程序的组成不同。从静态角度看，进程由程序、数据和进程控制块（PCB）三部分组成。而程序是一组有序的指令集合</li>
</ul>
<h4 id="7-static关键字的作用"><a href="#7-static关键字的作用" class="headerlink" title="7.static关键字的作用"></a>7.static关键字的作用</h4><ul>
<li><p>对于函数定义和代码块之外的变量声明，static修改标识符的链接属性，由默认的external变为internal，作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。</p>
</li>
<li><p>对于代码块内部的变量声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。</p>
</li>
<li><p>对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用</p>
</li>
<li><p>对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。一样，它们都属于类的静态成员，它们都不是对象成员。</p>
</li>
</ul>
<h4 id="8-C-和C的区别"><a href="#8-C-和C的区别" class="headerlink" title="8.C++和C的区别"></a>8.C++和C的区别</h4><p>设计思想上：</p>
<ul>
<li>C++是面向对象的语言，而C是面向过程的结构化编程语言</li>
</ul>
<p>语法上：</p>
<ul>
<li><p>C++具有封装、继承和多态三种特性</p>
</li>
<li><p>C++相比C，增加多许多类型安全的功能，比如强制类型转换、</p>
</li>
<li><p>C++支持范式编程，比如模板类、函数模板等</p>
</li>
</ul>
<h4 id="9-C-中四种cast转换"><a href="#9-C-中四种cast转换" class="headerlink" title="9.C++中四种cast转换"></a>9.C++中四种cast转换</h4><ul>
<li>1、const_cast:用于将const变量转为非const</li>
<li>2、static_cast: 用于各种隐式转换， 比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</li>
<li>dynamic_cast:用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常</li>
<li>reinterpret_cast:几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</li>
<li>为什么不使用C的强制转换？<br>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</li>
</ul>
<h4 id="10-C-C-中指针和引用的区别？"><a href="#10-C-C-中指针和引用的区别？" class="headerlink" title="10.C/C++ 中指针和引用的区别？"></a>10.C/C++ 中指针和引用的区别？</h4><ul>
<li><p>1.指针有自己的一块空间，而引用只是一个别名；</p>
</li>
<li><p>2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</p>
</li>
<li><p>3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</p>
</li>
<li><p>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</p>
</li>
<li><p>5.可以有const指针，但是没有const引用；</p>
</li>
<li><p>6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</p>
</li>
<li><p>7.指针可以有多级指针（**p），而引用只有一级；</p>
</li>
<li><p>8.指针和引用使用++运算符的意义不一样；</p>
</li>
<li><p>9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p>
</li>
</ul>
<h4 id="11-数组和指针的区别"><a href="#11-数组和指针的区别" class="headerlink" title="11.数组和指针的区别"></a>11.数组和指针的区别</h4><ul>
<li>指针：保存数据的地址。间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据。通常用于动态的数据结构。通过Malloc分配内存，free释放内存。通常指向匿名数据，操作匿名函数</li>
<li>保存数据。直接访问数据。通常用于固定数目且数据类型相同的元素。隐式的分配和删除。自身即为数据名。</li>
</ul>
<h4 id="12-野指针"><a href="#12-野指针" class="headerlink" title="12.野指针"></a>12.野指针</h4><ul>
<li>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</li>
</ul>
<h4 id="13-C-中的智能指针"><a href="#13-C-中的智能指针" class="headerlink" title="13.C++中的智能指针"></a>13.C++中的智能指针</h4><ul>
<li>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。</li>
<li>最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配</li>
<li>对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。</li>
<li>并可以通过get函数获得普通指针。</li>
</ul>
<h4 id="14-智能指针有没有内存泄露的情况"><a href="#14-智能指针有没有内存泄露的情况" class="headerlink" title="14.智能指针有没有内存泄露的情况"></a>14.智能指针有没有内存泄露的情况</h4><ul>
<li>当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</li>
<li>智能指针的内存泄漏如何解决<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从</span><br><span class="line">而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管</span><br><span class="line">理的对象是否已经被释放，从而避免非法访问。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="15-C-中析构函数的作用"><a href="#15-C-中析构函数的作用" class="headerlink" title="15.C++中析构函数的作用"></a>15.C++中析构函数的作用</h4><ul>
<li>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</li>
<li>析构函数名也应与类名相同，只是在函数名前面加一个位取反符，例如stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</li>
<li>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</li>
</ul>
<h4 id="16-C-中虚函数的作用和多态"><a href="#16-C-中虚函数的作用和多态" class="headerlink" title="16.C++中虚函数的作用和多态"></a>16.C++中虚函数的作用和多态</h4><ul>
<li>C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。</li>
<li>当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，[即B b; A a = &b;] 父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（如果不使用virtual方法，请看后面★*），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。</li>
<li>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。</li>
</ul>
<h4 id="17-虚函数的底层实现机制"><a href="#17-虚函数的底层实现机制" class="headerlink" title="17.虚函数的底层实现机制"></a>17.虚函数的底层实现机制</h4><ul>
<li>编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，每个类使用一个虚函数表，每个类对象用一个虚表指针。</li>
<li>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</li>
</ul>
<h4 id="18-为什么父类的析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数"><a href="#18-为什么父类的析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数" class="headerlink" title="18.为什么父类的析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数"></a>18.为什么父类的析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</h4><ul>
<li><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
</li>
<li><p>C ++ 默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
</li>
</ul>
<h4 id="19-函数指针"><a href="#19-函数指针" class="headerlink" title="19.函数指针"></a>19.函数指针</h4><ul>
<li>函数指针是指向函数的指针变量。</li>
<li>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。</li>
</ul>
<h4 id="20-fork函数"><a href="#20-fork函数" class="headerlink" title="20.fork函数"></a>20.fork函数</h4><ul>
<li>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。</li>
<li>在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</li>
<li>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。</li>
<li>Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</li>
</ul>
<h4 id="21-静态函数和虚函数的区别"><a href="#21-静态函数和虚函数的区别" class="headerlink" title="21.静态函数和虚函数的区别"></a>21.静态函数和虚函数的区别</h4><p>参考回答：</p>
<ul>
<li>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。</li>
<li>虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销</li>
</ul>
<h4 id="22-strcpy和strlen"><a href="#22-strcpy和strlen" class="headerlink" title="22.strcpy和strlen"></a>22.strcpy和strlen</h4><ul>
<li>strcpy是字符串拷贝函数，原型：<br>char <em>strcpy(char</em> dest, const char *src);从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。</li>
<li>strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</li>
</ul>
<h4 id="23-请你来写个函数在main函数执行前先运行"><a href="#23-请你来写个函数在main函数执行前先运行" class="headerlink" title="23.请你来写个函数在main函数执行前先运行"></a>23.请你来写个函数在main函数执行前先运行</h4><p>__attribute((constructor))是gcc扩展，标记这个函数应当在main函数之前执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__attribute((constructor))void before()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;before main\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-以下四行代码的区别是什么？-const-char-arr-“123”-char-brr-“123”-const-char-crr-“123”-char-drr-“123”"><a href="#24-以下四行代码的区别是什么？-const-char-arr-“123”-char-brr-“123”-const-char-crr-“123”-char-drr-“123”" class="headerlink" title="24.以下四行代码的区别是什么？ const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”;"></a>24.以下四行代码的区别是什么？ const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”;</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const char * arr &#x3D; &quot;123&quot;;</span><br><span class="line">&#x2F;&#x2F;字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char * brr &#x3D; &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改&quot;123&quot;的值</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const char crr[] &#x3D; &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char drr[] &#x3D; &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;字符串123保存在栈区，可以通过drr去修改</span><br></pre></td></tr></table></figure>

<h4 id="25-C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#25-C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="25.C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>25.C++里是怎么定义常量的？常量存放在内存的哪个位置？</h4><ul>
<li>常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。</li>
<li>对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局/静态存储区。</li>
<li>对于字面值常量，常量存放在常量存储区</li>
</ul>
<h4 id="26-如果同时定义了两个函数，一个带const，一个不带，会有问题吗？"><a href="#26-如果同时定义了两个函数，一个带const，一个不带，会有问题吗？" class="headerlink" title="26.如果同时定义了两个函数，一个带const，一个不带，会有问题吗？"></a>26.如果同时定义了两个函数，一个带const，一个不带，会有问题吗？</h4><ul>
<li>不会，这相当于函数的重载。</li>
</ul>
<h4 id="27-C-函数栈空间的最大值"><a href="#27-C-函数栈空间的最大值" class="headerlink" title="27.C++函数栈空间的最大值"></a>27.C++函数栈空间的最大值</h4><p>默认是1M，不过可以调整</p>
<h4 id="28-说一说extern“C”"><a href="#28-说一说extern“C”" class="headerlink" title="28.说一说extern“C”"></a>28.说一说extern“C”</h4><ul>
<li>C++调用C函数需要extern C，因为C语言没有函数重载。</li>
</ul>
<h4 id="29-隐式类型转换"><a href="#29-隐式类型转换" class="headerlink" title="29.隐式类型转换"></a>29.隐式类型转换</h4><ul>
<li>首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换。</li>
<li>其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。</li>
</ul>
<h4 id="30-RTTI是什么"><a href="#30-RTTI是什么" class="headerlink" title="30.RTTI是什么"></a>30.RTTI是什么</h4><ul>
<li>RTTI 是“Runtime Type Information”的缩写，意思是：运行时类型信息。它提供了运行时确定对象类型的方法。</li>
<li>两个重要的 RTTI 运算符的使用方法，它们是 typeid 和 dynamic_cast。</li>
<li>typeid的主要作用就是让用户知道当前的变量是什么类型的，对于内置数据类型以及自定义数据类型都生效</li>
<li>dynamic_cast主要用于在多态的时候，它允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构中安全地转换类型，把基类指针（引用）转换为派生类指针（引用）</li>
</ul>
<h4 id="31-虚函数表具体是怎样实现运行时多态的"><a href="#31-虚函数表具体是怎样实现运行时多态的" class="headerlink" title="31.虚函数表具体是怎样实现运行时多态的?"></a>31.虚函数表具体是怎样实现运行时多态的?</h4><ul>
<li>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换；</li>
<li>对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</li>
</ul>
<h4 id="32-C语言是怎么进行函数调用的？"><a href="#32-C语言是怎么进行函数调用的？" class="headerlink" title="32.C语言是怎么进行函数调用的？"></a>32.C语言是怎么进行函数调用的？</h4><ul>
<li>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。</li>
<li>调用前，先把返回地址压栈，然后把当前函数的esp指针压栈</li>
</ul>
<h4 id="33-C语言参数压栈顺序？"><a href="#33-C语言参数压栈顺序？" class="headerlink" title="33.C语言参数压栈顺序？"></a>33.C语言参数压栈顺序？</h4><p>从右到左</p>
<h4 id="34-C-如何处理返回值？"><a href="#34-C-如何处理返回值？" class="headerlink" title="34.C++如何处理返回值？"></a>34.C++如何处理返回值？</h4><ul>
<li>生成一个临时变量，把它的引用作为函数参数传入函数内。</li>
</ul>
<h4 id="35-C-中拷贝赋值函数的形参能否进行值传递？"><a href="#35-C-中拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="35.C++中拷贝赋值函数的形参能否进行值传递？"></a>35.C++中拷贝赋值函数的形参能否进行值传递？</h4><ul>
<li>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。</li>
</ul>
<h4 id="36-fork-wait-exec函数"><a href="#36-fork-wait-exec函数" class="headerlink" title="36.fork,wait,exec函数"></a>36.fork,wait,exec函数</h4><ul>
<li>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。</li>
<li>fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。</li>
<li>exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1</li>
</ul>
<h4 id="37-C-中struct和class的区别"><a href="#37-C-中struct和class的区别" class="headerlink" title="37.C++中struct和class的区别"></a>37.C++中struct和class的区别</h4><ul>
<li>在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。</li>
<li>class还可以定义模板类形参，比如template &lt;class T, int i&gt;。</li>
</ul>
<h4 id="38-什么是右值引用，跟左值又有什么区别？"><a href="#38-什么是右值引用，跟左值又有什么区别？" class="headerlink" title="38.什么是右值引用，跟左值又有什么区别？"></a>38.什么是右值引用，跟左值又有什么区别？</h4><ul>
<li>右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</span><br><span class="line"></span><br><span class="line">2. 能够更简洁明确地定义泛型函数。</span><br></pre></td></tr></table></figure></li>
<li>左值和右值的概念：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">左值：能对表达式取地址、或具名对象&#x2F;变量。一般指表达式结束后依然存在的持久对象。</span><br><span class="line"></span><br><span class="line">右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</span><br></pre></td></tr></table></figure></li>
<li>右值引用和左值引用的区别：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 左值可以寻址，而右值不可以。</span><br><span class="line"></span><br><span class="line">2. 左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。</span><br><span class="line"></span><br><span class="line">3. 左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="39-静态变量什么时候初始化"><a href="#39-静态变量什么时候初始化" class="headerlink" title="39.静态变量什么时候初始化"></a>39.静态变量什么时候初始化</h4><ul>
<li>静态变量存储在虚拟地址空间的数据段和bss段</li>
<li>C语言中其在代码执行之前初始化，属于编译期初始化。</li>
<li>而C ++ 中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造</li>
</ul>
<h3 id="容器STL"><a href="#容器STL" class="headerlink" title="容器STL"></a>容器STL</h3><h4 id="1-stl里面set和map怎么实现的"><a href="#1-stl里面set和map怎么实现的" class="headerlink" title="1.stl里面set和map怎么实现的?"></a>1.stl里面set和map怎么实现的?</h4><ul>
<li>集合，所有元素都会根据元素的值自动被排序，且不允许重复。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">底层实现：红黑树</span><br><span class="line"></span><br><span class="line">set 底层是通过红黑树（RB-tree）来实现的，由于红黑树是一种平衡二叉搜索树，自动排序的效果很不错，所以标准的 STL 的 set 即以 RB-Tree 为底层机制。又由于 set 所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 set 操作行为，都只有转调用 RB-tree 的操作行为而已。</span><br><span class="line"></span><br><span class="line">适用场景：有序不重复集合</span><br></pre></td></tr></table></figure></li>
<li>映射。map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</span><br><span class="line"></span><br><span class="line">底层：红黑树</span><br><span class="line"></span><br><span class="line">适用场景：有序键值对不重复映射</span><br></pre></td></tr></table></figure>
<h4 id="2-STL中map与unordered-map"><a href="#2-STL中map与unordered-map" class="headerlink" title="2.STL中map与unordered_map"></a>2.STL中map与unordered_map</h4>1、Map映射，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</li>
</ul>
<p>底层实现：红黑树</p>
<p>适用场景：有序键值对不重复映射</p>
<p>2、Multimap多重映射。multimap 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许键值重复。</p>
<p>底层实现：红黑树</p>
<p>适用场景：有序键值对可重复映射</p>
<h4 id="3-vector和list的区别，应用"><a href="#3-vector和list的区别，应用" class="headerlink" title="3.vector和list的区别，应用"></a>3.vector和list的区别，应用</h4><ul>
<li><p>1vector底层实现是数组；list是双向 链表。</p>
</li>
<li><p>2）vector支持随机访问，list不支持。</p>
</li>
<li><p>3）vector是顺序内存，list不是。</p>
</li>
<li><p>4）vector在中间节点进行插入删除会导致内存拷贝，list不会。</p>
</li>
<li><p>5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</p>
</li>
<li><p>6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</p>
</li>
</ul>
<p>应用</p>
<ul>
<li><p>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</p>
</li>
<li><p>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</p>
</li>
</ul>
<h4 id="4-STL迭代器是怎么删除元素的呢"><a href="#4-STL迭代器是怎么删除元素的呢" class="headerlink" title="4.STL迭代器是怎么删除元素的呢"></a>4.STL迭代器是怎么删除元素的呢</h4><ul>
<li><p>1.对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；</p>
</li>
<li><p>2.对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。</p>
</li>
<li><p>3.对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。</p>
</li>
</ul>
<h4 id="5-STL中迭代器的作用，有指针为何还要迭代器"><a href="#5-STL中迭代器的作用，有指针为何还要迭代器" class="headerlink" title="5.STL中迭代器的作用，有指针为何还要迭代器?"></a>5.STL中迭代器的作用，有指针为何还要迭代器?</h4><ul>
<li>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、–等。</li>
<li>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。</li>
</ul>
<p>迭代器产生原因</p>
<ul>
<li>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</li>
</ul>
<h4 id="6-STL里resize和reserve的区别"><a href="#6-STL里resize和reserve的区别" class="headerlink" title="6.STL里resize和reserve的区别"></a>6.STL里resize和reserve的区别</h4><ul>
<li>resize()：改变当前容器内含有元素的数量(size())，eg: vector<int>v; v.resize(len);v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；</int></li>
<li>reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；</li>
</ul>
<h3 id="编译与底层"><a href="#编译与底层" class="headerlink" title="编译与底层"></a>编译与底层</h3><h4 id="1-一个C-源文件从文本到可执行文件经历的过程？"><a href="#1-一个C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="1.一个C++源文件从文本到可执行文件经历的过程？"></a>1.一个C++源文件从文本到可执行文件经历的过程？</h4><ul>
<li><p>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</p>
</li>
<li><p>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</p>
</li>
<li><p>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</p>
</li>
<li><p>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</p>
</li>
</ul>
<h4 id="2-include头文件的顺序"><a href="#2-include头文件的顺序" class="headerlink" title="2.include头文件的顺序"></a>2.include头文件的顺序</h4><ul>
<li>对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。</li>
</ul>
<h4 id="3-双引号””和尖括号-lt-gt-的区别？"><a href="#3-双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="3.双引号””和尖括号&lt;&gt;的区别？"></a>3.双引号””和尖括号&lt;&gt;的区别？</h4><ul>
<li><p>双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。</p>
</li>
<li><p>双引号包含的头文件，查找头文件路径的顺序为：<br>1）.当前头文件目录；2）编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）;3)系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
</li>
<li><p>尖括号包含的头文件，查找头文件的路径顺序为：<br>1)编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）;2)系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
</li>
</ul>
<h4 id="4-malloc的原理"><a href="#4-malloc的原理" class="headerlink" title="4.malloc的原理"></a>4.malloc的原理</h4><ul>
<li>Malloc函数用于动态分配内存。</li>
<li>为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。</li>
<li>当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</li>
</ul>
<h4 id="5-brk系统调用和mmap系统调用的作用分别是什么？"><a href="#5-brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="5.brk系统调用和mmap系统调用的作用分别是什么？"></a>5.brk系统调用和mmap系统调用的作用分别是什么？</h4><ul>
<li>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</li>
</ul>
<h4 id="6-C-的内存管理是怎样的？"><a href="#6-C-的内存管理是怎样的？" class="headerlink" title="6.C++的内存管理是怎样的？"></a>6.C++的内存管理是怎样的？</h4><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</p>
<ul>
<li><p>代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
</li>
<li><p>数据段：存储程序中已初始化的全局变量和静态变量</p>
</li>
<li><p>bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</p>
</li>
<li><p>堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。</p>
</li>
<li><p>映射区:存储动态链接库以及调用mmap函数进行的文件映射</p>
</li>
<li><p>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
</li>
</ul>
<h4 id="7-如何判断内存泄漏？"><a href="#7-如何判断内存泄漏？" class="headerlink" title="7.如何判断内存泄漏？"></a>7.如何判断内存泄漏？</h4><ul>
<li>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。 </li>
<li>为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind</li>
<li>另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</li>
</ul>
<h4 id="8-什么时候会发生段错误"><a href="#8-什么时候会发生段错误" class="headerlink" title="8.什么时候会发生段错误"></a>8.什么时候会发生段错误</h4><ul>
<li>段错误通常发生在访问非法内存地址的时候</li>
<li>使用野指针</li>
<li>试图修改字符串常量的内容</li>
</ul>
<h4 id="9-memory-leak，也就是内存泄漏"><a href="#9-memory-leak，也就是内存泄漏" class="headerlink" title="9.memory leak，也就是内存泄漏"></a>9.memory leak，也就是内存泄漏</h4><ul>
<li>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。</li>
<li>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</li>
<li>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</li>
<li>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li>
<li>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li>
</ul>
<h4 id="10-说一下共享内存相关api"><a href="#10-说一下共享内存相关api" class="headerlink" title="10.说一下共享内存相关api"></a>10.说一下共享内存相关api</h4><p>1）新建共享内存shmget</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int shmget(key_t key,size_t size,int shmflg);</span><br><span class="line"></span><br><span class="line">key：共享内存键值，可以理解为共享内存的唯一性标记。</span><br><span class="line"></span><br><span class="line">size：共享内存大小</span><br><span class="line"></span><br><span class="line">shmflag：创建进程和其他进程的读写权限标识。</span><br><span class="line"></span><br><span class="line">返回值：相应的共享内存标识符，失败返回-1</span><br></pre></td></tr></table></figure>

<p>2）连接共享内存到当前进程的地址空间shmat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void *shmat(int shm_id,const void *shm_addr,int shmflg);</span><br><span class="line"></span><br><span class="line">shm_id：共享内存标识符</span><br><span class="line"></span><br><span class="line">shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。</span><br><span class="line"></span><br><span class="line">shmflg：标志位</span><br><span class="line"></span><br><span class="line">返回值：指向共享内存第一个字节的指针，失败返回-1</span><br></pre></td></tr></table></figure>

<p>3）当前进程分离共享内存shmdt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int shmdt(const void *shmaddr);</span><br></pre></td></tr></table></figure>

<p>4）控制共享内存shmctl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">和信号量的semctl函数类似，控制共享内存</span><br><span class="line"></span><br><span class="line">int shmctl(int shm_id,int command,struct shmid_ds *buf);</span><br><span class="line"></span><br><span class="line">shm_id：共享内存标识符</span><br><span class="line"></span><br><span class="line">command: 有三个值</span><br><span class="line"></span><br><span class="line">IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</span><br><span class="line"></span><br><span class="line">IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。</span><br><span class="line"></span><br><span class="line">IPC_RMID:删除共享内存</span><br><span class="line"></span><br><span class="line">buf：共享内存管理结构体。</span><br></pre></td></tr></table></figure>
<h4 id="11-如何采用单线程的方式处理高并发"><a href="#11-如何采用单线程的方式处理高并发" class="headerlink" title="11.如何采用单线程的方式处理高并发"></a>11.如何采用单线程的方式处理高并发</h4><ul>
<li>在单线程模型中，可以采用I/O复用来提高单线程处理多个请求的能力</li>
<li>然后再采用事件驱动模型</li>
<li>基于异步回调来处理事件来</li>
</ul>
<h4 id="12-C-如何处理内存泄漏？"><a href="#12-C-如何处理内存泄漏？" class="headerlink" title="12.C++如何处理内存泄漏？"></a>12.C++如何处理内存泄漏？</h4><ul>
<li>使用varglind，mtrace检测</li>
</ul>
<h3 id="C-11特性"><a href="#C-11特性" class="headerlink" title="C++11特性"></a>C++11特性</h3><h4 id="1-C-11-最常用的新特性如下："><a href="#1-C-11-最常用的新特性如下：" class="headerlink" title="1.C++11 最常用的新特性如下："></a>1.C++11 最常用的新特性如下：</h4><ul>
<li><p>auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导</p>
</li>
<li><p>nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。</p>
</li>
<li><p>智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。</p>
</li>
<li><p>初始化列表：使用初始化列表来对类进行初始化</p>
</li>
<li><p>右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率</p>
</li>
<li><p>atomic原子操作用于多线程资源互斥操作</p>
</li>
<li><p>新增STL容器array以及tuple</p>
</li>
</ul>
<h2 id="三、操作系统"><a href="#三、操作系统" class="headerlink" title="三、操作系统"></a>三、操作系统</h2><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-进程与线程的概念"><a href="#1-进程与线程的概念" class="headerlink" title="1.进程与线程的概念"></a>1.进程与线程的概念</h4><ul>
<li>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</li>
<li>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。</li>
<li>每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</li>
</ul>
<p>两者区别</p>
<ul>
<li><p>1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p>
</li>
<li><p>2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</p>
</li>
<li><p>3.进程是资源分配的最小单位，线程是CPU调度的最小单位；</p>
</li>
<li><p>4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。</p>
</li>
<li><p>5.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p>
</li>
<li><p>6.进程间不会相互影响 ；一个线程挂掉将导致整个进程挂掉</p>
</li>
<li><p>7.进程适应于多核、多机分布；线程适用于多核</p>
</li>
</ul>
<h4 id="2-进程间通信的方式"><a href="#2-进程间通信的方式" class="headerlink" title="2.进程间通信的方式"></a>2.进程间通信的方式</h4><p>进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。</p>
<ul>
<li>管道</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">管道主要包括无名管道和命名管道 :管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.1 普通管道PIPE：</span><br><span class="line"></span><br><span class="line">1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</span><br><span class="line"></span><br><span class="line">2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</span><br><span class="line"></span><br><span class="line">3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</span><br><span class="line"></span><br><span class="line">1.2 命名管道FIFO：</span><br><span class="line"></span><br><span class="line">1)FIFO可以在无关的进程之间交换数据</span><br><span class="line"></span><br><span class="line">2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</span><br></pre></td></tr></table></figure>
<ul>
<li>系统IPC<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.1 消息队列</span><br><span class="line"></span><br><span class="line">消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line">1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</span><br><span class="line"></span><br><span class="line">2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</span><br><span class="line"></span><br><span class="line">3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.2 信号量semaphore</span><br><span class="line"></span><br><span class="line">信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line">1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</span><br><span class="line"></span><br><span class="line">2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</span><br><span class="line"></span><br><span class="line">3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</span><br><span class="line"></span><br><span class="line">4)支持信号量组。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.3 信号signal</span><br><span class="line"></span><br><span class="line">信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.4 共享内存（Shared Memory）</span><br><span class="line"></span><br><span class="line">它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line">1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取</span><br><span class="line"></span><br><span class="line">2)因为多个进程可以同时操作，所以需要进行同步</span><br><span class="line"></span><br><span class="line">3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</span><br></pre></td></tr></table></figure>
<ul>
<li>套接字SOCKET<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-线程间通信的方式"><a href="#3-线程间通信的方式" class="headerlink" title="3.线程间通信的方式"></a>3.线程间通信的方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</span><br><span class="line"></span><br><span class="line">互斥量Synchronized&#x2F;Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</span><br><span class="line"></span><br><span class="line">信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</span><br><span class="line"></span><br><span class="line">事件(信号)，Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</span><br></pre></td></tr></table></figure>

<h4 id="4-虚拟内存的好处"><a href="#4-虚拟内存的好处" class="headerlink" title="4.虚拟内存的好处"></a>4.虚拟内存的好处</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.扩大地址空间；</span><br><span class="line"></span><br><span class="line">2.内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。</span><br><span class="line"></span><br><span class="line">3.公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。</span><br><span class="line"></span><br><span class="line">4.当进程通信时，可采用虚存共享的方式实现。</span><br><span class="line"></span><br><span class="line">5.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存</span><br><span class="line"></span><br><span class="line">6.虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高</span><br><span class="line"></span><br><span class="line">7.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片</span><br></pre></td></tr></table></figure>

<h4 id="5-虚拟内存的代价"><a href="#5-虚拟内存的代价" class="headerlink" title="5.虚拟内存的代价"></a>5.虚拟内存的代价</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</span><br><span class="line"></span><br><span class="line">2.虚拟地址到物理地址的转换，增加了指令的执行时间。</span><br><span class="line"></span><br><span class="line">3.页面的换入换出需要磁盘I&#x2F;O，这是很耗时的</span><br><span class="line"></span><br><span class="line">4.如果一页中只有一部分数据，会浪费内存。</span><br></pre></td></tr></table></figure>
<p>缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、在指令执行期间产生和处理缺页中断信号</span><br><span class="line"></span><br><span class="line">2、一条指令在执行期间，可能产生多次缺页中断</span><br><span class="line"></span><br><span class="line">3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。</span><br></pre></td></tr></table></figure>
<h4 id="6-操作系统中的缺页中断"><a href="#6-操作系统中的缺页中断" class="headerlink" title="6.操作系统中的缺页中断"></a>6.操作系统中的缺页中断</h4><ul>
<li>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。</li>
<li>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</li>
</ul>
<p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、保护CPU现场</span><br><span class="line"></span><br><span class="line">2、分析中断原因</span><br><span class="line"></span><br><span class="line">3、转入缺页中断处理程序进行处理</span><br><span class="line"></span><br><span class="line">4、恢复CPU现场，继续执行</span><br></pre></td></tr></table></figure>

<h4 id="7-fork和vfork的区别"><a href="#7-fork和vfork的区别" class="headerlink" title="7.fork和vfork的区别"></a>7.fork和vfork的区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段</span><br><span class="line"></span><br><span class="line">2. fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。</span><br><span class="line"></span><br><span class="line">3. vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</span><br><span class="line"></span><br><span class="line">4.当需要改变共享数据段中变量的值，则拷贝父进程。</span><br></pre></td></tr></table></figure>

<h4 id="8-请问如何修改文件最大句柄数？"><a href="#8-请问如何修改文件最大句柄数？" class="headerlink" title="8.请问如何修改文件最大句柄数？"></a>8.请问如何修改文件最大句柄数？</h4><ul>
<li>linux默认最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报”too many open files”的错误。</li>
<li>ulimit -n &lt;可以同时打开的文件数&gt;，将当前进程的最大句柄数修改为指定的参数(该方法只针对当前进程有效，重新打开一个shell或者重新开启一个进程，参数还是之前的值)</li>
<li>ulimit -a查询Linux相关的参数</li>
</ul>
<p>对所有进程都有效的方法，修改Linux系统参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;security&#x2F;limits.conf 添加</span><br><span class="line"></span><br><span class="line">*　　soft　　nofile　　65536</span><br><span class="line"></span><br><span class="line">*　　hard　　nofile　　65536</span><br><span class="line"></span><br><span class="line">将最大句柄数改为65536</span><br></pre></td></tr></table></figure>
<p>修改以后保存，注销当前用户，重新登录，修改后的参数就生效了</p>
<h4 id="9-并发-concurrency-和并行-parallelism"><a href="#9-并发-concurrency-和并行-parallelism" class="headerlink" title="9.并发(concurrency)和并行(parallelism)"></a>9.并发(concurrency)和并行(parallelism)</h4><ul>
<li><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p>
</li>
<li><p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p>
</li>
</ul>
<h4 id="10-MySQL的端口号是多少，如何修改这个端口号"><a href="#10-MySQL的端口号是多少，如何修改这个端口号" class="headerlink" title="10.MySQL的端口号是多少，如何修改这个端口号"></a>10.MySQL的端口号是多少，如何修改这个端口号</h4><ul>
<li>mysql的默认端口是3306。</li>
<li>编辑/etc/my.cnf文件，早期版本有可能是my.conf文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。</li>
</ul>
<h4 id="11-操作系统中的页表寻址"><a href="#11-操作系统中的页表寻址" class="headerlink" title="11.操作系统中的页表寻址"></a>11.操作系统中的页表寻址</h4><ul>
<li>页式内存管理，内存分成固定长度的一个个页片。操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表.</li>
<li>页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。</li>
<li>通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。</li>
<li>一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。</li>
</ul>
<h4 id="12-请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"><a href="#12-请问单核机器上写多线程程序，是否需要考虑加锁，为什么？" class="headerlink" title="12.请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"></a>12.请问单核机器上写多线程程序，是否需要考虑加锁，为什么？</h4><ul>
<li>在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。</li>
<li>在单核机器上的多线程程序，仍然存在线程同步的问题。</li>
<li>因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。</li>
<li>如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。</li>
</ul>
<h4 id="13-线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"><a href="#13-线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的" class="headerlink" title="13.线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"></a>13.线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的</h4><p>线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SP:堆栈指针，指向当前栈的栈顶地址</span><br><span class="line"></span><br><span class="line">PC:程序计数器，存储下一条将要执行的指令</span><br><span class="line"></span><br><span class="line">EAX:累加寄存器，用于加法乘法的缺省寄存器</span><br></pre></td></tr></table></figure>

<h4 id="14-线程间的同步方式，最好说出具体的系统调用"><a href="#14-线程间的同步方式，最好说出具体的系统调用" class="headerlink" title="14.线程间的同步方式，最好说出具体的系统调用"></a>14.线程间的同步方式，最好说出具体的系统调用</h4><ul>
<li>信号量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：</span><br><span class="line"></span><br><span class="line">P(SV):如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。</span><br><span class="line"></span><br><span class="line">V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。</span><br><span class="line"></span><br><span class="line">其系统调用为：</span><br><span class="line"></span><br><span class="line">sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。</span><br><span class="line"></span><br><span class="line">sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</span><br></pre></td></tr></table></figure></li>
<li>互斥量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区      时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：</span><br><span class="line"></span><br><span class="line">pthread_mutex_init:初始化互斥锁</span><br><span class="line"></span><br><span class="line">pthread_mutex_destroy：销毁互斥锁</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。</span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。</span><br></pre></td></tr></table></figure></li>
<li>条件变量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个&#x2F;多个线程。即，当某个共享变量等于某个值时，调用 signal&#x2F;broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：</span><br><span class="line"></span><br><span class="line">pthread_cond_init：初始化条件变量</span><br><span class="line"></span><br><span class="line">pthread_cond_destroy：销毁条件变量</span><br><span class="line"></span><br><span class="line">pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。</span><br><span class="line"></span><br><span class="line">pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。</span><br></pre></td></tr></table></figure>
<h4 id="15-多线程和多进程的不同"><a href="#15-多线程和多进程的不同" class="headerlink" title="15.多线程和多进程的不同"></a>15.多线程和多进程的不同</h4></li>
<li>进程是资源分配的最小单位，而线程时CPU调度的最小单位。</li>
<li>多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。</li>
<li>多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于多核、多机分布。</li>
</ul>
<h4 id="16-游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"><a href="#16-游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？" class="headerlink" title="16.游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"></a>16.游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？</h4><ul>
<li>游戏服务器应该为每个用户开辟一个进程。因为同一进程间的线程会相互影响，一个线程死掉会影响其他线程，从而导致进程崩溃。因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程</li>
</ul>
<h4 id="17-OS缺页置换算法"><a href="#17-OS缺页置换算法" class="headerlink" title="17.OS缺页置换算法"></a>17.OS缺页置换算法</h4><p>当前操作系统最常采用的缺页置换算法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、FIFO（先进先出淘汰算法）</span><br><span class="line"></span><br><span class="line">思想：最近刚访问的，将来访问的可能性比较大。</span><br><span class="line"></span><br><span class="line">实现：使用一个队列，新加入的页面放入队尾，每次淘汰队首的页面，即最先进入的数据，最先被淘汰。</span><br><span class="line"></span><br><span class="line">弊端：无法体现页面冷热信息</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2、LFU（最不经常访问淘汰算法）</span><br><span class="line"></span><br><span class="line">思想：如果数据过去被访问多次，那么将来被访问的频率也更高。</span><br><span class="line"></span><br><span class="line">实现：每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块。</span><br><span class="line"></span><br><span class="line">开销：排序开销。</span><br><span class="line"></span><br><span class="line">弊端：缓存颠簸。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3、LRU（最近最少使用替换算法）</span><br><span class="line"></span><br><span class="line">思想：如果数据最近被访问过，那么将来被访问的几率也更高。</span><br><span class="line"></span><br><span class="line">实现：使用一个栈，新页面或者命中的页面则将该页面移动到栈底，每次替换栈顶的缓存页面。</span><br><span class="line"></span><br><span class="line">优点：LRU算法对热点数据命中率是很高的。</span><br><span class="line"></span><br><span class="line">缺陷：</span><br><span class="line"></span><br><span class="line">1）缓存颠簸，当缓存（1，2，3）满了，之后数据访问（0，3，2，1，0，3，2，1。。。）。</span><br><span class="line"></span><br><span class="line">2）缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4、LRU-K（LRU-2、LRU-3）</span><br><span class="line"></span><br><span class="line">思想：最久未使用K次淘汰算法。</span><br><span class="line"></span><br><span class="line">LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</span><br><span class="line"></span><br><span class="line">相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</span><br><span class="line"></span><br><span class="line">实现：</span><br><span class="line"></span><br><span class="line">1）数据第一次被访问，加入到访问历史列表；</span><br><span class="line"></span><br><span class="line">2）如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</span><br><span class="line"></span><br><span class="line">3）当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</span><br><span class="line"></span><br><span class="line">4）缓存数据队列中被再次访问后，重新排序；</span><br><span class="line"></span><br><span class="line">5）需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</span><br><span class="line"></span><br><span class="line">针对问题：</span><br><span class="line"></span><br><span class="line">LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5、2Q</span><br><span class="line"></span><br><span class="line">类似LRU-2。使用一个FIFO队列和一个LRU队列。</span><br><span class="line"></span><br><span class="line">实现：</span><br><span class="line"></span><br><span class="line">1）新访问的数据插入到FIFO队列；</span><br><span class="line"></span><br><span class="line">2）如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</span><br><span class="line"></span><br><span class="line">3）如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；</span><br><span class="line"></span><br><span class="line">4）如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；</span><br><span class="line"></span><br><span class="line">5）LRU队列淘汰末尾的数据。</span><br><span class="line"></span><br><span class="line">针对问题：LRU的缓存污染</span><br><span class="line"></span><br><span class="line">弊端：</span><br><span class="line"></span><br><span class="line">当FIFO容量为2时，访问负载是：ABCABCABC会退化为FIFO，用不到LRU。</span><br></pre></td></tr></table></figure>
<h4 id="18-作系统中的结构体对齐，字节对齐"><a href="#18-作系统中的结构体对齐，字节对齐" class="headerlink" title="18.作系统中的结构体对齐，字节对齐"></a>18.作系统中的结构体对齐，字节对齐</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、原因：</span><br><span class="line">1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</span><br><span class="line"></span><br><span class="line">2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</span><br><span class="line"></span><br><span class="line">2、规则</span><br><span class="line"></span><br><span class="line">1）数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</span><br><span class="line"></span><br><span class="line">2）结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</span><br><span class="line"></span><br><span class="line">3）结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。</span><br><span class="line"></span><br><span class="line">3、定义结构体对齐</span><br><span class="line"></span><br><span class="line">可以通过预编译命令#pragma pack(n)，n&#x3D;1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。</span><br><span class="line"></span><br><span class="line">4、举例</span><br><span class="line"></span><br><span class="line">#pragma pack(2)</span><br><span class="line"></span><br><span class="line">struct AA &#123;</span><br><span class="line"></span><br><span class="line">int a;       &#x2F;&#x2F;长度4 &gt; 2 按2对齐；偏移量为0；存放位置区间[0,3]</span><br><span class="line"></span><br><span class="line">char b;  &#x2F;&#x2F;长度1 &lt; 2 按1对齐；偏移量为4；存放位置区间[4]</span><br><span class="line"></span><br><span class="line">short c;     &#x2F;&#x2F;长度2 &#x3D; 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</span><br><span class="line"></span><br><span class="line">char d;  &#x2F;&#x2F;长度1 &lt; 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#pragma pack()</span><br></pre></td></tr></table></figure>

<h4 id="19-多进程和多线程的使用场景"><a href="#19-多进程和多线程的使用场景" class="headerlink" title="19.多进程和多线程的使用场景"></a>19.多进程和多线程的使用场景</h4><ul>
<li>多进程模型的优势是CPU</li>
<li>多线程模型主要优势为线程间切换代价较小，因此适用于I/O密集型的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于单机多核分布式场景。</li>
<li>多进程模型，适用于CPU密集型。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。</li>
</ul>
<h4 id="20-互斥锁和读写锁的区别"><a href="#20-互斥锁和读写锁的区别" class="headerlink" title="20.互斥锁和读写锁的区别"></a>20.互斥锁和读写锁的区别</h4><p>概念</p>
<ul>
<li><p>互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</p>
</li>
<li><p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p>
</li>
</ul>
<p>互斥锁和读写锁的区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）读写锁区分读者和写者，而互斥锁不区分</span><br><span class="line"></span><br><span class="line">2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</span><br></pre></td></tr></table></figure>
<h4 id="21-Linux的4种锁机制："><a href="#21-Linux的4种锁机制：" class="headerlink" title="21.Linux的4种锁机制："></a>21.Linux的4种锁机制：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线</span><br><span class="line">程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于</span><br><span class="line">读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠</span><br><span class="line">，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂</span><br><span class="line">的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时</span><br><span class="line">，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制</span><br><span class="line">被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。</span><br></pre></td></tr></table></figure>
<h4 id="22-进程状态转换图"><a href="#22-进程状态转换图" class="headerlink" title="22.进程状态转换图"></a>22.进程状态转换图</h4><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470678794_F9BF116BD97A95A5E655DF9E1672186F" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）创建状态：进程正在被创建</span><br><span class="line"></span><br><span class="line">2）就绪状态：进程被加入到就绪队列中等待CPU调度运行</span><br><span class="line"></span><br><span class="line">3）执行状态：进程正在被运行</span><br><span class="line"></span><br><span class="line">4）等待阻塞状态：进程因为某种原因，比如等待I&#x2F;O，等待设备，而暂时不能运行。</span><br><span class="line"></span><br><span class="line">5）终止状态：进程运行完毕</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。</span><br><span class="line"></span><br><span class="line">2）静止阻塞：进程在外存，同时被某种原因阻塞了。</span><br><span class="line"></span><br><span class="line">3）活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。</span><br><span class="line"></span><br><span class="line">4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。</span><br></pre></td></tr></table></figure>
<p>交换技术</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I&#x2F;0速</span><br><span class="line">度比处理机速度慢得多，可能出现全部进程阻塞等待I&#x2F;O。</span><br></pre></td></tr></table></figure>
<p>针对以上问题，提出了两种解决方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）交换技术：换出一部分进程到外存，腾出内存空间。</span><br><span class="line">2）虚拟存储技术：每个进程只能装入一部分程序和数据。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内</span><br><span class="line">存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。</span><br></pre></td></tr></table></figure>
<h4 id="23-A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？"><a href="#23-A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？" class="headerlink" title="23.A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？"></a>23.A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4&#x2F;8字节的空间（0x000m），分配给指针a。</span><br><span class="line"></span><br><span class="line">2）new A：通过new动态的在堆区申请类A大小的空间（0x000n）。</span><br><span class="line"></span><br><span class="line">3）a &#x3D; new A：将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）&#x3D;0x000n。</span><br><span class="line"></span><br><span class="line">4）a-&gt;i：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) &#x3D; </span><br><span class="line">10的赋值操作，即内存0x000n + offset的值是10。</span><br></pre></td></tr></table></figure>

<h4 id="24-用户态和内核态区别"><a href="#24-用户态和内核态区别" class="headerlink" title="24.用户态和内核态区别"></a>24.用户态和内核态区别</h4><ul>
<li>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。</li>
<li>用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。</li>
<li>内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</li>
</ul>
<h4 id="25-死循环-来连接时新建线程的方法效率有点低，怎么改进？"><a href="#25-死循环-来连接时新建线程的方法效率有点低，怎么改进？" class="headerlink" title="25.死循环+来连接时新建线程的方法效率有点低，怎么改进？"></a>25.死循环+来连接时新建线程的方法效率有点低，怎么改进？</h4><p>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术</p>
<h4 id="26-怎样确定当前线程是繁忙还是阻塞？"><a href="#26-怎样确定当前线程是繁忙还是阻塞？" class="headerlink" title="26.怎样确定当前线程是繁忙还是阻塞？"></a>26.怎样确定当前线程是繁忙还是阻塞？</h4><p>使用ps命令查看</p>
<h4 id="27-请问就绪状态的进程在等待什么？"><a href="#27-请问就绪状态的进程在等待什么？" class="headerlink" title="27.请问就绪状态的进程在等待什么？"></a>27.请问就绪状态的进程在等待什么？</h4><p>被调度使用cpu的运行权</p>
<h4 id="28-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#28-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="28.两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>28.两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h4><p>单核cpu，并且开了抢占可以造成这种情况。</p>
<h4 id="29-windows消息机制知道吗"><a href="#29-windows消息机制知道吗" class="headerlink" title="29.windows消息机制知道吗"></a>29.windows消息机制知道吗</h4><p>当用户有操作(鼠标，键盘等)时，系统会将这些时间转化为消息。每个打开的进程系统都为其维护了一个消息队列，系统会将这些消息放到进程的消息队列中，而应用程序会循环从消息队列中取出来消息，完成对应的操作</p>
<h4 id="30-请你说一说死锁产生的必要条件？"><a href="#30-请你说一说死锁产生的必要条件？" class="headerlink" title="30.请你说一说死锁产生的必要条件？"></a>30.请你说一说死锁产生的必要条件？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.互斥条件：一个资源每次只能被一个进程使用。</span><br><span class="line">2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</span><br><span class="line">3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</span><br><span class="line">4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</span><br></pre></td></tr></table></figure>

<h4 id="31-内存溢出和内存泄漏"><a href="#31-内存溢出和内存泄漏" class="headerlink" title="31.内存溢出和内存泄漏"></a>31.内存溢出和内存泄漏</h4><p>1、内存溢出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</span><br></pre></td></tr></table></figure>
<p>内存溢出原因：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1).内存中加载的数据量过于庞大，如一次从数据库取出过多数据</span><br><span class="line"></span><br><span class="line">2).集合类中有对对象的引用，使用完后未清空，使得不能回收</span><br><span class="line"></span><br><span class="line">3).代码中存在死循环或循环产生过多重复的对象实体</span><br><span class="line"></span><br><span class="line">4).使用的第三方软件中的BUG</span><br><span class="line"></span><br><span class="line">5).启动参数内存值设定的过小</span><br></pre></td></tr></table></figure>
<p>2、内存泄漏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理</span><br><span class="line">上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</span><br></pre></td></tr></table></figure>
<p>内存泄漏的分类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc </span><br><span class="line">new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete </span><br><span class="line">删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2、系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle </span><br><span class="line">,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3、没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，</span><br><span class="line">那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</span><br></pre></td></tr></table></figure>
<h4 id="32-常用线程模型"><a href="#32-常用线程模型" class="headerlink" title="32.常用线程模型"></a>32.常用线程模型</h4><p>1、Future模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该模型通常在使用的时候需要结合Callable接口配合使用。</span><br><span class="line"></span><br><span class="line">Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。</span><br><span class="line"></span><br><span class="line">Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。</span><br></pre></td></tr></table></figure>
<p>2、fork&amp;join模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子</span><br><span class="line">任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。</span><br><span class="line"></span><br><span class="line">这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时</span><br><span class="line">间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。</span><br></pre></td></tr></table></figure>
<p>3、actor模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继</span><br><span class="line">续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。</span><br></pre></td></tr></table></figure>

<p>4、生产者消费者模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个&#x2F;多个线程来生产任务，然后</span><br><span class="line">再开启一个&#x2F;多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费</span><br><span class="line">者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活</span><br><span class="line">的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。</span><br></pre></td></tr></table></figure>

<p>5、master-worker模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处</span><br><span class="line">理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。</span><br></pre></td></tr></table></figure>

<h4 id="33-协程与线程的区别"><a href="#33-协程与线程的区别" class="headerlink" title="33.协程与线程的区别"></a>33.协程与线程的区别</h4><ul>
<li><p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
</li>
<li><p>那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
</li>
<li><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
</li>
</ul>
<h4 id="34-系统调用是什么，你用过哪些系统调用"><a href="#34-系统调用是什么，你用过哪些系统调用" class="headerlink" title="34.系统调用是什么，你用过哪些系统调用"></a>34.系统调用是什么，你用过哪些系统调用</h4><ul>
<li>系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。</li>
<li>操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。</li>
<li>特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。</li>
<li>应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。</li>
<li>计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。</li>
<li>操作系统是这些资源的唯一入口，这个入口就是系统调用。</li>
</ul>
<p>写数据write，创建进程fork，vfork等都是系统调用。</p>
<h4 id="35-手写一下fork调用示例"><a href="#35-手写一下fork调用示例" class="headerlink" title="35.手写一下fork调用示例"></a>35.手写一下fork调用示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line">    printf(&quot;before fork pid:%d\n&quot;, getpid());</span><br><span class="line">    int abc &#x3D; 10;</span><br><span class="line">    pid &#x3D; fork();</span><br><span class="line">    </span><br><span class="line">    if (pid &#x3D;&#x3D; -1) &#123;           &#x2F;&#x2F;错误返回</span><br><span class="line">        perror(&quot;tile&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (pid &gt; 0) &#123;              &#x2F;&#x2F;父进程空间</span><br><span class="line">        abc++;</span><br><span class="line">        printf(&quot;parent:pid:%d \n&quot;, getpid());</span><br><span class="line">        printf(&quot;abc:%d \n&quot;, abc);</span><br><span class="line">        sleep(20);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (pid &#x3D;&#x3D; 0) &#123;       &#x2F;&#x2F;子进程空间</span><br><span class="line">        abc++;</span><br><span class="line">        printf(&quot;child:%d,parent: %d\n&quot;, getpid(), getppid());</span><br><span class="line">        printf(&quot;abc:%d&quot;, abc);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;fork after...\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="36-用户态到内核态的转化原理"><a href="#36-用户态到内核态的转化原理" class="headerlink" title="36.用户态到内核态的转化原理"></a>36.用户态到内核态的转化原理</h4><p>1、系统调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完</span><br><span class="line">成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。</span><br></pre></td></tr></table></figure>
<p>2、异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处</span><br><span class="line">理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。</span><br></pre></td></tr></table></figure>
<p>3、外围设备的中断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的</span><br><span class="line">指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然</span><br><span class="line">也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</span><br></pre></td></tr></table></figure>

<h4 id="37-微内核与宏内核"><a href="#37-微内核与宏内核" class="headerlink" title="37.微内核与宏内核"></a>37.微内核与宏内核</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。</span><br><span class="line">优点：效率高。</span><br><span class="line"></span><br><span class="line">缺点：稳定性差，开发过程中的bug经常会导致整个系统挂掉。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。</span><br><span class="line"></span><br><span class="line">优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃</span><br><span class="line"></span><br><span class="line">缺点：效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了。</span><br></pre></td></tr></table></figure>
<h4 id="38-僵尸进程"><a href="#38-僵尸进程" class="headerlink" title="38.僵尸进程"></a>38.僵尸进程</h4><p>1）正常进程</p>
<ul>
<li>子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</li>
<li>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1进程号the process ID</span><br><span class="line"></span><br><span class="line">2退出状态the termination status of the process</span><br><span class="line"></span><br><span class="line">3运行时间the amount of CPU time taken by the process等</span><br></pre></td></tr></table></figure>
2）孤儿进程</li>
<li>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li>
</ul>
<p>3）僵尸进程</p>
<ul>
<li>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</li>
<li>僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段</li>
<li>如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。</li>
<li>如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</li>
</ul>
<p>4）危害</p>
<ul>
<li>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。</li>
</ul>
<p>5）外部消灭：</p>
<ul>
<li>通过kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源</li>
</ul>
<p>6）内部解决：</p>
<ul>
<li><p>1、子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。</p>
</li>
<li><p>2、fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。</p>
</li>
</ul>
<h4 id="39-5种IO模型"><a href="#39-5种IO模型" class="headerlink" title="39.5种IO模型"></a>39.5种IO模型</h4><p>1.阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</p>
<p>2.非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。</p>
<p>3.信号驱动IO:信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</p>
<p>4.IO复用/多路转接IO:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</p>
<p>5.异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</p>
<h4 id="40-操作系统为什么要分内核态和用户态"><a href="#40-操作系统为什么要分内核态和用户态" class="headerlink" title="40.操作系统为什么要分内核态和用户态?"></a>40.操作系统为什么要分内核态和用户态?</h4><ul>
<li>为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。</li>
<li>分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。</li>
</ul>
<h4 id="41-操作系统怎么设计的page-cache"><a href="#41-操作系统怎么设计的page-cache" class="headerlink" title="41.操作系统怎么设计的page cache"></a>41.操作系统怎么设计的page cache</h4><ul>
<li>加快从磁盘读取文件的速率。page cache中有一部分磁盘文件的缓存</li>
<li>因为从磁盘中读取文件比较慢，所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。</li>
<li>在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项</li>
<li>它通过两个数据结构来管理这些 Cache<br>项，一个是radix tree，另一个是双向链表。Radix tree 是一种搜索树，Linux<br>内核利用这个数据结构来通过文件内偏移快速定位Cache项</li>
</ul>
<h4 id="42-死循环-来连接时新建线程的方法效率有点低，怎么改进？"><a href="#42-死循环-来连接时新建线程的方法效率有点低，怎么改进？" class="headerlink" title="42.死循环+来连接时新建线程的方法效率有点低，怎么改进？"></a>42.死循环+来连接时新建线程的方法效率有点低，怎么改进？</h4><ul>
<li>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。</li>
<li>改进死循环：使用select epoll这样的技术</li>
</ul>
<h4 id="43-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#43-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="43.两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>43.两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h4><ul>
<li>单核cpu，并且开了抢占可以造成这种情况。</li>
</ul>
<h4 id="44-请问怎么实现线程池"><a href="#44-请问怎么实现线程池" class="headerlink" title="44.请问怎么实现线程池"></a>44.请问怎么实现线程池</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.设置一个生产者消费者队列，作为临界资源</span><br><span class="line">2.初始化n个线程，并让其运行起来，加锁去队列取任务运行</span><br><span class="line">3.当任务队列为空的时候，所有线程阻塞</span><br><span class="line">4.当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程</span><br></pre></td></tr></table></figure>

<h4 id="44-Linux下怎么得到一个文件的100到200行"><a href="#44-Linux下怎么得到一个文件的100到200行" class="headerlink" title="44.Linux下怎么得到一个文件的100到200行"></a>44.Linux下怎么得到一个文件的100到200行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &#39;100,200p&#39; inputfile</span><br><span class="line">head -200 inputfile|tail -100</span><br></pre></td></tr></table></figure>
<h4 id="45-awk的使用"><a href="#45-awk的使用" class="headerlink" title="45.awk的使用"></a>45.awk的使用</h4><p>1）作用：</p>
<ul>
<li>样式扫描和处理语言。它允许创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</li>
</ul>
<h2 id="四、计算机网络"><a href="#四、计算机网络" class="headerlink" title="四、计算机网络"></a>四、计算机网络</h2><h3 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-请你说一下TCP怎么保证可靠性"><a href="#1-请你说一下TCP怎么保证可靠性" class="headerlink" title="1.请你说一下TCP怎么保证可靠性"></a>1.请你说一下TCP怎么保证可靠性</h4><p>（1）序列号、确认应答、超时重传</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一</span><br><span class="line">次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认</span><br><span class="line">应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。</span><br></pre></td></tr></table></figure>
<p>（2）窗口控制与高速重发控制/快速重传（重复确认应答）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据</span><br><span class="line">，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。</span><br></pre></td></tr></table></figure>
<p>（3）拥塞控制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发</span><br><span class="line">，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗</span><br><span class="line">口的值不再指数上升，而是加法增加（每次确认应答&#x2F;每个rtt，拥塞窗口大小+1），以此来避免拥塞。</span><br></pre></td></tr></table></figure>

<h4 id="2-三次握手"><a href="#2-三次握手" class="headerlink" title="2.三次握手"></a>2.三次握手</h4><ol>
<li><p>Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ol>
<p><img src="http://blog.chinaunix.net/attachment/201304/8/22312037_1365405910EROI.png" alt></p>
<h4 id="3-四次挥手"><a href="#3-四次挥手" class="headerlink" title="3.四次挥手"></a>3.四次挥手</h4><p>1.数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。</p>
<p>2.服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。</p>
<p>3.当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认</p>
<p>4.客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。</p>
<p><img src="http://blog.chinaunix.net/attachment/201304/9/22312037_1365503104wDR0.png" alt></p>
<h4 id="4-IP地址作用，以及MAC地址作用"><a href="#4-IP地址作用，以及MAC地址作用" class="headerlink" title="4.IP地址作用，以及MAC地址作用"></a>4.IP地址作用，以及MAC地址作用</h4><ul>
<li>MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。</li>
<li>IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</li>
</ul>
<h4 id="5-OSI七层模型和TCP-IP四层模型，每层列举2个协议"><a href="#5-OSI七层模型和TCP-IP四层模型，每层列举2个协议" class="headerlink" title="5.OSI七层模型和TCP/IP四层模型，每层列举2个协议"></a>5.OSI七层模型和TCP/IP四层模型，每层列举2个协议</h4><p>OSI七层模型及其包含的协议如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS</span><br></pre></td></tr></table></figure>

<h4 id="6-搜索baidu，会用到计算机网络中的什么层？"><a href="#6-搜索baidu，会用到计算机网络中的什么层？" class="headerlink" title="6.搜索baidu，会用到计算机网络中的什么层？"></a>6.搜索baidu，会用到计算机网络中的什么层？</h4><p>浏览器中输入URL</p>
<p>浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p>
<p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p>
<h4 id="7-达到什么情况的时候开始减慢增长的速度？"><a href="#7-达到什么情况的时候开始减慢增长的速度？" class="headerlink" title="7.达到什么情况的时候开始减慢增长的速度？"></a>7.达到什么情况的时候开始减慢增长的速度？</h4><p>采用慢开始和拥塞避免算法的时候</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度</span><br><span class="line"></span><br><span class="line">2. 一旦出现丢包的情况，就重新进行慢开始，减慢增长速度</span><br></pre></td></tr></table></figure>

<h4 id="8-传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文"><a href="#8-传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文" class="headerlink" title="8.传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文?"></a>8.传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文?</h4><ul>
<li>根据端口区分；</li>
<li>看ip头中的协议标识字段，17是udp，6是tcp</li>
</ul>
<h4 id="9-tcp握手为什么两次不可以？为什么不用四次？"><a href="#9-tcp握手为什么两次不可以？为什么不用四次？" class="headerlink" title="9.tcp握手为什么两次不可以？为什么不用四次？"></a>9.tcp握手为什么两次不可以？为什么不用四次？</h4><ul>
<li>两次不可以：tcp是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常</li>
<li>不用四次：<br>本来握手应该和挥手一样都是需要确认两个方向都能联通的</li>
</ul>
<h4 id="10-TCP和UDP的区别和各自适用的场景"><a href="#10-TCP和UDP的区别和各自适用的场景" class="headerlink" title="10.TCP和UDP的区别和各自适用的场景?"></a>10.TCP和UDP的区别和各自适用的场景?</h4><p>1）TCP和UDP区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1） 连接</span><br><span class="line"></span><br><span class="line">TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。</span><br><span class="line"></span><br><span class="line">UDP无连接。</span><br><span class="line"></span><br><span class="line">2） 服务对象</span><br><span class="line"></span><br><span class="line">TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；</span><br><span class="line"></span><br><span class="line">UDP支持一对一，一对多，多对一，多对多的交互通信。</span><br><span class="line"></span><br><span class="line">3） 可靠性</span><br><span class="line"></span><br><span class="line">TCP是可靠交付：无差错，不丢失，不重复，按序到达。</span><br><span class="line"></span><br><span class="line">UDP是尽最大努力交付，不保证可靠交付。</span><br><span class="line"></span><br><span class="line">4）拥塞控制，流量控制</span><br><span class="line"></span><br><span class="line">TCP有拥塞控制和流量控制保证数据传输的安全性。</span><br><span class="line"></span><br><span class="line">UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</span><br><span class="line"></span><br><span class="line">5） 报文长度</span><br><span class="line"></span><br><span class="line">TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</span><br><span class="line"></span><br><span class="line">UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</span><br><span class="line"></span><br><span class="line">6)   首部开销</span><br><span class="line"></span><br><span class="line">TCP首部开销大，首部20个字节。</span><br><span class="line"></span><br><span class="line">UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</span><br></pre></td></tr></table></figure>

<p>2）TCP和UDP适用场景</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选用TCP 协议（如文件传输、重要状态的更新等）；</span><br><span class="line">使用 UDP 协议（如视频传输、实时通信等）。</span><br></pre></td></tr></table></figure>

<h4 id="11-socket编程中服务器端和客户端主要用到哪些函数"><a href="#11-socket编程中服务器端和客户端主要用到哪些函数" class="headerlink" title="11.socket编程中服务器端和客户端主要用到哪些函数?"></a>11.socket编程中服务器端和客户端主要用到哪些函数?</h4><p>1）基于TCP的socket：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、服务器端程序：</span><br><span class="line"></span><br><span class="line">1创建一个socket，用函数socket()</span><br><span class="line"></span><br><span class="line">2绑定IP地址、端口等信息到socket上，用函数bind()</span><br><span class="line"></span><br><span class="line">3设置允许的最大连接数，用函数listen()</span><br><span class="line"></span><br><span class="line">4接收客户端上来的连接，用函数accept()</span><br><span class="line"></span><br><span class="line">5收发数据，用函数send()和recv()，或者read()和write()</span><br><span class="line"></span><br><span class="line">6关闭网络连接</span><br><span class="line"></span><br><span class="line">2、客户端程序：</span><br><span class="line"></span><br><span class="line">1创建一个socket，用函数socket()</span><br><span class="line"></span><br><span class="line">2设置要连接的对方的IP地址和端口等属性</span><br><span class="line"></span><br><span class="line">3连接服务器，用函数connect()</span><br><span class="line"></span><br><span class="line">4收发数据，用函数send()和recv()，或read()和write()</span><br><span class="line"></span><br><span class="line">5关闭网络连接</span><br></pre></td></tr></table></figure>
<p>2）基于UDP的socket：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、服务器端流程</span><br><span class="line"></span><br><span class="line">1建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。</span><br><span class="line"></span><br><span class="line">2设置服务器地址和侦听端口，初始化要绑定的网络地址结构。</span><br><span class="line"></span><br><span class="line">3绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。</span><br><span class="line"></span><br><span class="line">4接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。</span><br><span class="line"></span><br><span class="line">5向客户端发送数据，使用sendto()函数向服务器主机发送数据。</span><br><span class="line"></span><br><span class="line">6关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</span><br><span class="line"></span><br><span class="line">2、客户端流程</span><br><span class="line"></span><br><span class="line">1建立套接字文件描述符，socket()。</span><br><span class="line"></span><br><span class="line">2设置服务器地址和端口，struct sockaddr。</span><br><span class="line"></span><br><span class="line">3向服务器发送数据，sendto()。</span><br><span class="line"></span><br><span class="line">4接收服务器的数据，recvfrom()。</span><br><span class="line"></span><br><span class="line">5关闭套接字，close()。</span><br></pre></td></tr></table></figure>

<h4 id="12-讲述一下Socket编程的send-recv-accept-socket-函数？"><a href="#12-讲述一下Socket编程的send-recv-accept-socket-函数？" class="headerlink" title="12.讲述一下Socket编程的send() recv() accept() socket()函数？"></a>12.讲述一下Socket编程的send() recv() accept() socket()函数？</h4><p>1.send函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。</p>
<p>2.recv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。</p>
<p>3.accept函数用了接收一个连接，内核维护了半连接队列和一个已完成连接队列，当队列为空的时候，accept函数阻塞，不为空的时候accept函数从上边取下来一个已完成连接，返回一个文件描述符。</p>
<h2 id="五、数据库"><a href="#五、数据库" class="headerlink" title="五、数据库"></a>五、数据库</h2><h3 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-数据库事务隔离"><a href="#1-数据库事务隔离" class="headerlink" title="1.数据库事务隔离"></a>1.数据库事务隔离</h4><p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<h4 id="2-数据库的四个基本特征"><a href="#2-数据库的四个基本特征" class="headerlink" title="2.数据库的四个基本特征"></a>2.数据库的四个基本特征</h4><p>1）原子性（Atomicity）</p>
<p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<p>2）一致性（Consistency）</p>
<p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<p>3）隔离性（Isolation）</p>
<p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>4）持久性（Durability）</p>
<p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<h4 id="3-索引是什么？"><a href="#3-索引是什么？" class="headerlink" title="3.索引是什么？"></a>3.索引是什么？</h4><p>1、索引</p>
<p>数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。</p>
<p>2、优点：</p>
<p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
<p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p>
<p>3、缺点：</p>
<p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p>
<p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p>
<h4 id="4-数据库的三大范式"><a href="#4-数据库的三大范式" class="headerlink" title="4.数据库的三大范式"></a>4.数据库的三大范式</h4><p>第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分</p>
<p>第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式</p>
<p>第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于键码</p>
<h4 id="5-mysql的MVCC机制"><a href="#5-mysql的MVCC机制" class="headerlink" title="5.mysql的MVCC机制"></a>5.mysql的MVCC机制</h4><ul>
<li>MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。</li>
<li>MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</li>
</ul>
<h4 id="6-SQL优化方法有哪些"><a href="#6-SQL优化方法有哪些" class="headerlink" title="6.SQL优化方法有哪些?"></a>6.SQL优化方法有哪些?</h4><ul>
<li>通过建立索引对查询进行优化</li>
<li>对查询进行优化，应尽量避免全表扫描</li>
</ul>
<h4 id="7-mongodb和redis的区别"><a href="#7-mongodb和redis的区别" class="headerlink" title="7.mongodb和redis的区别"></a>7.mongodb和redis的区别</h4><p>1.内存管理机制上</p>
<ul>
<li>Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据。</li>
<li>MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘。</li>
</ul>
<p>2.支持的数据结构上</p>
<ul>
<li>Redis 支持的数据结构丰富，包括hash、set、list等。</li>
<li>MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富</li>
</ul>
<h4 id="8-Redis是单线程的，但是为什么这么高效呢"><a href="#8-Redis是单线程的，但是为什么这么高效呢" class="headerlink" title="8.Redis是单线程的，但是为什么这么高效呢?"></a>8.Redis是单线程的，但是为什么这么高效呢?</h4><ul>
<li>通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型</li>
<li>又可以很好地与Redis服务器中其他同样以单线程运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</li>
</ul>
<h4 id="9-Redis和memcached的区别"><a href="#9-Redis和memcached的区别" class="headerlink" title="9.Redis和memcached的区别"></a>9.Redis和memcached的区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）数据类型 ：redis数据类型丰富，支持set liset等类型；memcache支持简单数据类型，需要客户端自己处理复杂对象</span><br><span class="line">2）持久性：redis支持数据落地持久化存储；memcache不支持数据持久存储。)</span><br><span class="line"></span><br><span class="line">3）分布式存储：redis支持master-slave复制模式；memcache可以使用一致性hash做分布式。</span><br><span class="line"></span><br><span class="line">4）value大小不同：memcache是一个内存缓存，key的长度小于250字符，单个item存储要小于1M，不适合虚拟机使用</span><br><span class="line"></span><br><span class="line">5）数据一致性不同：redis使用的是单线程模型，保证了数据按顺序提交；memcache需要使用cas保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作</span><br><span class="line"></span><br><span class="line">6）cpu利用：redis单线程模型只能使用一个cpu，可以开启多个redis进程</span><br></pre></td></tr></table></figure>

<h4 id="10-使用redis可能出现的问题"><a href="#10-使用redis可能出现的问题" class="headerlink" title="10.使用redis可能出现的问题"></a>10.使用redis可能出现的问题</h4><p>答： 在这里我们主要介绍Redis可能出现的三个问题，如下所示：</p>
<p>缓存雪崩：<br>举例：缓存同一时间大面积的失效，这个时候又来的一波请求都到数据库上，导致数据库连接异常。</p>
<p>解决办法：可以给缓存设置不同的缓存时间，更新数据使用互斥锁或者通过双缓存在避免缓存雪崩。</p>
<p>缓存穿透：<br>举例：故意的去请求缓存中不存在的数据，导致请求都打到了数据库上，导致数据库异常。</p>
<p>解决办法：可以使用互斥锁或者无论是否取到结果都将结果存入缓存，还可以使用有效的机制来拦截不合法的key值等。</p>
<p>数据库和缓存的双写一致性问题：<br>在高并发请求下很容易导致数据不一致的问题，如果你的业务需要保证数据的强一致性，那么建议不要使用缓存。在数据库中和缓存数据的删除或者写入过程中，如果有失败的情况，会导致数据的不一致。</p>
<h4 id="11-为什么-Redis-中要使用-I-O-多路复用这种技术呢？"><a href="#11-为什么-Redis-中要使用-I-O-多路复用这种技术呢？" class="headerlink" title="11.为什么 Redis 中要使用 I/O 多路复用这种技术呢？"></a>11.为什么 Redis 中要使用 I/O 多路复用这种技术呢？</h4><p>首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的。</p>
<p>阻塞式的 I/O 模型并不能满足这里的需求，我们需要一种效率更高的 I/O 模型来支撑 Redis 的多个客户（redis-cli），这里涉及的就是 I/O 多路复用模型了。<br>Redis 服务采用 Reactor 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符）</p>
<p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 accept、read、write 和 close 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。<br>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务实现的简单。</p>
<h2 id="六、设计模式"><a href="#六、设计模式" class="headerlink" title="六、设计模式"></a>六、设计模式</h2><h3 id="常见问题-3"><a href="#常见问题-3" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-OOP的设计模式的五项原则"><a href="#1-OOP的设计模式的五项原则" class="headerlink" title="1.OOP的设计模式的五项原则"></a>1.OOP的设计模式的五项原则</h4><p>1、单一职责原则</p>
<p>单一职责有2个含义，一个是避免相同的职责分散到不同的类中，另一个是避免一个类承担太多职责。减少类的耦合，提高类的复用性。</p>
<p>2、接口隔离原则</p>
<p>表明客户端不应该被强迫实现一些他们不会使用的接口，应该把胖接口中额方法分组，然后用多个接口代替它，每个接口服务于一个子模块。简单说，就是使用多个专门的接口比使用单个接口好很多。</p>
<p>3、开放-封闭原则</p>
<p>open模块的行为必须是开放的、支持扩展的，而不是僵化的。</p>
<p>closed在对模块的功能进行扩展时，不应该影响或大规模影响已有的程序模块。一句话概括：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。</p>
<p>4、替换原则</p>
<p>子类型必须能够替换掉他们的父类型、并出现在父类能够出现的任何地方。</p>
<p>5、依赖倒置原则</p>
<p>上层模块不应该依赖于下层模块，他们共同依赖于一个抽象，即：父类不能依赖子类，他们都要依赖抽象类。</p>
<p>抽象不能依赖于具体，具体应该要依赖于抽象</p>
<h4 id="2-你用过哪些设计模式"><a href="#2-你用过哪些设计模式" class="headerlink" title="2.你用过哪些设计模式"></a>2.你用过哪些设计模式</h4><p>单例模式：单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p>
<p>工厂模式：工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。</p>
<p>观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<h4 id="3-你所知道的设计模式有哪些？"><a href="#3-你所知道的设计模式有哪些？" class="headerlink" title="3.你所知道的设计模式有哪些？"></a>3.你所知道的设计模式有哪些？</h4><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模<br>式、建造者模式、原型模式。</p>
<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、<br>外观模式、桥接模式、组合模式、享元模式。</p>
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模<br>式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<h4 id="4-Android-中举几个例子说说用到了什么设计模式-？"><a href="#4-Android-中举几个例子说说用到了什么设计模式-？" class="headerlink" title="4.Android 中举几个例子说说用到了什么设计模式 ？"></a>4.Android 中举几个例子说说用到了什么设计模式 ？</h4><ul>
<li><p>AlertDialog、Notification 源码中使用了 Builder（建造者）<br>模式完成参数的初始化</p>
</li>
<li><p>Okhttp 内部使用了责任链模式来完成每个 Interceptor 拦截<br>器的调用</p>
</li>
<li><p>RxJava 的观察者模式；单例模式；GridView 的适配器模式；<br>Intent 的原型模式</p>
</li>
<li><p>日常开发的 BaseActivity 抽象工厂模式</p>
</li>
</ul>
<h2 id="七、git用法"><a href="#七、git用法" class="headerlink" title="七、git用法"></a>七、git用法</h2><h4 id="1-merge-和-rebase-的运行机制有什么不同"><a href="#1-merge-和-rebase-的运行机制有什么不同" class="headerlink" title="1. merge 和 rebase 的运行机制有什么不同"></a>1. merge 和 rebase 的运行机制有什么不同</h4><ol>
<li>可以看出merge结果能够体现出时间线，但是rebase会打乱时间线。 </li>
<li>而rebase看起来简洁，但是merge看起来不太简洁。 </li>
<li>最终结果是都把代码合起来了，所以具体怎么使用这两个命令看项目需要。</li>
</ol>
<p>还有一点说明的是，在项目中经常使用git pull来拉取代码，git pull相当于是git fetch + git merge，如果此时运行git pull -r，也就是git pull –rebase，相当于git fetch + git rebase</p>
]]></content>
      <categories>
        <category>面试笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>面试笔记</tag>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>非诚勿扰——程序员专场</title>
    <url>/2020/06/22/%E9%9D%9E%E8%AF%9A%E5%8B%BF%E6%89%B0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%93%E5%9C%BA/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/%E9%9D%9E%E8%AF%9A%E5%8B%BF%E6%89%B0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%93%E5%9C%BA/oxj7mm.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">炫彩小镇</div>
</center>
> 本文是本人在Dian团队2019年的年终茶话会写的剧本，并且担任导演，当年该小品以高票当选第一名

<a id="more"></a>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/%E9%9D%9E%E8%AF%9A%E5%8B%BF%E6%89%B0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%93%E5%9C%BA/《非诚勿扰——程序员专场》.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">剧本</div>
</center>]]></content>
      <categories>
        <category>文集及讲座</category>
      </categories>
      <tags>
        <tag>剧本</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu使用ssr</title>
    <url>/2020/06/22/Ubuntu%E4%BD%BF%E7%94%A8ssr/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/06/22/Ubuntu%E4%BD%BF%E7%94%A8ssr/n6r6m7.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">深邃眼眸</div>
</center>

<h4 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h4><p>下载electron-ssr</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;shadowsocksrr&#x2F;electron-ssr&#x2F;releases</span><br></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i &lt;包名&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="二、配置终端"><a href="#二、配置终端" class="headerlink" title="二、配置终端"></a>二、配置终端</h4><p>先点击图标启动electron-ssr，将自己的ssr配置添加进去</p>
<p>终端临时走ssr需配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ export http_proxy&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:12333&quot;</span><br><span class="line">$ export https_proxy&#x3D;&quot;https:&#x2F;&#x2F;127.0.0.1:12333&quot;</span><br></pre></td></tr></table></figure>
<p>检测是否可以翻墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -i www.google.com</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
