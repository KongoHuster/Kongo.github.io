---
title: 安卓面试笔记
date: 2020-06-22 15:36:58
categories: 面试笔记
tags:
- 面试笔记
- Android
---

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="./安卓面试笔记/438yjy.jpg">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">林间小格</div>
</center>

> 本科面试笔记

<!-- more -->
### 一、四大组件问题

#### 1.四大组件是什么
1）Activity：用户可操作的可视化界面，为用户提供一个完成操作指令的窗口。一个 Activity 通常是一个单独的屏幕，Activity 通过 Intent 来进行通信。Android 中会维持一个 Activity Stack， 当一个新 Activity 创建时，它就会放到栈顶，这个 Activity 就处于运行状态。 

2）Service：服务，运行在手机后台，适合执行不需和用户交互且还需长期运行的任务。 

3）ContentProvider：内容提供者，使一个应用程序的指定数据集提供给其他应用程序，其 他应用可通过 ContentResolver 类从该内容提供者中获取或存入数据。它提供了一种跨进程 数据共享的方式，当数据被修改后，ContentResolver 接口的 notifyChange 函数通知那些注册 监控特定 URI 的 ContentObserver 对象。

4）Broadcast Receiver: 广播接收者，运用在应用程序间传输信息，可以使用广播接收器来让 应用对一个外部事件做出响应。

#### 2.Activity生命周期和简单用法
Activity：onCreate()->onStart()->onResume()->onPause()->onStop()->onDestory() 

onCreate()：为 Activity 设置布局，此时界面还不可见；

onStart(): Activity 可见但还不能与用户交互，不能获得焦点 

onRestart(): 重新启动 Activity 时被回调 

onResume(): Activity 可见且可与用户进行交互 

onPause(): 当前 Activity 暂停，不可与用户交互，但还可见。在新 Activity 启动前被系统调用 保存现有的 Activity 中的持久数据、停止动画等。 

onStop(): 当 Activity 被新的 Activity 覆盖不可见时被系统调用 onDestory(): 当 Activity 被系统销毁杀掉或是由于内存不足时调用

onDestory(): 当 Activity 被系统销毁杀掉或是由于内存不足时调用

#### 3.Service生命周期和简单用法

a) onBind 方式绑定的：onCreate->onBind->onUnBind->onDestory（不管调用 bindService 几次，
onCreate 只会调用一次，onStart 不会被调用，建立连接后，service 会一直运行，直到调用 unBindService 或是之前调用的 bindService 的 Context 不存在了，系统会自动停止 Service,对 应的 onDestory 会被调用） 

b) startService 启动的：onCreate->onStartCommand->onDestory(start 多次，onCreate 只会被 调用一次，onStart会调用多次，该 service 会在后台运行，直至被调用stopService 或是stopSelf) 

c) 又被启动又被绑定的服务，不管如何调用 onCreate()只被调用一次，startService 调用多少 次，onStart 就会被调用多少次，而 unbindService 不会停止服务，必须调用 stopService 或是 stopSelf 来停止服务。必须 unbindService 和 stopService(stopSelf）同时都调用了才会停止服 务。

#### 4.BroadcastReceiver 生命周期和简单用法

a) 动态注册：存活周期是在 Context.registerReceiver 和 Context.unregisterReceiver 之间， BroadcastReceiver 每次收到广播都是使用注册传入的对象处理的。 

b) 静态注册：进程在的情况下，receiver 会正常收到广播，调用 onReceive 方法；生命周期 只存活在 onReceive 函数中，此方法结束，BroadcastReceiver 就销毁了。onReceive()只有十 几秒存活时间，在 onReceive()内操作超过 10S，就会报 ANR。 


---
动态注册广播与静态注册广播的区别

（1）动态注册广播不是常驻型广播，也就是说广播跟随Activity的生命周期。注意在Activity结束前，移除广播接收器。

静态注册是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。

（2）当广播为有序广播时：优先级高的先接收（不分静态和动态）。同优先级的广播接收器，动态优先于静态

（3）同优先级的同类广播接收器，静态：先扫描的优先于后扫描的，动态：先注册的优先于后注册的。

（4）当广播为默认广播时：无视优先级，动态广播接收器优先于静态广播接收器。同优先级的同类广播接收器，静态：先扫描的优先于后扫描的，动态：先注册的优先于后册的。



#### 5.ContentProvider 生命周期和简单用法
ContentProvider：应该和应用的生命周期一样，它属于系统应用，应用启动时，它会跟着初始化，应用关闭或被杀，它会跟着结束。

#### 6.Activity 之间的通信方式 
1）通过 Intent 方式传递参数跳转 

2）通过广播方式 

3）通过接口回调方式 

4）借助类的静态变量或全局变量 

5）借助 SharedPreference或是外部存储，如数据库或本地文件

#### 7.Activity 各种情况下的生命周期 

1. 两 个 Activity(A->B) 切 换 (B 正 常 的 Activity) 的 生 命 周 期 ： onPause(A)->onCreate(B)->onStart(B)->onResume(B)->oStop(A) 这时如果按回退键回退到 A onPause(B)->onRestart(A)->onStart(A)->onResume(A)->oStop(B)
如果在切换到 B 后调用了 A.finish()，则会走到 onDestory(A)，这时点回退键会退出应用 

2) 两个 Activity(A->B)切换(B 透明主题的 Activity 或是 Dialog 风格的 Acivity)的生命周期： onPause(A)->onCreate(B)->onStart(B)->onResume(B) 这时如果回退到 A onPause(B)->onResume(A)->oStop(B)->onDestory(B) 

3) Activity(A) 启 动 后 点 击 Home 键 再 回 到 应 用 的 生 命 周 期 ： onPause(A)->oStop(A)->onRestart(A)->onStart(A)->onResume(A)

4) Activity 上有 Dialog 的时候, Dialog 并不会影响 Activity 的生命周期
#### 8.横竖屏切换的时候，Activity 各种情况下的生命周期 

1. 切换横屏时 ： onSaveInstanceState->onPause->onStop->onDestory->onCreate->onStart->onRestoreInstanceSta te->onResume 

2) 切换竖屏时：会打印两次相同的log onSaveInstanceState->onPause->onStop->onDestory->onCreate->onStart->onRestoreInstanceSta te->onResume->onSaveInstanceState->onPause->onStop->onDestory->onCreate->onStart->onRe storeInstanceState->onResume 

3) 如 果 在 AndroidMainfest.xml 中 修 改 该 Activity 的 属 性 ， 添 加 android:configChanges="orientation" 横竖屏切换，打印的 log 一样，同 1) 

#### 9.Fragment 生命周期 
- Fragment 生命周期 :onAttach->onCreate->onCreateView->onActivityCreated->onStart->onResume->onPause->onStop->onDestoryView->onDestory->onDetach 
- 切换到该Fragment ： onAttach->onCreate->onCreateView->onActivityCreated->onStart->onResume 
- 按下Power键：onPause->onSaveInstanceState->onStop 
- 点亮屏幕解锁：onStart->onRestoreInstanceState->onResume 
- 切换到其他 Fragment:onPause->onStop->onDestoryView
- 切回到该Fragment: onCreateView->onActivityCreated->onStart->onResume 
- 退出应用：onPause->onStop->onDestoryView->onDestory->onDetach


---

Fragment与Activity生命周期关系

![GpCAh9.png](https://s1.ax1x.com/2020/03/26/GpCAh9.png)

#### 10.Activity 的四种启动模式对比
1. standard：标准启动模式（默认），每启动一次 Activity，都会创建一个实例，即使从 ActivityA startActivity ActivityA,也会再次创建 A 的实例放于栈顶，当回退时，回到上一个 ActivityA 的 实例。 
2) singleTop：栈顶复用模式，每次启动 Activity，如果待启动的 Activity 位于栈顶，则不会重 新 创 建 Activity 的 实 例 ， 即 不 会 走 onCreate->onStart ， 会 直 接 进 入 Activity 的 onPause->onNewIntent->onResume 方法 
3) singleInstance: 单一实例模式，整个手机操作系统里只有一个该 Activity 实例存在，没有 其 他 Actvity,后 续 请 求 均 不 会 创 建 新 的 Activity 。 若 task 中 存 在 实 例 ， 执 行 实 例 的 onNewIntent()。应用场景：闹钟、浏览器、电话 
4) singleTask：栈内复用，启动的 Activity 如果在指定的 taskAffinity 的 task 栈中存在相应的实 例，则会把它上面的 Activity 都出栈，直到当前 Activity 实例位于栈顶，执行相应的 onNewIntent()方法。如果指定的 task 不存在，创建指定的 taskAffinity 的 task,taskAffinity 的 作用，进入指写 taskAffinity 的 task,如果指定的 task 存在，将 task 移到前台，如果指定的 task 不存在，创建指定的 taskAffinity 的 task. 应用场景：应用的主页面

#### 11.说说 ContentProvider、ContentResolver、ContentObserver 之间的关系 
ContentProvider实现各个应用程序间数据共享，用来提供内容给别的应用操作。如联系人应用中就使用了ContentProvider，可以在自己应用中读取和修改联系人信息，不过需要获取相应的权限。它也只是一个中间件，真正的数据源是文件或SQLite等。

ContentResolver内容解析者 ， 用于获取内容提供者提供的数据 ，通过ContentResolver.notifyChange(uri)发出消息 

ContentObserver内容监听者，可以监听数据的改变状态，观察特定 Uri 引起的数据库变化， 继而做一些相应的处理，类似于数据库中的触发器，当 ContentObserver 所观察的 Uri 发生 变化时，便会触发它。

#### 12.下广播 BroadcastReceiver 的理解 
- BroadcastReceiver 是一种全局监听器，用来实现系统中不同组件之间的通信。

- 有时候也会用 来作为传输少量而且发送频率低的数据，但是如果数据的发送频率比较高或者数量比较大就 不建议用广播接收者来接收了，因为这样的效率很不好，因为 BroadcastReceiver 接收数据的 开销还是比较大的。


#### 13.如何实现 Fragment 的滑动？
ViewPager+FragmentPagerAdapter+List<Fragment>

#### 14.fragment 之间传递数据的方式？ 
1) 在相应的 fragment 中编写方法，在需要回调的 fragment 里获取对应的 Fragment 实例，调 用相应的方法； 

2. 采用接口回调的方式进行数据传递； 

- a) 在 Fragment1中创建一个接口及接口对应的set 方法; 
- b) 在Fragment1 中调用接口的方法； 
- c)在 Fragment2 中实现该接口； 

3）利用第三方开源框架 EventBus


#### 15.service 和 activity 怎么进行数据交互？ 

1）通过 bindService 启动服务，可以在 ServiceConnection 的 onServiceConnected 中获取到 Service 的实例，这样就可以调用 service 的方法，如果 service 想调用 activity 的方法，可以 在 service 中定义接口类及相应的 set 方法，在activity中实现相应的接口，这样 service 就可 以回调接口言法； 

2）通过广播方式

#### 16.在 manifest 和代码中如何注册和使用 BroadcastReceiver? 

1）mainfest 中注册:静态注册的广播接收者就是一个常驻在系统中的全局监听器，也就是说 如果你应用中配置了一个静态的 BroadcastReceiver，而且你安装了应用而无论应用是否处于 运行状态，广播接收者都是已经常驻在系统中了。
```
<receiver android:name=".MyBroadcastReceiver"> 
    <intent-filter> 
        <action android:name="com.smilexie.test.intent.mybroadcastreceiver"/> 
    </intent-filter> 
</receiver> 
```
2) 动态注册:动态注册的广播接收者只有执行了 registerReceiver(receiver, filter)才会开始监听 广播消息，并对广播消息作为相应的处理。 
```
IntentFilter fiter = new IntentFilter("com.smilexie.test.intent.mybroadcastreceiver"); 
MyBroadcastReceiver receiver = new MyBroadcastReceiver(); 
registerReceiver(receiver, filter); 
```
```
//撤销广播接受者的动态注册 unregisterReceiver(receiver);
```

#### 17.AlertDialog,popupWindow区别
（1）Popupwindow 在显示之前一定要设置宽高，Dialog 无此限制。 

（2）Popupwindow 默认不会响应物理键盘的 back，除非显示设置了 popup.setFocusable(true); 而在点击 back 的时候，Dialog 会消失。

（3）Popupwindow 不会给页面其他的部分添加蒙层，而Dialog 会。  

（4） Popupwindow 没有标题 ， Dialog 默认有标 题 ， 可以通过 dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);取消标题 

（5）二者显示的时候都要设置 Gravity。如果不设置，Dialog 默认是 Gravity.CENTER。

#### 18.HttpClient 与 HttpUrlConnection 的区别 
- 首先 HttpClient 和 HttpUrlConnection 这两种方式都支持 Https 协议，都是以流的形式进行上
传或者下载数据，也可以说是以流的形式进行数据的传输，还有 ipv6,以及连接池等功能。 

- HttpClient 这个拥有非常多的 API，所以如果想要进行扩展的话，并且不破坏它的兼容性的话， 很难进行扩展，也就是这个原因，Google 在 Android6.0 的时候，直接就弃用了这个 HttpClient. 

- 而HttpUrlConnection 相对来说就是比较轻量级了，API 比较少，容易扩展，并且能够满足 Android 大部分的数据传输。比较经典的一个框架 volley，在 2.3 版本以前都是使用 HttpClient, 在 2.3 以后就使用了 HttpUrlConnection。

#### 19.java 虚拟机和 Dalvik 虚拟机的区别

Java 虚拟机： 

- 1、java 虚拟机基于栈。 基于栈的机器必须使用指令来载入和操作栈上数据，所需指令更多。

- 2、java 虚拟机运行的是 java 字节码。（java 类会被编译成一个或多个字节码.class 文件） 

Dalvik 虚拟机： 

- 1、dalvik 虚拟机是基于寄存器的 

- 2、Dalvik 运行的是自定义的.dex 字节码格式。（java 类被编译成.class 文件后，会通过一个 dx 工具将所有的.class 文件转换成一个.dex 文件，然后 dalvik 虚拟机会从其中读取指令和数 据

- 3、常量池已被修改为只使用 32 位的索引，以 简化解释器。

- 4、一个应用，一个虚拟机实例，一个进程（所有 android 应用的线程都是对应一个 linux 线 程，都运行在自己的沙盒中，不同的应用在不同的进程中运行。每个 android dalvik 应用程 序都被赋予了一个独立的 linux PID(app_*)

#### 20.进程保活

当前业界的 Android 进程保活手段主要分为黑、白、灰三种，其大致的实现思路如下： 

1. 黑色保活：不同的 app 进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒） 
```
所谓黑色保活，就是利用不同的 app 进程使用广播来进行相互唤醒。

举个3个比较常见的场景：
1：开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒 app 场景 

2：接入第三方 SDK 也会唤醒相应的 app 进程，如微信 sdk 会唤醒微信，支付宝 sdk 会 唤醒支付宝。由此发散开去，就会直接触发了下面的场景3场景 

3：假如你手机里装了支付宝、淘宝、天猫、UC 等阿里系的 app，那么你打开任意一个阿里系的 app 后，有可能就顺便把其他阿里系的 app 给唤醒了。（只是拿阿里打个比方，其实BAT系都差不多）
```


2. 白色保活：启动前台 Service
```
白色保活手段非常简单，就是调用系统 api 启动一个前台的 Service 进程，这样会在系统的 通知栏生成一个 Notification，用来让用户知道有这样一个 app 在运行着，哪怕当前的 app 退到了后台。
```

3. 灰色保活：利用系统的漏洞启动前台 Service
```
灰色保活，这种保活手段是应用范围最广泛。它是利用系统的漏洞来启动一个前台的 Service 进程，与普通的启动方式区别在于，它不会在系统通知栏处出现一个 Notification，看起来就 
如同运行着一个后台 Service 进程一样。这样做带来的好处就是，用户无法察觉到你运行着 一个前台进程（因为看不到 Notification）,但你的进程优先级又是高于普通后台
进程的。那 么如何利用系统的漏洞呢，大致的实现思路和代码如下： 

思路一：API < 18，启动前台 Service 时直接传入 new Notification()； 

思路二：API >= 18，同时启动两个 id 相同的前台 Service，然后再将后启动的 Service 做 stop 处理
```

#### 21.什么是 oom_adj？
概念
- 它是 linux 内核分配给 每个系统进程的一个值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收。

对于 oom_adj 的作用，你只需要记住以下几点即可： 
- 进程的 oom_adj 越大，表示此进程优先级越低，越容易被杀回收；越小，表示进程优先级 越高，越不容易被杀回收 
- 普通 app 进程的 oom_adj>=0,系统进程的 oom_adj 才可能<0 
- 有些手机厂商把这些知名的 app 放入了自己的白名单中，保证了进程不死来提高用户体验 （如微信、QQ、陌陌都在小米的白名单中）。如果从白名单中移除，他们终究还是和普通 app 一样躲避不了被杀的命运，为了尽量避免被杀，还是老老实实去做好优化工作吧。 
- 所以，进程保活的根本方案终究还是回到了性能优化上，进程永生不死终究是个彻头彻尾的 伪命题！

#### 22.讲解一下 Context
- Context 是一个抽象基类。在翻译为上下文，也可以理解为环境，是提供一些程序的运行环境基础信息。
- Context 下有两个子类，ContextWrapper 是上下文功能的封装类，而 ContextImpl 则是上下文功能的实现类。而ContextWrapper又有三个直接的子类，ContextThemeWrapper、 Service 和 Application。
- Context 一共有三种类型，分别是 Application、Activity 和 Service。这三个类虽然分别各种承担着不同的作用，但它们都属于 Context 的一种，而它 们具体 Context 的功能则是由 ContextImpl 类去实现的，因此在绝大多数场景下，Activity、 Service 和 Application 这三种类型的 Context 都是可以通用的。
- Context 一共有三种类型，分别是 Application、Activity 和 Service。这三个类虽然分别各种承担着不同的作用，但它们都属于 Context 的一种，而它 们具体 Context 的功能则是由 ContextImpl 类去实现的，因此在绝大多数场景下，Activity、 Service 和 Application 这三种类型的 Context 都是可以通用的。
- getApplicationContext()和 getApplication()方法得到的对象都是同一个 application 对象，只是 对象的类型不一样。
- Context 数量 = Activity 数量 + Service 数量 + 1 （1 为 Application）

#### 23.理解 Activity，View, Window 三者关系

Activity 像一个工匠（控制单元），Window 像窗户（承载模型），View 像窗花（显示视图） LayoutInflater 像剪刀，Xml 配置像窗花图纸。 

1：Activity 构造的时候会初始化一个 Window，准确的说是 PhoneWindow。

2：这个 PhoneWindow 有一个“ViewRoot”，这个“ViewRoot”是一个 View 或者说 ViewGroup， 是最初始的根视图。 

3：“ViewRoot”通过 addView 方法来一个个的添加 View。比如 TextView，Button 等。

4：这些 View 的事件监听，是由 Window完成的。

#### 24.View 的绘制流程

View 的绘制流程：OnMeasure()——>OnLayout()——>OnDraw() 

第一步：OnMeasure()：测量视图大小。从顶层父 View 到子 View 递归调用 measure 方法， measure 方法又回调 OnMeasure。 

第二步：OnLayout()：确定 View 位置，进行页面布局。从顶层父 View 向子 View 的递归调用 view.layout 方法的过程，即父 View 根据上一步 measure 子 View 所得到的布局大小和布局参 数，将子 View 放在合适的位置上。 

第三步：OnDraw()：绘制视图。ViewRoot 创建一个 Canvas 对象，然后调用 OnDraw()。六个 步骤：

①、绘制视图的背景；

②、保存画布的图层（Layer）；

③、绘制 View 的内容；

④、绘制 View 子视图，如果没有就不用；

⑤、还原图层（Layer）；

⑥、绘制滚动条。

#### 25.View，ViewGroup 事件分发 

1. Touch 事件分发中只有两个主角:ViewGroup 和 View。ViewGroup 包含 onInterceptTouchEvent、 dispatchTouchEvent、onTouchEvent 三个相关事件。View 包含 dispatchTouchEvent、onTouchEvent 两个相关事件。其中 ViewGroup 又继承于 View。 

2. ViewGroup 和 View 组成了一个树状结构，根节点为 Activity 内部包含的一个 ViwGroup。

3. 触摸事件由 Action_Down、Action_Move、Aciton_UP 组成，其中一次完整的触摸事件中， Down 和 Up 都只有一个，Move 有若干个，可以为 0 个。 

4. 当 Acitivty 接收到 Touch 事件时，将遍历子 View 进行 Down 事件的分发。ViewGroup 的遍 历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的 View，这个 View 会在 onTouchuEvent 结果返回 true。 

5. 当某个子 View 返回 true 时，会中止 Down 事件的分发，同时在 ViewGroup 中记录该子 View。 接下去的 Move 和 Up 事件将由该子 View 直接进行处理。由于子 View 是保存在 ViewGroup 中的，多层 ViewGroup 的节点结构时，上级 ViewGroup 保存的会是真实处理事件的 View 所 在的 ViewGroup 对象:如 ViewGroup0-ViewGroup1-TextView 的结构中，TextView 返回了 true，
它将被保存在 ViewGroup1 中，而 ViewGroup1 也会返回 true，被保存在 ViewGroup0 中。当 Move 和 UP 事件来时，会先从 ViewGroup0 传递至 ViewGroup1，再由 ViewGroup1 传递至 TextView。 

6. 当 ViewGroup 中所有子 View 都不捕获 Down 事件时，将触发 ViewGroup 自身的 onTouch 事件。触发的方式是调用 super.dispatchTouchEvent 函数，即父类 View 的 dispatchTouchEvent 方法。在所有子 View 都不处理的情况下，触发 Acitivity 的 onTouchEvent 方法。 

7. onInterceptTouchEvent 有两个作用：1.拦截 Down 事件的分发。2.中止 Up 和 Move 事件向 目标 View 传递，使得目标 View 所在的 ViewGroup 捕获 Up 和 Move 事件。

#### 26.Android 中的几种动画 

帧动画：指通过指定每一帧的图片和播放时间，有序的进行播放而形成动画效果，比如想听 的律动条。 

补间动画：指通过指定 View 的初始状态、变化时间、方式，通过一系列的算法去进行图形 变换，从而形成动画效果，主要有 Alpha、Scale、Translate、Rotate 四种效果。注意：只是 在视图层实现了动画效果，并没有真正改变 View 的属性，比如滑动列表，改变标题栏的透 明度。 

属性动画：在 Android3.0 的时候才支持，通过不断的改变 View 的属性，不断的重绘而形成 动画效果。相比于视图动画，View 的属性是真正改变了。比如 view 的旋转，放大，缩小。

#### 27.Android 中跨进程通讯的几种方式

- intent：这种跨进程方式并不是访问内存的形式，它需要传递一个 uri,比如说打电话。 

- contentProvider：这种形式，是使用数据共享的形式进行数据共享。 

- service：远程服务，aidl

- 广播

#### 28.AIDL 理解

AIDL: 每一个进程都有自己的 Dalvik VM 实例，都有自己的一块独立的内存，都在自己的内 存上存储自己的数据，执行着自己的操作，都在自己的那片狭小的空间里过完自己的一生。

而 aidl 就类似与两个进程之间的桥梁，使得两个进程之间可以进行数据的传输，跨进程通信 有多种选择，比如 BroadcastReceiver , Messenger 等，但是 BroadcastReceiver 占用的系统 资源比较多，如果是频繁的跨进程通信的话显然是不可取的；Messenger 进行跨进程通信时 请求队列是同步进行的，无法并发执行。

#### 29.Binder 机制简单理解

在 Android 系统的 Binder 机制中，是有Client,Service,ServiceManager,Binder 驱动程序组成的， 其中 Client，service，Service Manager 运行在用户空间，Binder 驱动程序是运行在内核空间 的。而 Binder 就是把这 4 种组件粘合在一块的粘合剂，其中核心的组件就是 Binder 驱动程 序，Service Manager 提供辅助管理的功能，而 Client 和 Service 正是在 Binder 驱动程序和 Service Manager 提供的基础设施上实现 C/S 之间的通信。其中 Binder 驱动程序提供设备文 件/dev/binder 与用户控件进行交互


Client、Service，Service Manager 通过 open 和 ioctl 文件操作相应的方法与 Binder 驱动程序 进行通信。而Client和Service之间的进程间通信是通过Binder驱动程序间接实现的。而Binder Manager 是一个守护进程，用来管理 Service，并向 Client 提供查询 Service 接口的能力。

#### 30.Handler 的原理

Android 中主线程是不能进行耗时操作的，子线程是不能进行更新 UI 的。所以就有了 handler， 它的作用就是实现线程之间的通信。


handler 整个流程中，主要有四个对象，handler，Message,MessageQueue,Looper。当应用创 建的时候，就会在主线程中创建 handler 对象， 

我们通过要传送的消息保存到 Message 中，handler 通过调用 sendMessage 方法将 Message 发送到 MessageQueue 中，Looper 对象就会不断的调用 loop()方法 

不断的从 MessageQueue 中取出 Message 交给 handler 进行处理。从而实现线程之间的通信。

#### 31.热修复的原理 

我们知道 Java 虚拟机 —— JVM 是加载类的 class 文件的，而 Android 虚拟机——Dalvik/ART VM 是加载类的 dex 文件， 而他们加载类的时候都需要 ClassLoader,ClassLoader 有一个子类 BaseDexClassLoader，而 BaseDexClassLoader 下有一个 数组——DexPathList，是用来存放 dex 文件，当 BaseDexClassLoader 通过调用 findClass 方法 时，实际上就是遍历数组， 找到相应的 dex 文件，找到，则直接将它 return。

而热修复的解决方法就是将新的 dex 添加 到该集合中，并且是在旧的 dex 的前面， 所以就会优先被取出来并且 return 返回。

#### 32.内存泄露原因
一、Handler 引起的内存泄漏。 

解决：将 Handler 声明为静态内部类，就不会持有外部类 SecondActivity 的引用，其生命周 期就和外部类无关， 如果 Handler 里面需要 context 的话，可以通过弱引用方式引用外部类 

二、单例模式引起的内存泄漏。 

- 解决：Context 是 ApplicationContext，由于 ApplicationContext 的生命周期是和 app 一致的， 不会导致内存泄漏 

三、非静态内部类创建静态实例引起的内存泄漏。 

- 解决：把内部类修改为静态的就可以避免内存泄漏了 

四、非静态匿名内部类引起的内存泄漏。

- 解决：将匿名内部类设置为静态的。 

五、注册/反注册未成对使用引起的内存泄漏。 

- 注册广播接受器、EventBus 等，记得解绑。 

六、资源对象没有关闭引起的内存泄漏。 

- 在这些资源不使用的时候，记得调用相应的类似 close（）、destroy（）、recycler（）、release （）等方法释放。 

七、集合对象没有及时清理引起的内存泄漏。 

- 通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不 再被引用。

#### 33.Android UI 适配 

字体使用 sp,使用 dp，多使用 match_parent，wrap_content，weight 

图片资源，不同图片的的分辨率，放在相应的文件夹下可使用百分比代替。

#### 34.App 启动优化(针对冷启动) App 
启动的方式有三种： 

1. 冷启动：App 没有启动过或 App 进程被 killed, 系统中不存在该 App 进程, 此时启动 App 即 为冷启动。 
2. 热启动：热启动意味着你的 App 进程只是处于后台, 系统只是将其从后台带到前台, 展示给 用户。
3. 介于冷启动和热启动之间, 一般来说在以下两种情况下发生: 
- (1)用户 back 退出了 App, 然后又启动. App 进程可能还在运行, 但是 activity 需要重建。 
- (2)用户退出 App 后, 系统可能由于内存原因将 App 杀死, 进程和 activity 都需要重启, 但是 可以在 onCreate 中将被动杀死锁保存的状态(saved instance state)恢复。

#### 35.ANR
概念 
- ANR 全名 Application Not Responding, 也就是"应用无响应". 当操作在一段时间内系统无法 处理时, 系统层面会弹出上图那样的 ANR 对话框.

解决方式：

(1)不要在主线程中做耗时的操作，而应放在子线程中来实现。如 onCreate()和 onResume() 里尽可能少的去做创建操作。 

(2)应用程序应该避免在 BroadcastReceiver 里做耗时的操作或计算。

(3)避免在 Intent Receiver 里启动一个 Activity，因为它会创建一个新的画面，并从当前用户正 在运行的程序上抢夺焦点。 

(4)service 是运行在主线程的，所以在 service 中做耗时操作，必须要放在子线程中。

#### 36.MVC，MVP，MVVM

[![8rgdgK.md.png](https://s1.ax1x.com/2020/03/19/8rgdgK.md.png)](https://imgchr.com/i/8rgdgK)

MVC：PC时代就有的架构方案，在Android上也是最早的方案，Activity/Fragment这些上帝角色既承担了V的角色，也承担了C的角色，小项目开发起来十分顺手，大项目就会遇到
耦合过重，Activity/Fragment类过大等问题。

MVP：为了解决MVC耦合过重的问题，MVP的核心思想就是提供一个Presenter将视图逻辑I和业务逻辑相分离，达到解耦的目的。

MVVM：使用ViewModel代替Presenter，实现数据与View的双向绑定，这套框架最早使用的data-binding将数据绑定到xml里，这么做在大规模应用的时候是不行的，不过数据绑定是一个很有用的概念，后续Google又推出了ViewModel组件与LiveData组件。ViewModel组件规范了ViewModel所处的地位、生命周期、生产方式以及一个Activity下多个Fragment共享ViewModel数据的问题。LiveData组件则提供了在Java层面View订阅ViewModel数据源的实现方案。

#### 37.Glide 的理解

1. 不仅仅可以进行图片缓存还可以缓存媒体文件。Glide 不仅是一个图片缓存，它支持 Gif、 WebP、缩略图。甚至是 Video，所以更该当做一个媒体缓存。

2. 支持优先级处理。 

3. 与 Activity/Fragment 生命周期一致，支持 trimMemory。Glide 对每个 context 都保持一 个 RequestManager，通过 FragmentTransaction 保持与 Activity/Fragment 生命周期一致， 并且有对应的 trimMemory 接口实现可供调用。 

4. 支持 okhttp、Volley。Glide 默认通过 UrlConnection 获取数据，可以配合 okhttp 或是 Volley 使用。实际 ImageLoader、Picasso 也都支持 okhttp、Volley。

#### 38.Xutils, OKhttp, Volley, Retrofit 对比

Xutils 这个框架非常全面，可以进行网络请求，可以进行图片加载处理，可以数据储存，还 可以对 view 进行注解，使用这个框架非常方便，但是缺点也是非常明显的，使用这个项目， 会导致项目对这个框架依赖非常的严重，一旦这个框架出现问题，那么对项目来说影响非常 大的。

OKhttp ： Android 开发中是可以直接使用现成的 api 进 行 网 络请求 的 。 就 是 使 用 HttpClient,HttpUrlConnection 进行操作。okhttp 针对 Java 和 Android 程序，封装的一个高性 能的 http 请求库，支持同步，异步，而且 okhttp 又封装了线程池，封装了数据转换，封装 了参数的使用，错误处理等。API 使用起来更加的方便。但是我们在项目中使用的时候仍然 需要自己在做一层封装，这样才能使用的更加的顺手。 


Volley：Volley 是 Google 官方出的一套小而巧的异步请求库，该框架封装的扩展性很强，支 持 HttpClient、HttpUrlConnection，甚至支持 OkHttp，而且 Volley 里面也封装了 ImageLoader， 所以如果你愿意你甚至不需要使用图片加载框架，不过这块功能没有一些专门的图片加载框 架强大，对于简单的需求可以使用，稍复杂点的需求还是需要用到专门的图片加载框架。 Volley 也有缺陷，比如不支持 post 大数据，所以不适合上传文件。不过 Volley 设计的初衷本 身也就是为频繁的、数据量小的网络请求而生。 


Retrofit：Retrofit 是 Square 公司出品的默认基于 OkHttp 封装的一套 RESTful 网络请求框架， RESTful 是目前流行的一套 api 设计的风格， 并不是标准。Retrofit 的封装可以说是很强大， 里面涉及到一堆的设计模式,可以通过注解直接配置请求，可以使用不同的 http 客户端，虽 然默认是用 http ，可以使用不同 Json Converter 来序列化数据，同时提供对 RxJava 的支持， 使用 Retrofit + OkHttp + RxJava + Dagger2 可以说是目前比较潮的一套框架，但是需要有比较 高的门槛。


Volley VS OkHttp 

Volley 的优势在于封装的更好，而使用 OkHttp 你需要有足够的能力再进行一次封装。而 OkHttp 的优势在于性能更高，因为 OkHttp 基于 NIO 和 Okio ，所以性能上要比 Volley 更快。 IO 和 NIO 这两个都是 Java 中的概念，如果我从硬盘读取数据，第一种方式就是程序一直等， 数据读完后才能继续操作这种是最简单的也叫阻塞式 IO,还有一种是你读你的,程序接着往下 执行，等数据处理完你再来通知我，然后再处理回调。而第二种就是 NIO 的方式，非阻塞 式， 所以 NIO 当然要比 IO 的性能要好了,而 Okio 是 Square 公司基于 IO 和 NIO 基础上做 的一个更简单、高效处理数据流的一个库。理论上如果 Volley 和 OkHttp 对比的话，更倾向 于使用 Volley，因为 Volley 内部同样支持使用 OkHttp,这点 OkHttp 的性能优势就没了， 而 且 Volley 本身封装的也更易用，扩展性更好些。

#### 39.Android中的动画有哪些
逐帧动画(Frame Animation)

- 加载一系列Drawable资源来创建动画，简单来说就是播放一系列的图片来实现动画效果，可以自定义每张图片的持续时间

补间动画(Tween Animation)

- Tween可以对View对象实现一系列动画效果，比如平移，缩放，旋转，透明度等。但是它并不会改变View属性的值，只是改变了View的绘制的位置，比如，一个按钮在动画过后，不在原来的位置，但是触发点击事件的仍然是原来的坐标。

属性动画(Property Animation)

- 动画的对象除了传统的View对象，还可以是Object对象，动画结束后，Object对象的属性值被实实在在的改变了

#### 40.synchronized和lock的区别？
synchronized会主动释放锁，而lock需要手动调用unlock释放锁；

synchronized是java内置的关键字，而lock是个java类；

#### 41.开发过程中如果想替换第三方jar中的某个class文件，或者在开发时你的class文件与jar中的重名，但是你想使用自己的应该如何解决？如果你替换掉某个方法又该怎么解决？
方式一：可以获取到jar的源码或者将jar反编译获取到java项目，然后替换掉自己想要的.java文件或者方法；

方式二：可以通过类加载器将目标class替换成自己的class；

#### 42.IO与NIO的区别？
第一点：IO是面向流的，NIO是面向缓冲区的。

IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。

NIO是面向缓存的。数据读取到一个缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且要确保当更多的数据读入缓冲区时，不要覆盖缓冲区中未处理的数据。

第二点：IO的各种流是阻塞的。

这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情。NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，在数据可读之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

#### 43.单例模式有几种写法以及各自的优劣？
1.饿汉式：

缺点：存在内存损耗问题，如果当前类没有用到也会被实例化

```
public class SingleInstance {
    
    private static SingleInstance mInstance = new SingleInstance();
    
    private SingleInstance(){}
    
    public static SingleInstance getInstance(){
        return mInstance;
    }
}
```
2.懒汉式：

缺点：加了synchronized锁会影响性能
有次被问到为什么要有两次空判断？

第一次空判断和好理解，可以很大程度上减少锁机制的次数；

第二次判空是因为，如果a，b两个线程都到了synchronized处，而假设a拿到了锁，进入到代码块中创建了对象，然后释放了锁，由于b线程在等待锁，所以a释放后，会被b拿到，因此此时判空就保证了实例的唯一性。

```
public class SingleInstance {

    private static SingleInstance mInstance = null;

    private SingleInstance(){}

    public static SingleInstance getInstance(){
        if(mInstance==null){
            synchronized (SingleInstance.class){
                if(mInstance==null){
                    mInstance = new SingleInstance();
                }
            }
        }
        return mInstance;
    }
}
```

#### 44.自定义View的基本流程
①.自定义View的属性 编写attr.xml文件

②.在layout布局文件中引用，同时引用命名空间

③.在View的构造方法中获得我们自定义的属性 ，在自定义控件中进行读取（构造方法拿到attr.xml文件值）

④.重写onMesure

⑥.重写onDraw

#### 45.三级缓存(这个偶尔会问)
网络加载，不优先加载，速度慢，浪费流量

本地缓存，次优先加载，速度快

内存缓存，优先加载，速度最快

首次加载Android App时，肯定要通过网络交互来获取图片，之后我们可以将图片保存至本地SD卡和内存中，之后运行APP时，优先访问内存中的图片缓存，若内存中没有，则加载本地SD卡中图片，最后选择访问网络

#### 46.内存泄露原因以及解决
一、Handler 引起的内存泄漏。

解决：将Handler声明为静态内部类，就不会持有外部类SecondActivity的引用，其生命周期就和外部类无关，

如果Handler里面需要context的话，可以通过弱引用方式引用外部类

二、单例模式引起的内存泄漏。

解决：Context是ApplicationContext，由于ApplicationContext的生命周期是和app一致的，不会导致内存泄漏

三、非静态内部类创建静态实例引起的内存泄漏。

解决：把内部类修改为静态的就可以避免内存泄漏了

四、非静态匿名内部类引起的内存泄漏。

解决：将匿名内部类设置为静态的。

五、注册/反注册未成对使用引起的内存泄漏。

注册广播接受器、EventBus等，记得解绑。

六、资源对象没有关闭引起的内存泄漏。

在这些资源不使用的时候，记得调用相应的类似close（）、destroy（）、recycler（）、release（）等方法释放。

七、集合对象没有及时清理引起的内存泄漏。

通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不再被引用。

#### 47.图片加载框架有哪些？他们之间的区别是什么？
##### ImageLoader ：

优点：

①　支持下载进度监听；

②　可以在 View 滚动中暂停图片加载；

③　默认实现多种内存缓存算法这几个图片缓存都可以配置缓存算法，不过 ImageLoader 默认实现了较多缓存算法，如 Size 最大先删除、使用最少先删除、最近最少使用、先进先删除、时间最长先删除等；

④　支持本地缓存文件名规则定义；

缺点:

缺点在于不支持GIF图片加载, 缓存机制没有和http的缓存很好的结合, 完全是自己的一套缓存机制

##### Picasso：

优点：

①　自带统计监控功能，支持图片缓存使用的监控，包括缓存命中率、已使用内存大小、节省的流量等。

②　支持优先级处理

③　支持延迟到图片尺寸计算完成加载

④　支持飞行模式、并发线程数根据网络类型而变，手机切换到飞行模式或网络类型变换时会自动调整线程池最大并发数。

⑤ “无”本地缓存。Picasso 自己没有实现本地缓存，而由okhttp 去实现，这样的好处是可以通过请求 Response Header 中的 Cache-Control 及 Expired 控制图片的过期时间。

缺点：

于不支持GIF，默认使用ARGB_8888格式缓存图片，缓存体积大。

Glide：

优点：

①　图片缓存->媒体缓存 ，支持 Gif、WebP、缩略图。甚至是 Video。

②　支持优先级处理

③　与 Activity/Fragment 生命周期一致，支持 trimMemory

④　支持 okhttp、Volley。Glide 默认通过 UrlConnection 获取数据，可以配合 okhttp 或是 Volley 使用。实际 ImageLoader、Picasso 也都支持 okhttp、Volley。

⑤　内存友好，内存缓存更小图片，图片默认使用默认 RGB565 而不是 ARGB888

缺点：

清晰度差，但可以设置

##### Fresco：

优点:

①　图片存储在安卓系统的匿名共享内存, 而不是虚拟机的堆内存中,所以不会因为图片加载而导致oom, 同时也减少垃圾回收器频繁调用回收Bitmap导致的界面卡顿,性能更高.

②　渐进式加载JPEG图片, 支持图片从模糊到清晰加载

③　图片可以以任意的中心点显示在ImageView, 而不仅仅是图片的中心.

④ JPEG图片改变大小也是在native进行的, 不是在虚拟机的堆内存, 同样减少OOM

⑤　很好的支持GIF图片的显示

缺点:

框架较大, 影响Apk体积，使用较繁琐

#### 48.ContentProvider、ContentResolver与ContentObserver之间的关系是什么？

ContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、文件、XML、网络等，ContentProvider为这些数据的访问提供了统一的接口，可以用来做进程间数据共享。

ContentResolver：ContentResolver可以不同URI操作不同的ContentProvider中的数据，外部进程可以通过ContentResolver与ContentProvider进行交互。

ContentObserver：观察ContentProvider中的数据变化，并将变化通知给外界。

#### 49.APK的打包流程
1. 通过AAPT工具进行资源文件（包括AndroidManifest.xml、布局文件、各种xml资源等）的打包，生成R.java文件。

2. 通过AIDL工具处理AIDL文件，生成相应的Java文件。

3. 通过Javac工具编译项目源码，生成Class文件。

4. 通过DX工具将所有的Class文件转换成DEX文件，该过程主要完成Java字节码转换成Dalvik字节码，压缩常量池以及清除冗余信息等工作。

5. 通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件。

6. 利用KeyStore对生成的APK文件进行签名。

7. 如果是正式版的APK，还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件
的速度会更快

#### 50.Activity的启动流程
1. 点击桌面应用图标，Launcher进程将启动Activity（MainActivity）的请求以Binder的方式发送给了AMS。

2. AMS接收到启动请求后，交付ActivityStarter处理Intent和Flag等信息，然后再交给ActivityStackSupervisior/ActivityStack
处理Activity进栈相关流程。同时以Socket方式请求Zygote进程fork新进程。

3. Zygote接收到新进程创建请求后fork出新进程。

4. 在新进程里创建ActivityThread对象，新创建的进程就是应用的主线程，在主线程里开启Looper消息循环，开始处理创建Activity。

5. ActivityThread利用ClassLoader去加载Activity、创建Activity实例，并回调Activity的onCreate()方法。这样便完成了Activity的启动。

#### 51.既然有现有的IPC方式，为什么重新设计一套Binder机制呢?

1. 高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。

2. 稳定性：上面说到共享内存的性能优于Binder，那为什么不适用共享内存呢，因为共享内存需要处理并发同步问题，控制负责，容易出现死锁和资源竞争，稳定性较差。而Binder基于C/S架构，客户端与服务端彼此独立，稳定性较好。

3. 安全性：我们知道Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理，包括6.0以前的固定权限和6.0以后的动态权限，传荣IPC只能由用户在数据包里填入UID/PID，这个标记完全是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。

#### 52.Java与C++如何相互调用？

Java调用C++

1. 在Java中声明Native方法（即需要调用的本地方法）

2. 编译上述 Java源文件javac（得到 .class文件）
3. 通过 javah 命令导出JNI的头文件（.h文件）

4. 使用 Java需要交互的本地代码 实现在 Java中声明的Native方法

5. 编译.so库文件

6. 通过Java命令执行 Java程序，最终实现Java调用本地代码

C++调用Java

1. 从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象。

2. 获取类的默认构造方法ID。

3. 查找实例方法的ID。

4. 创建该类的实例。

5. 调用对象的实例方法。
```
JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessMethod_callJavaInstaceMethod  
(JNIEnv *env, jclass cls)  
{  
    jclass clazz = NULL;  
    jobject jobj = NULL;  
    jmethodID mid_construct = NULL;  
    jmethodID mid_instance = NULL;  
    jstring str_arg = NULL;  
    // 1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象  
    clazz = (*env)->FindClass(env, "com/study/jnilearn/ClassMethod");  
    if (clazz == NULL) {  
        printf("找不到'com.study.jnilearn.ClassMethod'这个类");  
        return;  
    }  
    // 2、获取类的默认构造方法ID  
    mid_construct = (*env)->GetMethodID(env,clazz, "<init>","()V");  
    if (mid_construct == NULL) {  
        printf("找不到默认的构造方法");  
        return;  
    }  
    // 3、查找实例方法的ID  
    mid_instance = (*env)->GetMethodID(env, clazz, "callInstanceMethod", "(Ljava/lang/String;I)V");  
    if (mid_instance == NULL) {  
        return;  
    }  
    // 4、创建该类的实例  
    jobj = (*env)->NewObject(env,clazz,mid_construct);  
    if (jobj == NULL) {  
        printf("在com.study.jnilearn.ClassMethod类中找不到callInstanceMethod方法");  
        return;  
    }  
    // 5、调用对象的实例方法  
    str_arg = (*env)->NewStringUTF(env,"我是实例方法");  
    (*env)->CallVoidMethod(env,jobj,mid_instance,str_arg,200);  
    // 删除局部引用  
    (*env)->DeleteLocalRef(env,clazz);  
    (*env)->DeleteLocalRef(env,jobj);  
    (*env)->DeleteLocalRef(env,str_arg);  
}  
```

#### 53.了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？

插件化：插件化是体现在功能拆分方面的，它将某个功能独立提取出来，独立开发，独立测试，再插入到主应用中。依次来较少主应用的规模。

热修复：热修复是体现在bug修复方面的，它实现的是不需要重新发版和重新安装，就可以去修复已知的bug。

#### 54.将apk文件复制到data/app目录

解析apk信息

dexopt操作

更新权限信息

完成安装,发送Intent.ACTION_PACKAGE_ADDED广播

#### 55.JNI的几种注册方式

静态注册

1.编写一个java类，在里面加载对应的so库并且通过native关键字定义需要调用的函数

```
package com.example.wenzhe.myjni;
/**
 * Created by wenzhe on 16-1-27.
 */
public class JniTest {
public native int getRandomNum();
public native String getNativeString();

static {
    System.loadLibrary("HelloJni");
    }
}
```
2.在命令行下输入 javac JniTest.java 生成JniTest.class文件

3.将头文件拷贝到jni目录下(eclipse在src同级目录建立文件夹，Android studio 在java同级目录建立文件夹)

4.编写C/C++源代码 并把刚拷贝的头文件包含进去 ,复制头文件中函数的定义部分，并实现其中的你想要的功能

5.在命令行中进入jni目录，输入ndk-build 即可生产对应so库，会自动放在libs文件夹下 至此就可以运行程序了

动态注册

1.编写Java端的相关native方法

2.编写C/C++代码, 实现JNI_Onload()方法

3.将Java 方法和 C/C++方法通过签名信息一一对应起来

4.通过JavaVM获取JNIEnv, JNIEnv主要用于获取Java类和调用一些JNI提供的方法

5.使用类名和对应起来的方法作为参数, 调用JNI提供的函数RegisterNatives()注册方

#### 56.自定义View 的步骤
自定义View属性

在View的构造方法中获得自定义的属性

重写onMesure

重写onDraw

#### 57.同步和异步的概念区别：
同步，必须执行完成某个问题后才能继续执行其他的。

异步，我会去先执行其他问题，你执行完之后返回给我一个结果就可以。

---

android中为什么要引用异步任务呢？

　android启动的，会启动一个线程也称为主线程，UI线程，但是我们不能把所有耗时的任务交给主线程来完成，这样会影响用户的体验，也就是说我们要另外的开辟新的线程来执行我们的任务，但是在android中，（加载图片，网络编程都属于耗时的操作），在android4.0后规定禁止在主线程中完成网络操作，所以说这些耗时的任务要交给子线程。

---
　
Asynctask的基本使用：

首先它是一个抽象类，也就是说我们要重写他的方法然后在new

AsyncTask<Params,progress,result>

parames:启动任务的时候执行的参数，比如传入的url

Progress：后台执行进度的百分比单位

result：执行完异步操作后返回的结果

#### 58.EventBus的原理
1. 构造方法: 创建构造方法: 通过双重锁的模式创建对象 ; 通过建造者模式创建对象

2. 注册:这个subscriber就是我们使用EventBus.getDefault().register(this);传入的这个this，比如MainActivity.this。通过反射，查找该Subscriber中，通过@Subscribe注解的方法（消费方法）信息，将这些方法信息封装到SubscriberMethod中，封装的内容包括Method对象、ThreadMode、事件类型、优先级、是否粘性等

3. 发布与消费事件: post进行发布 .然后到线程的队列中,然后进行消费事件,消费的时候通过反射和method 调用,这是回到queue队列当中,循环遍历queue中的event 查找可以消费该事件的类和方法,最终他会将事件交给这个类和方法,完成整个消息的发布与消费;

---

Handler与EventBus区别

EventBus是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息.优点是开销小，代码更优雅。以及将发送者和接收者解耦。

大家可以简单对比下两者的区别，可以发现EventBus进行了完全的解耦。

