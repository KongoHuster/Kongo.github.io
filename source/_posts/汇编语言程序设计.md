---
title: 汇编语言程序设计
date: 2020-06-28 16:29:28
categories: 汇编语言程序设计
tags:
- 汇编语言程序设计
---

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://s1.ax1x.com/2020/06/28/N2R1Bj.md.png">
    <br>
    <div style="color:orange;
    display: inline-block;
    color: #999;
    padding: 2px;">眼神</div>
</center>

> 此文为学习汇编语言程序设计所做的笔记

<!-- more -->

### 第一章 汇编语言基础

#### 一、硬件组成


从应用角度看，汇编语言程序员可以将计算机抽象为：寄存器、存储器地址、输入输出地址

##### 1.寄存器

- 处理器内部的高速存储单元
- 用于暂时存放程序执行过程中的代码和数据
- 透明寄存器：对应用人员不可见、不能编程直接控制
- 可编程寄存器：通用寄存器、专用寄存器

##### 2.通用寄存器
- 32位通用寄存器：EAX、EBX、ECX、EDX；ESI、EDI；EBP、ESP
- 16位通用寄存器：AX、BX、CX、DX、SI、DI、BP、SP
- 8位通用寄存器：AH、AL、BH、BL、CH、CL、DH、DL

##### 3.专用寄存器
- 标志寄存器：EFLAGS
- 指令指针寄存器：EIP
- 段寄存器：CS、DS、SS、ES、FS、GS

##### 4.通用寄存器名称
- EAX：累加器
- EBX：基址寄存器
- ECX：计数器
- EDX：数据寄存器
- ESI：源变址寄存器
- EDI：目的编制寄存器
- EBP：基址指针
- ESP：堆栈指针

#### 二、存储器组织

##### 1.存储器地址

- 主存储器容量很大，被划分成许多存储单元
- 每个存储单元被编排一个号码、即存储单元地址
- 每个存储单元一字节为基本存储单位，即按字节编址，一个字节等于8bit

##### 2.位、字节、字、双字

双字 = 2 字 = 4字节 = 32 位

##### 3.存储模型
- 高性能处理器集成存储管理单元MMU
- 操作系统利用MMU进行主存进行管理
- IA-32处理处理器提供3种存储模型：平展存储模型、段式存储模型、实地址存储模型

##### 4.存储空间分段管理
“段”是保存相关代码或数据的一个主存区域

- 代码段：存放程序的可执行代码
- 数据段：存放程序所有的数据，例如全局变量
- 堆栈段：程序需要的特殊区域，存放放回地址、临时变量等

##### 5.逻辑地址
- 存储器空间可以分段管理，采用逻辑地址指示
- 逻辑地址 = 段地址 ： 偏移地址
- 处理器内部以及程序员编程时采用逻辑地址

##### 6.物理地址和逻辑地址的转换

- 程序员编程时采用逻辑地址
- 操作系统利用存储管理单元MMU将逻辑地址映射为线性地址（虚拟地址）
- 处理器使用物理地址访问存储器芯片

##### 7.Win32的虚拟地址分配
- 系统区（2GB）：操作系统代码、系统DLL等
- 用户区（2GB）：用户DLL、进程堆栈、DOS/Win16兼容区、空指针区、

##### 8.标志寄存器
- 状态寄存器：记录指令执行结果的辅助信息
- 控制标志：方向DF，仅用于串操作指令
- 系统标志：控制操作系统或核心管理程序的操作方式

##### 9.指令指针寄存器EIP
- 顺序执行时自动增量
- 分支、调用等操作时执行控制转移指令修改
- 出现中断或异常时被处理器赋值二相应改变

##### 10.段寄存器
段寄存器表明某个段在主存中的位置

- 代码段（CS）——基地址由代码段CS指示、偏移地址由指令指针寄存器EIP保存
- 堆栈段（SS）——基地址由SS指示、偏移地址由ESP指示
- 数据段（DS、ES、FS、GS）——段基地址由DS指示，有时也由ES、FS、GS指示，偏移地址由有效地址EA指示

#### 三、处理器指令格式

##### 1.处理器指令
- 程序用程序设计语言编写，有指令构成
- 指令由操作码和操作数组成
- 操作码在汇编语言使用指令助记符表示
- 操作数在汇编语言中使用寄存器、变量、常量等形式表示

##### 2.IA-32处理器的代码格式
- IA-32处理器采用可变长的指令格式
- 操作码——可选的指令前缀；1~3字节的主要操作吗
- 操作数——可选的地址域、可选的的位移量、可选的立即数

##### 3.汇编语言语句

- 源程序由语句组成
- 通常一个语句占一行
- 一个语句不操作132个字符，4个部分
- 执行性语句：表达处理器指令、实行功能
- 说明性语句：表达伪指令，控制编程方式

##### 4.标号和名字
- 标号和名字是用户定义的标识符
- 标号在执行性语句中
- 名字在说明性语句中

##### 5.标识符
- 取名原则类似于高级语言，但是默认不区别大小写字母
- 不能以数字开头
- 在一个源程序中，用户定义的每个标识符必须唯一
- 不能是保留字

##### 6.助记符
- 帮助记忆指令功能的符号
- 硬指令助记符表示处理器指令
- 伪指令助记符表达一个汇编命令

##### 7.包含伪指令INCLUDE
- 用于声明常用的常量定义、过程说明、共享的子程序库等
- 相当于C和C++语言中，包含头文件的作用
  
##### 8.程序的开始和结束
- 程序开始执行的位置（使用一个标号，作为汇编结束END伪指令的参数）
- 应用程序执行终止（语句“EXIT 0”终止程序执行，返回操作系统，提供一个返回代码0）
- 源程序汇编结束——使用END伪指令语句

### 第二章 数据表示

#### 一、常量表达

##### 1.常量
- 常量是程序中使用的一个确定数值
- 表达形式：常数、字符和字符串、符号常量、数值表达式

#### 二、变量定义

##### 1.什么是变量
- 变量是随程序运行会变化的数据，保存在刻度可写的主存空间
- 变量表达主存数据，即存储操作数

##### 2.变量的定义
- 变量名：用户标识符，表示首元素逻辑地址；
- 变量定义伪指令：为指令助记符，表示变量类型
- 初值表：用逗号分隔的一个或多个参数，表示变量初值

##### 3.主要的变量定义伪指令
- BYTE：每个数据8位
- WORD：每个数据16位
- DWORD：每个数据32位

##### 4.变量定义的初值表
- 使用“？”表示初值不确定，即未赋初值
- 使用赋值操作符DUP表示多个同样的数值，形式：重复次数 DUP（重复参数）

#### 三、变量运用

##### 1.字节数据的存储顺序

- 大端方式：高对低，低对高
- 小端方式：高对高、低对低


##### 2.变量属性
- 地址属性：首个变量所在存储单元的逻辑地址
- 类型属性：变量定义的数据单位
  
##### 3.变量的地址属性及地址操作符
- []:括起来的表达式作为存储器地址指针
- $:返回当前偏移的地址
- OFFSET 变量名:返回变量名所在段的偏移地址
- SEG 变量名:返回段基地址

##### 4.类型操作符

- 类型名 PTR 变量名：将变量名按照指定的类型使用
- TYPE 变量名：返回占用字节空间的数字量数值
- LENGTHOF 变量名：返回整个变量的数据项
- SIZEOF 变量名：返回整个变量占用的字节数


### 第三章 数据寻址

#### 一、立即数寻址 

##### 1.寻址方式

- 数据寻址：指令执行过程中，访问所需要操作的数据
- 指令寻址：一条指令执行后，确定执行的下一条指令的位置

##### 2.数据寻址

- 立即数寻址：数据保存在指令代码中
- 寄存器寻址：数据在寄存器中，用寄存器名表示
- 存储器寻址：数据来自主存储器，变量指向存储单元，所以访问变量就是存储器寻址。
- IO寻址：数据在外设中，用IO地址表示，可分为直接寻址和间接寻址

#### 二、寄存器寻址

- 操作数存放在处理器的内部
- 用寄存器名表示它的内容

#### 三、存储器寻址

##### 1.原理
- 指令代码表达形式地址
- 由形式地址结合规则经过计算得到有效地址EA
- 处理器将有效地址转换为物理地址访问存储单元
- 逻辑地址 = 段基地址 ： 偏移地址

##### 2.段寄存器指示段基地址
- 读取指令，一定是代码段CS
- 堆栈操作，针对堆栈段SS
- 读取数据，默认在数据段DS

##### 3.32位有效地址的组成
基址寄存器 + 变址寄存器 * 比例 + 位移量
- 基址寄存器 ：任何8个32位通用寄存器之一
- 变址寄存器：除ESP外的任何32位通用寄存器之一
- 比例：1，2，4或8
- 位移量：8或32位有符号位

##### 4.16位有效地址的组成
基地址寄存器 + 变址寄存器 + 位移量
- 基地址寄存器：BX或BP
- 变址寄存器：SI或DI
- 位移量：8或16位有符号值

##### 5.直接寻址常用于存取变量
- 直接使用变量名
- 变量名加或减一个常量
- 使用中括号括起的变量名

##### 6.寄存器间接寻址和相对寻址
- 间接寻址其有效地址存放在寄存器中，用中括号括起寄存器表达
- 相对寻址其有效地址是寄存器内容与位移量之和，寄存器要用中括号括起来

### 第四章 通用数据处理指令

#### 一、数据传送类指令
- MOV：把一个字节、字或双字的操作数从源位置传送至目的位置
- LEA：地址传送指令获取存储器操作数的地址
- PUSH：数据压进堆栈
- POP：数据弹出堆栈

#### 二、算术运算类指令

##### 1.进位标志位CF和溢出标志位

- 当加减法运算结果的最高有效位（加法）或借位（减法）时，进位标志位置1
- 针对无符号整数，判断加减结果是否超出表达范围
- 有溢出，运算结果已经不正确
- 无符号数，关心进位；有符号数，注意溢出

##### 2.零标志、符号标志和奇偶标志
- 运行结果为0，则零标志ZF置1
- 运算结果最高位为1，则符号标志位SF=1，即最高位=符号位
- 当运算结果最低字节中“1”的个数为零或偶数时，奇偶标志位PF=1；否则PF=0

##### 3.运算指令
- ADD：目的操作数加上源操作数，和送到目的操作数
- SUB：目的操作数减去源操作数，差送到目的操作数
- INC：只有一个操作数，将寄存器中的操作数加一返回原处
- DEC：只有一个操作数，将寄存器中的操作数减一返回原处
- - NEG：只有一个操作数，将寄存器中的操作数进行求补运算，即用零减去操所数

#### 三、位操作类指令

##### 1.逻辑运算指令

- AND：逻辑与
- OR：逻辑或
- NOT：逻辑非
- XOR：逻辑异或
- TEST：测试指令

##### 2.移位指令
- 逻辑左移指令 SHL：各位同时左移
- 逻辑右移指令 SHR：各位同时右移
- 算术左移指令 SAL：各位同时左移，最高位不变
- 算术右移指令 SAR：各位同时右移，最高位不变

##### 3.循环移位指令
- 不带进位循环左移指令 ROL
- 不带进位循环右移指令 ROR
- 带进位循环左移指令 RCL
- 带进位循环右移指令 RCR

### 第五章 顺序程序结构

程序的顺序结构是不含分支、循环和调用的一条语句（指令）、一条语句（指令）逐个顺序执行的程序结构。


- 移位可以实现乘法（10 = 2^3 + 2）
- 自然数求和程序

### 第六章 分支程序结构

#### 一、指令寻址方式

##### 1.指令寻址
- 顺序寻址
- 跳转寻址——直接寻址、相对寻址、间接寻址（寄存器间接寻址、存储器间接寻址）

##### 2.指令的直接寻址
- 直接提供目的地址
- 目标地址 = 指令操作数

##### 3.指令的间接寻址

- 目标地址来自寄存器或存储单元、间接获得
- 可分为寄存器间接寻址和存储器间接寻址

##### 4.程序流程的控制转移
- 程序代码在代码段，CS指明代码段在主存中的段基地址，EIP给出将要执行的偏移地址
- 指令调转寻址，程序控制转移，EIP（CS）随之改变
- 通过改变EIP（和CS）控制程序流程，实现程序分支、循环、调用等结构

##### 5.无条件转移指令（JMP）
- JMP lable 程序转向lable标号指定的地址
- JMP reg32/reg16 程序转向寄存器指定的地址
- JMP mem48/mem32/mem16 程序转向存储单元指定的地址

##### 6.条件转移指令（Jcc）
- 单个标志状态位作为条件；两数大小关系作为条件
- ZF：JZ，JE；JNZ，JNE
- CF：JC，JNC
- OF：JO，JNO
- SF：JS，JNS
- PF：JP，JPE，JNP，JPO

#### 二、单分支结构

- 注意和if-then语句相反，当瞒住条件，就发生转移，跳过分支体
- 条件不满足，顺序向下执行分支体

#### 三、双分支结构

- 相当于高级语言的if-then-else语句
- 条件为真执行一个分支，条件为假执行另一个分支

### 第七章 循环指令结构

#### 一、循环指令

##### 1.LOOP指令

- LOOP是循环指令，用于实现减量计数多的循环控制
- 初值为0时循环次数为2^32次
- LOOP指令是先减1后做判断

##### 2.JECXZ指令
- 为避免计数初值为0可能导致的程序错误
- 用于跳过ECX=0的情况

#### 二、计数控制循环

- 计数可以减量进行，即减到0结束
- 计数可以增量进行，即达到规定值结束

#### 三、条件控制循环
- 根据条件决定是否进行循环
- 所见的是“先判断、后循环”结构

### 第八章 子程序结构

#### 一、子程序设计

##### 1.子程序指令
- 主程序：执行调用指令CALL调用子程序
- 子程序：执行返回指令RET返回主程序

#### 二、参数传递

##### 1.参数传递
- 参数分类：入口参数、出口参数
- 参数具体内容：数据本身、数据的存储地址
- 参数传递方式：通用寄存器、共享变量、堆栈

##### 2.寄存器传参
- 把参数存于约定的寄存器
- 少量数据直接传递数值
- 大量数据只能传递地址
- 带有出口参数的寄存器不能保护和恢复

##### 3.共享变量传参
- 子程序和主程序使用同一个变量名存取数据
- 如果变量定义和使用不在同一个程序模块中，需要使用PUBLIC、EXTERN声明
- 特别适合在多个程序段间、尤其在不同程序模块间传递数据
- 对应高级语言中的全局变量

##### 4.堆栈传递参数
- 主程序将入口参数压入堆栈
- 子程序从堆栈中取出参数
- 出口参数通常不适用堆栈传递

#### 三、程序模块

##### 1.MASM支持的多模块方法
- 源文件包含
- 模块连接
- 子程序库
- 库文件包含

##### 2.源文件包含
- INC：各种常量、声明语句等组织在包含文件
- MAC：常用的或有价值的宏定义存放宏定义文件
- ASM：常用的子程序形成汇编语言源文件

##### 3.模块连接
子程序单独编写一个源程序文件
- 使用共用伪指令PUBLIC和外部伪指令EXTERN声明
- 子程序在代码段，与主程序文件采用相同的存储模型
- 没有开始执行和结束执行点，但有汇编结束语句
- 处理好子程序与主程序之间的参数传递问题

##### 4.子程序库的使用
- 子程序单独编写一个源程序文件
- 子程序源文件汇编形成目标模块OBJ文件
- 利用库管理工具把子程序模块加入到子程序库
- 在连接主程序时提供子程序库文件名

##### 5.库文件包含
- 要使用已存入库文件中的子程序
- 在主程序源文件中用库文件包含伪指令INCLUDELIB声明

##### 6.宏汇编
- 宏（Macro）是具有宏名的一段汇编语句序列
- 宏需要先使用MACRO/ENDM伪指令进行定义
- 然后在程序中使用宏名（带参数）进行宏调用
- 源程序进行汇编时，宏名被汇编程序用宏定义的，代码序列替代，实现宏展开
- 这个过程就是“宏汇编”

##### 7.宏与子程序
- 宏仅是源程序级的简化
- 子程序不仅简化源程序，还是目标程序级的简化
- 当程序段较短或要求较快执行时，选用宏
- 当程序段较长或为减小目标代码时，选用子程序