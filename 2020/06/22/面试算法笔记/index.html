<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yoursite.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:-1,unescape:!1,preload:!0},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="一抹光     本科面试笔记"><meta property="og:type" content="article"><meta property="og:title" content="算法面试笔记"><meta property="og:url" content="http://yoursite.com/2020/06/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="Kongo&#39;s blog"><meta property="og:description" content="一抹光     本科面试笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://yoursite.com/2020/06/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/dgdvlo.jpg"><meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20190313/311436_1552474444160_93CF294B0FB45C83DC616C5700184F2E"><meta property="og:image" content="http://img.51nod.com/upload/000FBEAF/08D25D565D85EFF40000000000000002.jpeg"><meta property="og:image" content="https://img-blog.csdn.net/20140901134800948?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM5NzM2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><meta property="og:image" content="http://img.blog.csdn.net/20141221160159348"><meta property="og:image" content="http://uploadfiles.nowcoder.com/images/20150807/277064_1438943576180_1.jpg"><meta property="og:image" content="https://img-blog.csdnimg.cn/20190702222955833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlaW5pZmk=,size_16,color_FFFFFF,t_70"><meta property="og:image" content="https://img-blog.csdnimg.cn/20190702223336946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlaW5pZmk=,size_16,color_FFFFFF,t_70"><meta property="og:image" content="https://s1.ax1x.com/2020/03/20/82I09f.png"><meta property="og:image" content="https://s1.ax1x.com/2020/03/21/8WS2Rg.png"><meta property="article:published_time" content="2020-06-22T07:51:30.000Z"><meta property="article:modified_time" content="2020-06-22T07:54:00.721Z"><meta property="article:author" content="Kongo"><meta property="article:tag" content="面试笔记"><meta property="article:tag" content="算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://yoursite.com/2020/06/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/dgdvlo.jpg"><link rel="canonical" href="http://yoursite.com/2020/06/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>算法面试笔记 | Kongo's blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Kongo's blog</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/honghong1234" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/header.jpeg"><meta itemprop="name" content="Kongo"><meta itemprop="description" content="闳的博客，记录技术、生活"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Kongo's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 算法面试笔记</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-06-22 15:51:30 / 修改时间：15:54:00" itemprop="dateCreated datePublished" datetime="2020-06-22T15:51:30+08:00">2020-06-22</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">面试笔记</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/2020/06/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/06/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span></a></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>44k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>40 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><center> <img style="border-radius:.3125em;box-shadow:0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08)" src="/2020/06/22/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/dgdvlo.jpg"><br><div style="color:orange;display:inline-block;color:#999;padding:2px">一抹光</div></center><blockquote><p>本科面试笔记</p></blockquote><a id="more"></a><h3 id="一、树"><a href="#一、树" class="headerlink" title="一、树"></a>一、树</h3><h4 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1.红黑树"></a>1.红黑树</h4><ul><li>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。</li><li>通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树</li></ul><p>性质：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 每个节点非红即黑</span><br><span class="line"></span><br><span class="line">2. 根节点是黑的;</span><br><span class="line"></span><br><span class="line">3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</span><br><span class="line"></span><br><span class="line">4. 如果一个节点是红色的，则它的子节点必须是黑色的。</span><br><span class="line"></span><br><span class="line">5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</span><br></pre></td></tr></table></figure><h4 id="2-AVL树"><a href="#2-AVL树" class="headerlink" title="2.AVL树"></a>2.AVL树</h4><p>平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。</p><h4 id="3-map底层为什么用红黑树实现"><a href="#3-map底层为什么用红黑树实现" class="headerlink" title="3.map底层为什么用红黑树实现"></a>3.map底层为什么用红黑树实现</h4><p>红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p><h4 id="4-Top-K-问题"><a href="#4-Top-K-问题" class="headerlink" title="4.Top(K)问题"></a>4.Top(K)问题</h4><p>1、直接全部排序（只适用于内存够的情况）</p><p>当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。</p><p>这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。</p><p>2、快速排序的变形 （只使用于内存够的情况）</p><p>这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。</p><p>这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index &gt; K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index &lt; K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。</p><p>3、最小堆法</p><p>这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。</p><p>4、分治法</p><p>将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N<em>K个数据，如果内存不能容纳N</em>K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。</p><p>5、Hash法</p><p>如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。</p><h4 id="5-红黑树较AVL树的优点："><a href="#5-红黑树较AVL树的优点：" class="headerlink" title="5.红黑树较AVL树的优点："></a>5.红黑树较AVL树的优点：</h4><p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p><h4 id="6-二叉树的层序遍历并输出（手写代码）"><a href="#6-二叉树的层序遍历并输出（手写代码）" class="headerlink" title="6.二叉树的层序遍历并输出（手写代码）"></a>6.二叉树的层序遍历并输出（手写代码）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line">&#x2F;**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val &#x3D; 0;</span><br><span class="line">    TreeNode left &#x3D; null;</span><br><span class="line">    TreeNode right &#x3D; null;</span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val &#x3D; val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; resultList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode nowNode &#x3D; q.peek();</span><br><span class="line">            q.poll();</span><br><span class="line">            resultList.add(nowNode.val);</span><br><span class="line">            if (nowNode.left !&#x3D; null) &#123;</span><br><span class="line">                q.add(nowNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (nowNode.right !&#x3D; null) &#123;</span><br><span class="line">                q.add(nowNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return resultList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-序列化和反序列化二叉树。（手写代码）"><a href="#7-序列化和反序列化二叉树。（手写代码）" class="headerlink" title="7.序列化和反序列化二叉树。（手写代码）"></a>7.序列化和反序列化二叉树。（手写代码）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;题目：请实现两个函数，分别用来序列化和反序列化二叉树。</span><br><span class="line"> </span><br><span class="line">public class SerializeBinaryTrees &#123;</span><br><span class="line">    public class TreeNode &#123;</span><br><span class="line">        int val &#x3D; 0;</span><br><span class="line">        TreeNode left &#x3D; null;</span><br><span class="line">        TreeNode right &#x3D; null;</span><br><span class="line"> </span><br><span class="line">        public TreeNode(int val) &#123;</span><br><span class="line">            this.val &#x3D; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    String Serialize(TreeNode node) &#123;</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            sb.append(&quot;$,&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sb.append(node.val + &quot;,&quot;);</span><br><span class="line">            sb.append(Serialize(node.left));</span><br><span class="line">            sb.append(Serialize(node.right));</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    int index &#x3D; 0;</span><br><span class="line">    TreeNode Deserialize(String str) &#123;</span><br><span class="line">        TreeNode node &#x3D; null;</span><br><span class="line">        if (str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D; 0)</span><br><span class="line">            return node;</span><br><span class="line">        int start &#x3D; index;</span><br><span class="line">        while (str.charAt(index) !&#x3D; &#39;,&#39;)</span><br><span class="line">            index++;</span><br><span class="line">        if (!str.substring(start, index).equals(&quot;$&quot;)) &#123;</span><br><span class="line">            node &#x3D; new TreeNode(Integer.parseInt(str.substring(start, index)));</span><br><span class="line">            index++; &#x2F;&#x2F; 这条语句位置别放错了</span><br><span class="line">            node.left &#x3D; Deserialize(str);</span><br><span class="line">            node.right &#x3D; Deserialize(str);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-最近公共祖先"><a href="#8-最近公共祖先" class="headerlink" title="8.最近公共祖先"></a>8.最近公共祖先</h4><p>有一棵无穷大的满二叉树，其结点按根结点一层一层地从左往右依次编号，根结点编号为1。现在有两个结点a，b。请设计一个算法，求出a和b点的最近公共祖先的编号。</p><p>给定两个int a,b。为给定结点的编号。请返回a和b的最近公共祖先的编号。注意这里结点本身也可认为是其祖先。</p><p>测试样例：<br>2，3</p><p>返回：<br>1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：满二叉树的子节点与父节点之间的关系为root &#x3D; child &#x2F; 2</span><br><span class="line">&#x2F;&#x2F;利用这个关系，如果a ！&#x3D; b，就让其中的较大数除以2， 如此循环知道a &#x3D;&#x3D; b，</span><br><span class="line">&#x2F;&#x2F;即是原来两个数的最近公共祖先</span><br><span class="line">&#x2F;&#x2F;代码如下：</span><br><span class="line"> class LCA &#123;</span><br><span class="line">public:</span><br><span class="line">    int getLCA(int a, int b) &#123;</span><br><span class="line">        &#x2F;&#x2F; write code here</span><br><span class="line">        while(a !&#x3D; b)</span><br><span class="line">            &#123;</span><br><span class="line">            if(a &gt; b)</span><br><span class="line">                a &#x2F;&#x3D; 2;</span><br><span class="line">            else</span><br><span class="line">                b &#x2F;&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二、堆和栈"><a href="#二、堆和栈" class="headerlink" title="二、堆和栈"></a>二、堆和栈</h3><h4 id="1-说一说你理解的stack-overflow，并举个简单例子导致栈溢出"><a href="#1-说一说你理解的stack-overflow，并举个简单例子导致栈溢出" class="headerlink" title="1.说一说你理解的stack overflow，并举个简单例子导致栈溢出"></a>1.说一说你理解的stack overflow，并举个简单例子导致栈溢出</h4><p>栈溢出概念：</p><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。</p><p>栈溢出的原因：</p><ol><li><p>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）。</p></li><li><p>递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</p></li><li><p>指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</p></li></ol><h4 id="2-堆和栈的区别"><a href="#2-堆和栈的区别" class="headerlink" title="2.堆和栈的区别"></a>2.堆和栈的区别</h4><p>1）申请方式：<br>栈由系统自动分配和管理，堆由程序员手动分配和管理。</p><p>2）效率：</p><p>栈由系统分配，速度快，不会有内存碎片。</p><p>堆由程序员分配，速度较慢，可能由于操作不当产生内存碎片。</p><p>3）扩展方向</p><p>栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展。</p><p>4）程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间。</p><h4 id="3-大小根堆特点"><a href="#3-大小根堆特点" class="headerlink" title="3.大小根堆特点"></a>3.大小根堆特点</h4><p>堆是一棵完全二叉树（如果一共有h层，那么1~h-1层均满，在h层可能会连续缺失若干个右叶子）。</p><p>1）小根堆</p><p>若根节点存在左子女则根节点的值小于左子女的值；若根节点存在右子女则根节点的值小于右子女的值。</p><p>2）大根堆</p><p>若根节点存在左子女则根节点的值大于左子女的值；若根节点存在右子女则根节点的值大于右子女的值。</p><hr><p>堆和普通树的区别</p><p>堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。我们来看一下两者的主要差别：</p><p>节点的顺序。在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。</p><p>内存占用。普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额为是我内存。堆仅仅使用一个数据来存储数组，且不使用指针。</p><p>平衡。二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。</p><p>搜索。在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</p><h4 id="4-两个栈实现一个队列-和-用队列实现栈（手写代码）"><a href="#4-两个栈实现一个队列-和-用队列实现栈（手写代码）" class="headerlink" title="4.两个栈实现一个队列 和 用队列实现栈（手写代码）"></a>4.两个栈实现一个队列 和 用队列实现栈（手写代码）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"> </span><br><span class="line">	Stack&lt;Integer&gt; stack1 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">	Stack&lt;Integer&gt; stack2 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;进栈操作呢</span><br><span class="line">	public void appendTail(int item)&#123;</span><br><span class="line">		stack1.push(item);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;出栈操作</span><br><span class="line">	public int deleteHead()&#123;</span><br><span class="line">		while(!stack2.isEmpty())&#123;</span><br><span class="line">			return stack2.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		while(!stack1.isEmpty())&#123;</span><br><span class="line">			stack2.push(stack1.pop());</span><br><span class="line">		&#125;</span><br><span class="line">		return stack2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用队列实现栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">    Queue&lt;Integer&gt; que;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;** Initialize your data structure here. *&#x2F;</span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        que &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Push element x onto stack. *&#x2F;</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        que.add(x);</span><br><span class="line">        int num&#x3D;que.size();</span><br><span class="line">        while(num&gt;1)&#123;</span><br><span class="line">            que.add(que.poll());</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;</span><br><span class="line">    public int pop() &#123;       </span><br><span class="line">       return que.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Get the top element. *&#x2F;</span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return que.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Returns whether the stack is empty. *&#x2F;</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return que.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h3><h4 id="1-数组与链表的区别"><a href="#1-数组与链表的区别" class="headerlink" title="1.数组与链表的区别"></a>1.数组与链表的区别</h4><p>数组的优点：</p><ol><li><p>随机访问性强</p></li><li><p>查找速度快</p></li></ol><p>数组的缺点:</p><ol><li><p>插入和删除效率低</p></li><li><p>可能浪费内存</p></li><li><p>内存空间要求高，必须有足够的连续内存空间。</p></li><li><p>数组大小固定，不能动态拓展</p></li></ol><p>链表的优点:</p><ol><li><p>插入删除速度快</p></li><li><p>内存利用率高，不会浪费内存</p></li><li><p>大小没有固定，拓展很灵活。</p></li></ol><p>链表的缺点:</p><ol><li>不能随机查找，必须从第一个开始遍历，查找效率低</li></ol><h4 id="2-二分法"><a href="#2-二分法" class="headerlink" title="2.二分法"></a>2.二分法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int binary_search(T arr[], int n, T target) &#123;</span><br><span class="line">    int l &#x3D; 0, r &#x3D; n - 1;</span><br><span class="line">    while (l &lt;&#x3D; r) &#123;</span><br><span class="line">        int mid &#x3D; (r + l) &#x2F; 2; &#x2F;&#x2F; ☆</span><br><span class="line">        if (arr[mid] &#x3D; target) return mid;</span><br><span class="line">        if (target &gt; arr[mid]) l &#x3D; mid + 1;</span><br><span class="line">        else r &#x3D; mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、排序"><a href="#四、排序" class="headerlink" title="四、排序"></a>四、排序</h3><h4 id="1-各种排序算法及时间复杂度"><a href="#1-各种排序算法及时间复杂度" class="headerlink" title="1.各种排序算法及时间复杂度"></a>1.各种排序算法及时间复杂度</h4><p>插入排序：对于一个带排序数组来说，其初始有序数组元素个数为1，然后从第二个元素，插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插入的元素，则后移一位；如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前元素的下一位中。</p><p>希尔排序：先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关，其最后一个值必须为1.</p><p>归并排序：该算法采用分治法；对于包含m个元素的待排序序列，将其看成m个长度为1的子序列。然后两两合归并，得到n/2个长度为2或者1的有序子序列；然后再两两归并，直到得到1个长度为m的有序序列。</p><p>冒泡排序：对于包含n个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，若为逆序，则交换元素位置；然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前前n-i个元素中的最大的元素移到n-i位置。遍历n次，完成排序。</p><p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>选择排序：每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个元素交换位置，从而使有序数组元素加1，无序数组元素减1.初始时无序数组为空。</p><p>堆排序：堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数据构造一个最大堆（升序）/最小堆（降序），然后将堆顶元素与待排序数组的最后一个元素交换位置，此时末尾元素就是最大/最小的值。然后将剩余n-1个元素重新构造成最大堆/最小堆。</p><p><img src="/images/loading/loading.gif" data-original="https://uploadfiles.nowcoder.com/images/20190313/311436_1552474444160_93CF294B0FB45C83DC616C5700184F2E" alt></p><h4 id="2-稳定排序哪几种？"><a href="#2-稳定排序哪几种？" class="headerlink" title="2.稳定排序哪几种？"></a>2.稳定排序哪几种？</h4><p>基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序</p><h4 id="3-请问求第k大的数的方法以及各自的复杂度是怎样的？"><a href="#3-请问求第k大的数的方法以及各自的复杂度是怎样的？" class="headerlink" title="3.请问求第k大的数的方法以及各自的复杂度是怎样的？"></a>3.请问求第k大的数的方法以及各自的复杂度是怎样的？</h4><p>解法1： 我们可以对这个乱序数组按照从大到小先行排序，然后取出前k大，总的时间复杂度为O(n*logn + k)。</p><p>解法2： 利用快速排序的思想，从数组S中随机找出一个元素X，把数组分为两部分Sa和Sb。Sa中的元素大于等于X，Sb中元素小于X。这时有两种情况：</p><ol><li>Sa中元素的个数小于k，则Sb中的第k-|Sa|个元素即为第k大数；</li><li>Sa中元素的个数大于等于k，则返回Sa中的第k大数。时间复杂度近似为O(n)</li></ol><p>解法3：维护一个k大小的最小堆，对于数组中的每一个元素判断与堆顶的大小，若堆顶较大，则不管，否则，弹出堆顶，将当前值插入到堆中。时间复杂度O(n * logk)</p><p>解法4：利用hash保存数组中元素Si出现的次数，利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大数，平均情况下时间复杂度O(n)</p><h4 id="4-冒泡排序-手写代码-O-n-2"><a href="#4-冒泡排序-手写代码-O-n-2" class="headerlink" title="4.冒泡排序(手写代码) O(n^2)"></a>4.冒泡排序(手写代码) O(n^2)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void BubbleSort1(int [] arr)&#123;</span><br><span class="line"></span><br><span class="line">   int temp;&#x2F;&#x2F;临时变量</span><br><span class="line">   boolean flag;&#x2F;&#x2F;是否交换的标志</span><br><span class="line">   for(int i&#x3D;0; i&lt;arr.length-1; i++)&#123;   &#x2F;&#x2F;表示趟数，一共 arr.length-1 次</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 每次遍历标志位都要先置为false，才能判断后面的元素是否发生了交换</span><br><span class="line">       flag &#x3D; false;</span><br><span class="line">       </span><br><span class="line">       for(int j&#x3D;arr.length-1; j&gt;i; j--)&#123; &#x2F;&#x2F;选出该趟排序的最大值往后移动</span><br><span class="line"></span><br><span class="line">           if(arr[j] &lt; arr[j-1])&#123;</span><br><span class="line">               temp &#x3D; arr[j];</span><br><span class="line">               arr[j] &#x3D; arr[j-1];</span><br><span class="line">               arr[j-1] &#x3D; temp;</span><br><span class="line">               flag &#x3D; true;    &#x2F;&#x2F;只要有发生了交换，flag就置为true</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 判断标志位是否为false，如果为false，说明后面的元素已经有序，就直接return</span><br><span class="line">       if(!flag) break;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-选择排序-O-n-2"><a href="#5-选择排序-O-n-2" class="headerlink" title="5.选择排序 O(n^2)"></a>5.选择排序 O(n^2)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void select_sort(int array[],int lenth)&#123;</span><br><span class="line"></span><br><span class="line">   for(int i&#x3D;0;i&lt;lenth-1;i++)&#123;</span><br><span class="line"></span><br><span class="line">       int minIndex &#x3D; i;</span><br><span class="line">       for(int j&#x3D;i+1;j&lt;lenth;j++)&#123;</span><br><span class="line">          if(array[j]&lt;array[minIndex])&#123;</span><br><span class="line">              minIndex &#x3D; j;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if(minIndex !&#x3D; i)&#123;</span><br><span class="line">           int temp &#x3D; array[i];</span><br><span class="line">           array[i] &#x3D; array[minIndex];</span><br><span class="line">           array[minIndex] &#x3D; temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-快速排序（手写代码）O-Nlog2N"><a href="#6-快速排序（手写代码）O-Nlog2N" class="headerlink" title="6.快速排序（手写代码）O(Nlog2N)"></a>6.快速排序（手写代码）O(Nlog2N)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void quickSort(int a[],int l,int r)&#123;</span><br><span class="line">     if(l&gt;&#x3D;r)</span><br><span class="line">       return;</span><br><span class="line"></span><br><span class="line">     int i &#x3D; l; int j &#x3D; r; int key &#x3D; a[l];&#x2F;&#x2F;选择第一个数为key</span><br><span class="line"></span><br><span class="line">     while(i&lt;j)&#123;</span><br><span class="line"></span><br><span class="line">         while(i&lt;j &amp;&amp; a[j]&gt;&#x3D;key)&#x2F;&#x2F;从右向左找第一个小于key的值</span><br><span class="line">             j--;</span><br><span class="line">         if(i&lt;j)&#123;</span><br><span class="line">             a[i] &#x3D; a[j];</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         while(i&lt;j &amp;&amp; a[i]&lt;key)&#x2F;&#x2F;从左向右找第一个大于key的值</span><br><span class="line">             i++;</span><br><span class="line"></span><br><span class="line">         if(i&lt;j)&#123;</span><br><span class="line">             a[j] &#x3D; a[i];</span><br><span class="line">             j--;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;i &#x3D;&#x3D; j</span><br><span class="line">     a[i] &#x3D; key;</span><br><span class="line">     quickSort(a, l, i-1);&#x2F;&#x2F;递归调用</span><br><span class="line">     quickSort(a, i+1, r);&#x2F;&#x2F;递归调用</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="7-归并排序（手写代码）O-Nlog2N"><a href="#7-归并排序（手写代码）O-Nlog2N" class="headerlink" title="7.归并排序（手写代码）O(Nlog2N)"></a>7.归并排序（手写代码）O(Nlog2N)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public static void merge_sort(int a[],int first,int last,int temp[])&#123;</span><br><span class="line"></span><br><span class="line">  if(first &lt; last)&#123;</span><br><span class="line">      int middle &#x3D; (first + last)&#x2F;2;</span><br><span class="line">      merge_sort(a,first,middle,temp);&#x2F;&#x2F;左半部分排好序</span><br><span class="line">      merge_sort(a,middle+1,last,temp);&#x2F;&#x2F;右半部分排好序</span><br><span class="line">      mergeArray(a,first,middle,last,temp); &#x2F;&#x2F;合并左右部分</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;合并 ：将两个序列a[first-middle],a[middle+1-end]合并</span><br><span class="line">public static void mergeArray(int a[],int first,int middle,int end,int temp[])&#123;    </span><br><span class="line">  int i &#x3D; first;</span><br><span class="line">  int m &#x3D; middle;</span><br><span class="line">  int j &#x3D; middle+1;</span><br><span class="line">  int n &#x3D; end;</span><br><span class="line">  int k &#x3D; 0;</span><br><span class="line">  while(i&lt;&#x3D;m &amp;&amp; j&lt;&#x3D;n)&#123;</span><br><span class="line">      if(a[i] &lt;&#x3D; a[j])&#123;</span><br><span class="line">          temp[k] &#x3D; a[i];</span><br><span class="line">          k++;</span><br><span class="line">          i++;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">          temp[k] &#x3D; a[j];</span><br><span class="line">          k++;</span><br><span class="line">          j++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">  while(i&lt;&#x3D;m)&#123;</span><br><span class="line">      temp[k] &#x3D; a[i];</span><br><span class="line">      k++;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;    </span><br><span class="line">  while(j&lt;&#x3D;n)&#123;</span><br><span class="line">      temp[k] &#x3D; a[j];</span><br><span class="line">      k++;</span><br><span class="line">      j++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for(int ii&#x3D;0;ii&lt;k;ii++)&#123;</span><br><span class="line">      a[first + ii] &#x3D; temp[ii];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-堆排序O-Nlog2N"><a href="#8-堆排序O-Nlog2N" class="headerlink" title="8.堆排序O(Nlog2N)"></a>8.堆排序O(Nlog2N)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构建最小堆</span><br><span class="line">public static void MakeMinHeap(int a[], int n)&#123;</span><br><span class="line"> for(int i&#x3D;(n-1)&#x2F;2 ; i&gt;&#x3D;0 ; i--)&#123;</span><br><span class="line">     MinHeapFixdown(a,i,n);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2  </span><br><span class="line">public static void MinHeapFixdown(int a[],int i,int n)&#123;</span><br><span class="line"></span><br><span class="line">   int j &#x3D; 2*i+1; &#x2F;&#x2F;子节点</span><br><span class="line">   int temp &#x3D; 0;</span><br><span class="line"></span><br><span class="line">   while(j&lt;n)&#123;</span><br><span class="line">       &#x2F;&#x2F;在左右子节点中寻找最小的</span><br><span class="line">       if(j+1&lt;n &amp;&amp; a[j+1]&lt;a[j])&#123;  </span><br><span class="line">           j++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if(a[i] &lt;&#x3D; a[j])</span><br><span class="line">           break;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;较大节点下移</span><br><span class="line">       temp &#x3D; a[i];</span><br><span class="line">       a[i] &#x3D; a[j];</span><br><span class="line">       a[j] &#x3D; temp;</span><br><span class="line"></span><br><span class="line">       i &#x3D; j;</span><br><span class="line">       j &#x3D; 2*i+1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void MinHeap_Sort(int a[],int n)&#123;</span><br><span class="line">  int temp &#x3D; 0;</span><br><span class="line">  MakeMinHeap(a,n);</span><br><span class="line"></span><br><span class="line">  for(int i&#x3D;n-1;i&gt;0;i--)&#123;</span><br><span class="line">      temp &#x3D; a[0];</span><br><span class="line">      a[0] &#x3D; a[i];</span><br><span class="line">      a[i] &#x3D; temp;</span><br><span class="line">      MinHeapFixdown(a,0,i);</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、哈希"><a href="#五、哈希" class="headerlink" title="五、哈希"></a>五、哈希</h3><h4 id="1-hash表的实现"><a href="#1-hash表的实现" class="headerlink" title="1.hash表的实现"></a>1.hash表的实现</h4><p>（1）构造哈希</p><p>主要包括直接地址法、平方取中法、除留余数法等。</p><p>（2）处理哈希冲突</p><p>最常用的处理冲突的方法有开放定址法、再哈希法、链地址法、建立公共溢出区等方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开放定址法: 当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</span><br><span class="line"></span><br><span class="line">再哈希法：当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数。</span><br><span class="line"></span><br><span class="line">链地址法：将所有哈希值相同的Key通过链表存储。key按顺序插入到链表中</span><br><span class="line"></span><br><span class="line">建立公共溢出区：采用一个溢出表存储产生冲突的关键字。如果公共溢出区还产生冲突，再采用处理冲突方法处理。</span><br></pre></td></tr></table></figure><h4 id="2-哈希表的桶个数为什么是质数，合数有何不妥？"><a href="#2-哈希表的桶个数为什么是质数，合数有何不妥？" class="headerlink" title="2.哈希表的桶个数为什么是质数，合数有何不妥？"></a>2.哈希表的桶个数为什么是质数，合数有何不妥？</h4><p>哈希表的桶个数使用质数，可以最大程度减少冲突概率，使哈希后的数据分布的更加均匀。如果使用合数，可能会造成很多数据分布会集中在某些点上，从而影响哈希表效率。</p><h3 id="六、动态规划"><a href="#六、动态规划" class="headerlink" title="六、动态规划"></a>六、动态规划</h3><p>动态规划，利用问题的最优子结构性质，以自底向上的方式递归的从子问题的最优解逐步构造出整个问题的最优解。<br>对于重叠子问题，一个典型的问题是求斐波那契数列的第N项，如果用递归的方法做会存在大量的重叠子问题，而利用动态规划的方法就是解决了重叠子问题。<br>建立表格不断填表，相当于备忘录，也就是解决重叠子问题的技巧，典型的问题是斐波那契数列、背包问题等，许多动态规划问题都是定义数组，进行递推过程填充数组（模拟备忘录）。<br>马尔科夫性，是随机过程中某事件的发生只取决于它的上一事件、是“无记忆”过程。而动态规划具有“记忆性”。</p><h4 id="1-最长公共子序列（手写代码）"><a href="#1-最长公共子序列（手写代码）" class="headerlink" title="1.最长公共子序列（手写代码）"></a>1.最长公共子序列（手写代码）</h4><p>最长公共子序列问题：</p><p>给定两个字符串A、B，求A与B的最长公共子序列（子序列不要求是连续的）</p><p>举例：</p><p>字符串A： abcdef</p><p>字符串B：baaecd</p><p>输出：acd</p><p><img src="/images/loading/loading.gif" data-original="http://img.51nod.com/upload/000FBEAF/08D25D565D85EFF40000000000000002.jpeg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class 最长公共子序列  &#123;</span><br><span class="line">    public  static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">        String str1&#x3D;input.next();</span><br><span class="line">        String str2&#x3D;input.next();</span><br><span class="line">        int m&#x3D;son(str1,str2);&#x2F;&#x2F;传两个字符串</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">    public  static  int  son(String str1,String str2)</span><br><span class="line">    &#123;</span><br><span class="line">    &#x2F;&#x2F;因为要形成上图的表格，所以给两个字符串头多添了一个字符</span><br><span class="line">    &#x2F;&#x2F;使第一行和第一列都变为0</span><br><span class="line">        String s1&#x3D;&quot;2&quot;+str1;</span><br><span class="line">        String s2&#x3D;&quot;1&quot;+str2;</span><br><span class="line">        int [][]check&#x3D;new int[str1.length()+1][str2.length()+1];</span><br><span class="line">        for(int i&#x3D;0;i&lt;s1.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;s2.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i&#x3D;&#x3D;0||j&#x3D;&#x3D;0)&#x2F;&#x2F;定义第一个格子为0</span><br><span class="line">                &#123;</span><br><span class="line">                    check[i][j]&#x3D;0;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(s1.charAt(i)&#x3D;&#x3D;s2.charAt(j))</span><br><span class="line">                &#123;</span><br><span class="line">                    check[i][j]&#x3D;(check[i-1][j-1]+1);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;  &#x2F;&#x2F;取上一个数和左边的数中大的数</span><br><span class="line">                    if(check[i-1][j]&gt;check[i][j-1])</span><br><span class="line">                        check[i][j]&#x3D;check[i-1][j];</span><br><span class="line">                    else</span><br><span class="line">                        check[i][j]&#x3D;check[i][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回数组的最后一位</span><br><span class="line">        return  check[s1.length()-1][s2.length()-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-最长公共子串"><a href="#2-最长公共子串" class="headerlink" title="2.最长公共子串"></a>2.最长公共子串</h4><p>对于两个字符串，请设计一个时间复杂度为O(m*n)的算法(这里的m和n为两串的长度)，求出两串的最长公共子串的长度。这里的最长公共子串的定义为两个序列U1,U2,..Un和V1,V2,…Vn，其中Ui + 1 == Ui+1,Vi + 1 == Vi+1，同时Ui == Vi。</p><p>给定两个字符串A和B，同时给定两串的长度n和m。</p><p>测试样例：<br>“1AB2345CD”,9,”12345EF”,7</p><p>返回：4</p><p><img src="/images/loading/loading.gif" data-original="https://img-blog.csdn.net/20140901134800948?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDM5NzM2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">string getLCS(string str1, string str2) &#123;</span><br><span class="line">	vector&lt;vector&lt;int&gt; &gt; record(str1.length(), vector&lt;int&gt;(str2.length()));</span><br><span class="line">	int maxLen &#x3D; 0, maxEnd &#x3D; 0;</span><br><span class="line">	for(int i&#x3D;0; i&lt;static_cast&lt;int&gt;(str1.length()); ++i)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; static_cast&lt;int&gt;(str2.length()); ++j) &#123;</span><br><span class="line">			if (str1[i] &#x3D;&#x3D; str2[j]) &#123;</span><br><span class="line">				if (i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0) &#123;</span><br><span class="line">					record[i][j] &#x3D; 1;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					record[i][j] &#x3D; record[i - 1][j - 1] + 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				record[i][j] &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">			if (record[i][j] &gt; maxLen) &#123;</span><br><span class="line">				maxLen &#x3D; record[i][j];</span><br><span class="line">				maxEnd &#x3D; i; &#x2F;&#x2F;若记录i,则最后获取LCS时是取str1的子串</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	return str1.substr(maxEnd - maxLen + 1, maxLen);</span><br></pre></td></tr></table></figure><h4 id="3-求一个字符串最长回文子串-手写代码"><a href="#3-求一个字符串最长回文子串-手写代码" class="headerlink" title="3.求一个字符串最长回文子串(手写代码)"></a>3.求一个字符串最长回文子串(手写代码)</h4><p>子串：小于等于原字符串长度由原字符串中任意个连续字符组成的子序列</p><p>回文：关于中间字符对称的文法，即“aba”(单核)、“cabbac”(双核)等</p><p>最长回文子串：1.寻找回文子串；2.该子串是回文子串中长度最长的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 求最长回文子串</span><br><span class="line"> * @author autumn_leaf</span><br><span class="line"> * @Date 2019&#x2F;03&#x2F;23</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PalindSubstring &#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">		while(sc.hasNext()) &#123;</span><br><span class="line">			String s &#x3D; sc.nextLine();</span><br><span class="line">			&#x2F;&#x2F;将一串字符转化为字符数组</span><br><span class="line">			char[] str &#x3D; s.toCharArray();</span><br><span class="line">			int len &#x3D; str.length;</span><br><span class="line">			int[][] dp &#x3D; new int[len+10][len+10];</span><br><span class="line">			&#x2F;&#x2F;dp数组初始化</span><br><span class="line">			for(int i&#x3D;0; i&lt;len; i++) &#123;</span><br><span class="line">				dp[i][i] &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;dp中相邻元素</span><br><span class="line">			for(int i&#x3D;0; i&lt;len-1; i++) &#123;</span><br><span class="line">				if(str[i] &#x3D;&#x3D; str[i+1]) &#123;</span><br><span class="line">					dp[i][i+1] &#x3D; 2;</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					dp[i][i+1] &#x3D; 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;**dp中至少相隔一个元素*&#x2F;</span><br><span class="line">			&#x2F;**k代表相隔的区间长度*&#x2F;</span><br><span class="line">			for(int k&#x3D;2; k&lt;len; k++) &#123;</span><br><span class="line">				&#x2F;&#x2F;i代表区间起始位置</span><br><span class="line">				for(int i&#x3D;0; i+k&lt;len; i++) &#123;</span><br><span class="line">					&#x2F;&#x2F;j代表区间末尾位置</span><br><span class="line">					int j &#x3D; i+k;</span><br><span class="line">					if(str[i] &#x3D;&#x3D; str[j]) &#123;</span><br><span class="line">						dp[i][j] &#x3D; dp[i+1][j-1] + 2;</span><br><span class="line">					&#125;else &#123;</span><br><span class="line">						dp[i][j] &#x3D;Math.max(dp[i+1][j], dp[i][j-1]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(dp[0][len-1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Manacher算法用一个辅助数组Len[i]表示以字符T[i]为中心的最长回文字串的最右字符到T[i]的长度，比如以T[i]为中心的最长回文字串是T[l,r],那么Len[i]=r-i+1。</p><p>对于上面的例子，可以得出Len[i]数组为:</p><p><img src="/images/loading/loading.gif" data-original="http://img.blog.csdn.net/20141221160159348" alt></p><p>Len数组有一个性质，那就是Len[i]-1就是该回文子串在原字符串S中的长度，至于证明，首先在转换得到的字符串T中，所有的回文字串的长度都为奇数，那么对于以T[i]为中心的最长回文字串，其长度就为2*Len[i]-1,经过观察可知，T中所有的回文子串，其中分隔符的数量一定比其他字符的数量多1，也就是有Len[i]个分隔符，剩下Len[i]-1个字符来自原字符串，所以该回文串在原字符串中的长度就为Len[i]-1。</p><p>有了这个性质，那么原问题就转化为求所有的Len[i]。下面介绍如何在线性时间复杂度内求出所有的Len。</p><h4 id="4-硬币表示"><a href="#4-硬币表示" class="headerlink" title="4.硬币表示"></a>4.硬币表示</h4><p>有数量不限的硬币，币值为25分、10分、5分和1分，请编写代码计算n分有几种表示法。</p><p>给定一个int n，请返回n分有几种表示法。保证n小于等于100000，为了防止溢出，请将答案Mod 1000000007。</p><p>测试样例：<br>6</p><p>返回：2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int fun(int n, int coin)</span><br><span class="line">    &#123;</span><br><span class="line">        int nextcoin&#x3D;0;</span><br><span class="line">        switch(coin)</span><br><span class="line">        &#123;</span><br><span class="line">        case 25:</span><br><span class="line">            nextcoin&#x3D;10; break;</span><br><span class="line">        case 10:</span><br><span class="line">            nextcoin&#x3D;5; break;</span><br><span class="line">        case 5:</span><br><span class="line">            nextcoin&#x3D;1; break;</span><br><span class="line">        case 1:</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        int res&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i*coin&lt;&#x3D;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+&#x3D;fun(n-i*coin, nextcoin)%1000000007;</span><br><span class="line">        &#125;</span><br><span class="line">        return res%1000000007;&#x2F;&#x2F;%1000000007</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="5-字符混编"><a href="#5-字符混编" class="headerlink" title="5.字符混编"></a>5.字符混编</h4><p>A、B和C。如果C包含且仅包含来自A和B的所有字符，而且在C中属于A的字符之间保持原来在A中的顺序，属于B的字符之间保持原来在B中的顺序，那么称C是A和B的混编。实现一个函数，判断C是否是A和B的混编。</p><p>给定三个字符串A,B和C，及他们的长度。请返回一个bool值，代表C是否是A和B的混编。保证三个串的长度均小于等于100。</p><p>测试样例：<br>“ABC”,3,”12C”,3,”A12BCC”,6</p><p>返回：true</p><p><img src="/images/loading/loading.gif" data-original="http://uploadfiles.nowcoder.com/images/20150807/277064_1438943576180_1.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Mixture &#123;</span><br><span class="line">    public boolean chkMixture(String A, int n, String B, int m, String C, int v) &#123;</span><br><span class="line">        &#x2F;&#x2F; 边界情况处理</span><br><span class="line">        if (m + n !&#x3D; v)</span><br><span class="line">            return false;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F; 默认初始化为false</span><br><span class="line">        boolean[][] dp &#x3D; new boolean[101][101];</span><br><span class="line"> </span><br><span class="line">        dp[0][0] &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 初始化第0行</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;</span><br><span class="line">            if (B.charAt(i - 1) &#x3D;&#x3D; C.charAt(i - 1))</span><br><span class="line">                dp[0][i] &#x3D; true;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 初始化第0列</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">            if (A.charAt(i - 1) &#x3D;&#x3D; C.charAt(i - 1))</span><br><span class="line">                dp[i][0] &#x3D; true;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 状态转移方程</span><br><span class="line">         *  dp[i][j] &#x3D;</span><br><span class="line">         *</span><br><span class="line">         *  case 1: dp[i][j-1] &#x3D;&#x3D; true &amp;&amp; B[j-1] &#x3D;&#x3D; C[i+j-1]</span><br><span class="line">         * </span><br><span class="line">         *  case 2: dp[i-1][j] &#x3D;&#x3D; true &amp;&amp; A[i-1] &#x3D;&#x3D; C[i+j-1]</span><br><span class="line">         *</span><br><span class="line">         *&#x2F;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; m; ++j) &#123;</span><br><span class="line">                if (!dp[i][j]) &#123;</span><br><span class="line">                    &#x2F;&#x2F; dp[i-1][j] &#x3D; true &amp;&amp; A[i-1] &#x3D;&#x3D; C[i+j-1]</span><br><span class="line">                    if (dp[i - 1][j] &amp;&amp; A.charAt(i - 1) &#x3D;&#x3D; C.charAt(i + j - 1))</span><br><span class="line">                        dp[i][j] &#x3D; true;</span><br><span class="line"> </span><br><span class="line">                    &#x2F;&#x2F; dp[i][j-1] &#x3D;&#x3D; true &amp;&amp; B[j-1] &#x3D;&#x3D; C[i+j-1]</span><br><span class="line">                    if (dp[i][j - 1] &amp;&amp; B.charAt(j - 1) &#x3D;&#x3D; C.charAt(i + j - 1))</span><br><span class="line">                        dp[i][j] &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、链表"><a href="#七、链表" class="headerlink" title="七、链表"></a>七、链表</h3><h4 id="1-如何合并两个有序链表-手写代码"><a href="#1-如何合并两个有序链表-手写代码" class="headerlink" title="1.如何合并两个有序链表(手写代码)"></a>1.如何合并两个有序链表(手写代码)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*Definition for singly-linked list</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;递归</span><br><span class="line"></span><br><span class="line">class ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line"> </span><br><span class="line">    ListNode(int x)&#123;</span><br><span class="line">        val &#x3D; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        if (l1 &#x3D;&#x3D; null) return l2;</span><br><span class="line">        if (l2 &#x3D;&#x3D; null) return l1;</span><br><span class="line"> </span><br><span class="line">        ListNode head &#x3D; null;</span><br><span class="line">        if (l1.val &lt;&#x3D; l2.val)&#123;</span><br><span class="line">            head &#x3D; l1;</span><br><span class="line">            head.next &#x3D; mergeTwoLists(l1.next, l2);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head &#x3D; l2;</span><br><span class="line">            head.next &#x3D; mergeTwoLists(l1, l2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-反转链表（手写代码）"><a href="#2-反转链表（手写代码）" class="headerlink" title="2.反转链表（手写代码）"></a>2.反转链表（手写代码）</h4><p>递归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Node reverse(Node head) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null)</span><br><span class="line">        return head;</span><br><span class="line">    Node temp &#x3D; head.next;</span><br><span class="line">    Node newHead &#x3D; reverse(head.next);</span><br><span class="line">    temp.next &#x3D; head;</span><br><span class="line">    head.next &#x3D; null;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static Node reverseList(Node node) &#123;</span><br><span class="line">    Node pre &#x3D; null;</span><br><span class="line">    Node next &#x3D; null;</span><br><span class="line">    while (node !&#x3D; null) &#123;</span><br><span class="line">        next &#x3D; node.next;</span><br><span class="line">        node.next &#x3D; pre;</span><br><span class="line">        pre &#x3D; node;</span><br><span class="line">        node &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-判断一个链表是否为回文链表，说出你的思路并手写代码"><a href="#3-判断一个链表是否为回文链表，说出你的思路并手写代码" class="headerlink" title="3.判断一个链表是否为回文链表，说出你的思路并手写代码"></a>3.判断一个链表是否为回文链表，说出你的思路并手写代码</h4><ol><li>简单粗暴的做法就是：将链表反转生成一个新的链表，然后依次比较两个链表的每一个元素，如果均相等则是回文结构。这里我们可以不用反转链表，而是借助一个栈，将链表的数据全部压入栈中，然后从栈顶依次取出元素和原链表头部取出元素比较。栈的特点是先进后出，正好可以构成一个反转的链表。<br><img src="/images/loading/loading.gif" data-original="https://img-blog.csdnimg.cn/20190702222955833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlaW5pZmk=,size_16,color_FFFFFF,t_70" alt></li><li>根据回文结构的特点，链表前半部分和后半部分反转之后顺序是一致的，所以可以考虑不用反转整个链表，而是后半部分。要找到后半部分，需要两个指针，他们都从头部开始遍历，一个指针遍历的速度是另一个指针的两倍，这样，当快的指针遍历完成的时候，慢的指针位置就正好是中间位置。再把中间位置到链表尾部的所有节点放入一个堆栈，构成一个反转的链表，后面的判断就回到第一个办法的判断了。<br><img src="/images/loading/loading.gif" data-original="https://img-blog.csdnimg.cn/20190702223336946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlaW5pZmk=,size_16,color_FFFFFF,t_70" alt></li></ol><h4 id="4-如何判断两个单向链表是否相交"><a href="#4-如何判断两个单向链表是否相交" class="headerlink" title="4.如何判断两个单向链表是否相交"></a>4.如何判断两个单向链表是否相交</h4><p>判断两个链表是否相交</p><p>1）方法1：</p><p>链表相交之后，后面的部分节点全部共用，可以用2个指针分别从这两个链表头部走到尾部，最后判断尾部指针的地址信息是否一样，若一样则代表链表相交！</p><p>2）方法2：</p><p>可以把其中一个链表的所有节点地址信息存到数组中，然后把另一个链表的每一个节点地址信息遍历数组，若相等，则跳出循环，说明链表相交。进一步优化则是进行hash排序，建立hash表。</p><h3 id="八、高级算法"><a href="#八、高级算法" class="headerlink" title="八、高级算法"></a>八、高级算法</h3><h4 id="1-单向加密"><a href="#1-单向加密" class="headerlink" title="1.单向加密"></a>1.单向加密</h4><p>1）定义</p><p>单向加密又称为不可逆加密算法，其密钥是由加密散列函数生成的。</p><p>2）例子</p><ul><li><p>MD5（Message Digest Algorithm 5）：是RSA数据安全公司开发的一种单向散列算法，非可逆，相同的明文产生相同的密文；</p></li><li><p>SHA（Secure Hash Algorithm）：可以对任意长度的数据运算生成一个160位的数值。其变种由SHA192，SHA256，SHA384等；</p></li></ul><p>3）算法特征：</p><p>输入一样，输出必然相同；</p><p>雪崩效应，输入的微小改变，将会引起结果的巨大变化；</p><p>定长输出，无论原始数据多大，结果大小都是相同的；</p><p>不可逆，无法根据特征码还原原来的数据；</p><h4 id="2-对称加密"><a href="#2-对称加密" class="headerlink" title="2.对称加密"></a>2.对称加密</h4><p>采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。</p><p>特点：</p><p>1、加密方和解密方使用同一个密钥；</p><p>2、加密解密的速度比较快，适合数据比较长时的使用；</p><p>3、密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦；</p><p>优点：对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。</p><p>缺点：对称加密算法的缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p><h4 id="3-非对称加密"><a href="#3-非对称加密" class="headerlink" title="3.非对称加密"></a>3.非对称加密</h4><p>非对称密钥加密也称为公钥加密，由一对公钥和私钥组成。公钥是从私钥提取出来的。可以用公钥加密，再用私钥解密，这种情形一般用于公钥加密，当然也可以用私钥加密，用公钥解密。常用于数字签名，因此非对称加密的主要功能就是加密和数字签名。</p><p>特征：</p><p>1）秘钥对，公钥(public key)和私钥(secret key)</p><p>2）主要功能：加密和签名</p><p>发送方用对方的公钥加密，可以保证数据的机密性（公钥加密）。</p><p>发送方用自己的私钥加密，可以实现身份验证（数字签名）。</p><p>3）公钥加密算法很少用来加密数据，速度太慢，通常用来实现身份验证。</p><p>常用的非对称加密算法</p><p>RSA：由 RSA公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；既可以实现加密，又可以实现签名。</p><p>DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准）。</p><p>ECC（Elliptic Curves Cryptography）：椭圆曲线密码编码。</p><h4 id="4-LRU缓存"><a href="#4-LRU缓存" class="headerlink" title="4.LRU缓存"></a>4.LRU缓存</h4><p>LRU(最近最少使用)算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高</p><p>实现：使用一个链表保存缓存数据，将新数据插入到头部，每当缓存命中时，则将命中的数据移动到链表头部，当链表满的时候，将链表尾部的数据丢弃。</p><h3 id="九、字符串处理"><a href="#九、字符串处理" class="headerlink" title="九、字符串处理"></a>九、字符串处理</h3><h4 id="1-给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c"><a href="#1-给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c" class="headerlink" title="1.给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c"></a>1.给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c</h4><p>使用哈希的思想，建立256个bool数组array，初始都为false,从头开始扫描字符串，扫到一个，将以其ascii码为下标的元素置true。例如扫描到A的时候，执行：array[‘A’]=true。第二边扫描，扫到一个字母就以其ascii码为下标，去array数组中看其值，如果是true,返回改字母，如果是false，继续扫描下一个字母。</p><h3 id="十、贪心算法"><a href="#十、贪心算法" class="headerlink" title="十、贪心算法"></a>十、贪心算法</h3><h4 id="1-安置路灯"><a href="#1-安置路灯" class="headerlink" title="1.安置路灯"></a>1.安置路灯</h4><p>小Q正在给一条长度为n的道路设计路灯安置方案。</p><p>为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用’.’表示, 不需要照亮的障碍物格子用’X’表示。</p><p>小Q现在要在道路上设置一些路灯, 对于安置在pos位置的路灯, 这盏路灯可以照亮pos - 1, pos, pos + 1这三个位置。</p><p>小Q希望能安置尽量少的路灯照亮所有’.’区域, 希望你能帮他计算一下最少需要多少盏路灯。</p><p>输入描述:<br>输入的第一行包含一个正整数t(1 &lt;= t &lt;= 1000), 表示测试用例数<br>接下来每两行一个测试数据, 第一行一个正整数n(1 &lt;= n &lt;= 1000),表示道路的长度。<br>第二行一个字符串s表示道路的构造,只包含’.’和’X’。</p><p>输出描述:<br>对于每个测试用例, 输出一个正整数表示最少需要多少盏路灯。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        String string &#x3D; scanner.nextLine();</span><br><span class="line">        int caseNumber &#x3D; Integer.parseInt(string);</span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String nString &#x3D; scanner.nextLine();</span><br><span class="line">            int n &#x3D; Integer.parseInt(nString);</span><br><span class="line"></span><br><span class="line">            String road &#x3D; scanner.nextLine();</span><br><span class="line"></span><br><span class="line">            int result &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">                if (road.substring(i,i+1).equals(&quot;.&quot;))&#123;</span><br><span class="line">                    result++;</span><br><span class="line">                    i+&#x3D;2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(result);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十一、实战题目"><a href="#十一、实战题目" class="headerlink" title="十一、实战题目"></a>十一、实战题目</h3><h4 id="1-九宫格解锁方案（Vivo）"><a href="#1-九宫格解锁方案（Vivo）" class="headerlink" title="1.九宫格解锁方案（Vivo）"></a>1.九宫格解锁方案（Vivo）</h4><p>1、问题定义</p><p>问题很简单：安卓的手势解锁是3*3的点阵，在这个点阵上的解锁手势一共有多少种情况？这里一个合格的解锁手势轨迹必须满足以下两个条件：</p><ul><li>至少连接点阵中的四个点。</li><li>手势的轨迹不能跨过一个还没有经过的节点。</li><li>不允许重复经过某个定点两次。</li></ul><p>2、问题转化</p><p>为了方便，这里将点阵中的每个点用一个数字代替，1到9九个数字分别代表点阵中的一个点。这样，一个解锁手势可以对应到一个由1到9数字组成的字符串(该字符串中没有重复)。</p><p>去掉第二个限制条件，一种解锁手势正好对应一种1到9的排列。连接四个点的解锁手势的所有情况就是9选4的全排列，连接5个点的就是9选5的全排列，以此类推。</p><p>计算全排列的比较容易，接下来要解决的就是如何剔除那些不符合限制条件(手势的轨迹不能跨过一个还没有经过的节点)的手势。在3*3的点阵中，不符合条件的情况(也就是两个点的连接过程中跨过点的情况)比较有限，这里我们将其全部列出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from itertools import chain, permutations</span><br><span class="line"></span><br><span class="line">impossible &#x3D; &#123;&#39;13&#39;: &#39;2&#39;, &#39;46&#39;: &#39;5&#39;, &#39;79&#39;: &#39;8&#39;, &#39;17&#39;: &#39;4&#39;, &#39;28&#39;: &#39;5&#39;, &#39;39&#39;: &#39;6&#39;, &#39;19&#39;: &#39;5&#39;, &#39;37&#39;: &#39;5&#39;, &#39;31&#39;: &#39;2&#39;, &#39;64&#39;: &#39;5&#39;, &#39;97&#39;: &#39;8&#39;, &#39;71&#39;: &#39;4&#39;, &#39;82&#39;: &#39;5&#39;, &#39;93&#39;: &#39;6&#39;, &#39;91&#39;: &#39;5&#39;, &#39;73&#39;: &#39;5&#39;&#125;</span><br><span class="line"></span><br><span class="line">def counts_n(n):</span><br><span class="line">        iterlst &#x3D; permutations(&#39;123456789&#39;, n)</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        for i in iterlst:</span><br><span class="line">                stri &#x3D; &#39;&#39;.join(i)</span><br><span class="line">                for k, v in impossible.items():</span><br><span class="line">                        if k in stri and v not in stri[:stri.find(k)]:</span><br><span class="line">                                break</span><br><span class="line">                else: </span><br><span class="line">                        count +&#x3D; 1</span><br><span class="line">        return count</span><br><span class="line">   </span><br><span class="line">sum &#x3D; 0  </span><br><span class="line">print(&quot;len  num  sum&quot;)</span><br><span class="line">for i in range(4,10):</span><br><span class="line">        temp &#x3D; counts_n(i)</span><br><span class="line">        sum &#x3D; sum + temp</span><br><span class="line">        print(str(i)+&quot;  &quot;+str(temp)+&quot;  &quot;+str(sum))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">len  num  sum</span><br><span class="line">4  1624  1624</span><br><span class="line">5  7152  8776</span><br><span class="line">6  26016  34792</span><br><span class="line">7  72912  107704</span><br><span class="line">8  140704  248408</span><br><span class="line">9  140704  389112</span><br></pre></td></tr></table></figure><h4 id="2-爬楼梯算法"><a href="#2-爬楼梯算法" class="headerlink" title="2.爬楼梯算法"></a>2.爬楼梯算法</h4><p>第一种题目（递归实现）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设一个楼梯有 N 阶台阶，人每次最多可以跨 M 阶，求总共的爬楼梯方案数。</span><br><span class="line"></span><br><span class="line">例如楼梯总共有3个台阶，人每次最多跨2个台阶，也就是说人每次可以走1个，也可以走2个，但最多不会超过2个，那么楼梯总共有这么几种走法：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static int calculateCount(int ladder, int maxJump) &#123;</span><br><span class="line">    int jump &#x3D; 0;</span><br><span class="line">    if (ladder &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ladder &gt;&#x3D; maxJump) &#123;</span><br><span class="line">        &#x2F;&#x2F; 剩下的楼梯大于最大可跳跃数</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; maxJump; i++) &#123;</span><br><span class="line">            jump +&#x3D; calculateCount(ladder - i, maxJump);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 剩下的楼梯不足最大可跳跃数</span><br><span class="line">        jump &#x3D; calculateCount(ladder, ladder);</span><br><span class="line">    &#125;</span><br><span class="line">    return jump;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题有一道变体（非递归方式实现）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设一个楼梯有 N 阶台阶，人每次最多可以跨 2 阶，求总共的爬楼梯方案数，要求不用递归实现</span><br></pre></td></tr></table></figure><p>随着楼梯数n的增加，爬法总数呈现斐波那契数列规律增加，即f（n） = f（n-1） + f（n-2）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param ladder 台阶数量</span><br><span class="line"> * @return 总的爬法</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int count(int ladder) &#123;</span><br><span class="line">    if (ladder &#x3D;&#x3D; 1 || ladder &#x3D;&#x3D; 2) &#123;</span><br><span class="line">        return ladder;</span><br><span class="line">    &#125;</span><br><span class="line">    int n1 &#x3D; 1;</span><br><span class="line">    int n2 &#x3D; 2;</span><br><span class="line">    for (int i &#x3D; 3; i &lt;&#x3D; ladder; i++) &#123;</span><br><span class="line">        int tmp &#x3D; n2;</span><br><span class="line">        n2 &#x3D; n1 + n2;</span><br><span class="line">        n1 &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-两数之和"><a href="#3-两数之和" class="headerlink" title="3.两数之和"></a>3.两数之和</h4><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>1.解法一：使用for循环遍历</p><p>2.解法二：使用HashMap的性质</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if (map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                return new int[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三数之和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     *      时间复杂度：n2</span><br><span class="line">     *      空间复杂度：1</span><br><span class="line">     * 代码执行过程：</span><br><span class="line">     *</span><br><span class="line">     * 总结：</span><br><span class="line">     *</span><br><span class="line">     * ***********************************&#x2F;</span><br><span class="line">public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line"></span><br><span class="line">    if (nums &#x3D;&#x3D; null || nums.length &lt; 3) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">    int comp &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    int result &#x3D; Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果和之前那个数据相同，则会是重复事件</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int leftIndex &#x3D; i + 1;</span><br><span class="line">        int rightIndex &#x3D; nums.length - 1;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 滑动列表</span><br><span class="line">        while (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">            int tmp &#x3D; nums[leftIndex] + nums[rightIndex] + nums[i];</span><br><span class="line">            if (comp &gt; Math.abs(tmp - target)) &#123;</span><br><span class="line">                comp &#x3D; Math.abs(tmp - target);</span><br><span class="line">                result &#x3D; tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (tmp &gt; target) &#123;</span><br><span class="line">                rightIndex--;</span><br><span class="line">            &#125; else if (tmp &lt; target) &#123;</span><br><span class="line">                leftIndex++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 差值为0，最爽了，直接返回</span><br><span class="line">                return tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-最大回撤"><a href="#4-最大回撤" class="headerlink" title="4.最大回撤"></a>4.最大回撤</h4><p>题目形式：有一个数组，求其中两个数x,y，满足x的索引小于y的索引，使得 x-y 最大。例如 arr = [3,7,2,6,4,1,9,8,5]， 最大回撤是6，对应的x=7,y=1。</p><p>解法一</p><p>算法实现有很多，简单粗暴的方法比如把每一天的值和其他天作差值计算，找到差值最大的那一天，但这个方法并不好。从时间复杂度上看是O(n!)，差不多算是最差的了。</p><p>解法二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 计算最大回撤</span><br><span class="line"> * </span><br><span class="line"> * @author qcy</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">class FundTools &#123;</span><br><span class="line"> </span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 由净值序列x，直接计算最大回撤</span><br><span class="line">	 * </span><br><span class="line">	 * @param x</span><br><span class="line">	 *            累计份额净值序列</span><br><span class="line">	 * @return 最大回撤</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public double calc_max_dd(double[] x) &#123;</span><br><span class="line">		double max_unit_value &#x3D; x[0];</span><br><span class="line">		double max_dd &#x3D; 0;</span><br><span class="line">		double dd &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">		for (int i &#x3D; 1; i &lt; x.length; i++) &#123;</span><br><span class="line">			max_unit_value &#x3D; Math.max(x[i], max_unit_value);</span><br><span class="line">			dd &#x3D; x[i] &#x2F; max_unit_value - 1;</span><br><span class="line">			max_dd &#x3D; Math.min(dd, max_dd);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		return max_dd;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 根据每日收盘后份额净值和截止前一日的最大回撤、最高水位，计算今日的最大回撤</span><br><span class="line">	 * </span><br><span class="line">	 * @param max_dd</span><br><span class="line">	 *            截止到i-1日的最大回撤</span><br><span class="line">	 * @param max_unit_value</span><br><span class="line">	 *            截止到i-1日的最高累计份额净值</span><br><span class="line">	 * @param today_unit_value</span><br><span class="line">	 *            i日的累计份额净值</span><br><span class="line">	 * @return 第i日的最大回撤</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public double calc_max_dd(double max_dd, double max_unit_value,</span><br><span class="line">			double today_unit_value) &#123;</span><br><span class="line">		max_unit_value &#x3D; Math.max(max_unit_value, today_unit_value);</span><br><span class="line">		double dd &#x3D; today_unit_value &#x2F; max_unit_value - 1;</span><br><span class="line">		return Math.min(dd, max_dd);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-合并两个有序数组"><a href="#5-合并两个有序数组" class="headerlink" title="5.合并两个有序数组"></a>5.合并两个有序数组</h4><p>题目形式：</p><p>给定两个按升序排列的有序数组，将它们合并成一个新的有序数组。例如：a = [1,2,6,8], b = [2,4,7,10]，输出为 arr = [1,2,2,4,6,7,8,10]</p><p>解法一：开个新的数组，填充上去</p><p>解法二：因原数组都是有序数组，只需要从两个数组的最后一个元素开始对比，寻找最大值赋值给最终数组。</p><p>如果数组二元素耗尽，则得到最终数组。<br>如果数组一元素耗尽，则需要将原数组二剩余元素赋值给最终数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        if(m &#x3D;&#x3D;0 ) &#123;</span><br><span class="line">            System.arraycopy(nums2,0,nums1,0, n);</span><br><span class="line">        &#125;</span><br><span class="line">        int i1 &#x3D; m -1;</span><br><span class="line">        int i2 &#x3D; n -1;</span><br><span class="line">        while(i2&gt;&#x3D;0)&#123;</span><br><span class="line">            if(i1 &lt; 0)&#123;</span><br><span class="line">                System.arraycopy(nums2,0,nums1,0,i2+1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums1[i1] &gt;&#x3D; nums2[i2]) &#123;</span><br><span class="line">                nums1[i1 + i2 +1]&#x3D;nums1[i1--];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                nums1[i1 + i2 +1]&#x3D;nums2[i2--];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-最大连续子数组和"><a href="#6-最大连续子数组和" class="headerlink" title="6.最大连续子数组和"></a>6.最大连续子数组和</h4><p>题目形式：</p><p>给定一个数组，求其最大连续子数组的和。例如：arr = [1,5,-10,2,5,-3,2,6,-3,1]. 输出为：12。对应的连续子数组为 [2,5,-3,2,6]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int maxSunArray(int[] array) &#123;</span><br><span class="line">       if (array.length&#x3D;&#x3D;0 || array&#x3D;&#x3D;null) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">      int Sum &#x3D; 0;     </span><br><span class="line">      int max &#x3D; 0;            </span><br><span class="line">      for (int i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">          </span><br><span class="line">          if(Sum&lt;&#x3D;0)&#123;      &#x2F;&#x2F;如果当前连续n项的和小于等于0,则没必要与后面的元素相加</span><br><span class="line">              Sum &#x3D; array[i];      &#x2F;&#x2F;Sum重新赋值</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">              Sum +&#x3D; array[i];     &#x2F;&#x2F;如果Sum的值大于0,则继续与后面的元素相加,</span><br><span class="line">          &#125;</span><br><span class="line">          if(Sum&gt;max)&#123;         &#x2F;&#x2F;每次改变Sum的值都有与max进行比较</span><br><span class="line">              max &#x3D; Sum;       &#x2F;&#x2F;如果Sum的值大于max,则将Sum的值赋值给max</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>动态规划</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解法二：使用动态规划:</span><br><span class="line">&#x2F;&#x2F;F（i）：以array[i]为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变</span><br><span class="line">&#x2F;&#x2F;F（i）&#x3D;max（F（i-1）+array[i] ， array[i]）</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public  int FindGreatestSumOfSubArray(int[] array) &#123;</span><br><span class="line">            int res &#x3D; array[0]; &#x2F;&#x2F;记录当前所有子数组的和的最大值</span><br><span class="line">            int max &#x3D; array[0]; &#x2F;&#x2F;包含array[i]的连续数组最大值</span><br><span class="line">            for (int i &#x3D; 1; i &lt; array.length; i++) &#123;</span><br><span class="line">                 max&#x3D;Math.max(max+array[i], array[i]);</span><br><span class="line">                 res&#x3D;Math.max(max, res);</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-最长不重复子串"><a href="#7-最长不重复子串" class="headerlink" title="7.最长不重复子串"></a>7.最长不重复子串</h4><p>题目形式：</p><p>给定一个字符串，找出没有重复字符的最长的子串。例如输入“abcbefgf”，答案是 “cbefg”。</p><p>我的方法：（时间复杂度较大）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int start, end;</span><br><span class="line">        String count &#x3D; &quot;&quot;;</span><br><span class="line">        String str &#x3D; &quot;&quot;;</span><br><span class="line">        for(start&#x3D;0; start&lt;s.length(); start++)&#123;</span><br><span class="line">            for(end&#x3D;start+1; end&lt;&#x3D;s.length(); end++)&#123;</span><br><span class="line">                str &#x3D; s.substring(start, end);</span><br><span class="line">                if(end &#x3D;&#x3D; s.length())&#123;</span><br><span class="line">                    if(count.length() &lt; str.length())&#123;&#x2F;&#x2F;对比长度</span><br><span class="line">                        count &#x3D; str;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(str.contains(s.substring(end, end+1)))&#123;&#x2F;&#x2F;当有重复时候，处理，跳出循环让start++</span><br><span class="line">                        if(count.length() &lt; str.length())&#123;&#x2F;&#x2F;对比长度</span><br><span class="line">                            count &#x3D; str;</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2、滑动窗口思想：如果确定子串s[i,j]（假设表示字符串的第i个字符到第j-1个字符表示的子串），那么只需要比较s[j]是否与子串s[i,j]重复即可</p><p>若重复：记录此时滑动窗口大小，并与最大滑动窗口比较，赋值。然后滑动窗口大小重定义为1，头位置不变，并右移一个单位。</p><p>若不重复：滑动窗口头不变，结尾+1，整个窗口加大1个单位。继续比较下一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int n &#x3D; s.length();</span><br><span class="line">        Set&lt;Character&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        int ans &#x3D; 0, i &#x3D; 0, j &#x3D; 0;</span><br><span class="line">        while (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            &#x2F;&#x2F; try to extend the range [i, j]</span><br><span class="line">            if (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans &#x3D; Math.max(ans, j - i);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                set.remove(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用HashMap(这是一道动态规划+哈希查找的综合应用题)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int n &#x3D; s.length(), ans &#x3D; 0;</span><br><span class="line">        Map&lt;Character, Integer&gt; map &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F; current index of character</span><br><span class="line">        &#x2F;&#x2F; try to extend the range [i, j]</span><br><span class="line">        for (int j &#x3D; 0, i &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i &#x3D; Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            ans &#x3D; Math.max(ans, j - i + 1);</span><br><span class="line">            map.put(s.charAt(j), j + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-全排列-这是一道动态规划-排列组合的综合应用题"><a href="#8-全排列-这是一道动态规划-排列组合的综合应用题" class="headerlink" title="8.全排列(这是一道动态规划+排列组合的综合应用题)"></a>8.全排列(这是一道动态规划+排列组合的综合应用题)</h4><p>题目形式：</p><p>给定一个数组，找出其所有可能的排列。例如: arr = [1,1,3]，输出为 [[1,1,3],[1,3,1],[3,1,1]]。</p><p>（1）确定第一位的字符<br>数组arr从start到end的所有记录都可以出现在第一个位置，所以直接一个for循环，考虑了这所有的情况。在for循环中，swap方法就是交换i和start位置的数，保证当前i指向的记录出现在第一个位置，也就是start指向的位置</p><p>（2）剩下的记录继续做全排列<br>这个就是一个递归函数的调用，只需要修改起始位置，也就是start+1，因为start的位置已经放了记录，所以只需要继续做从start+1到end的全排列即可<br>2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123; 1, 2, 3, 4 &#125;;</span><br><span class="line">        fullSort(arr, 0, arr.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void fullSort(int[] arr, int start, int end) &#123;</span><br><span class="line">        &#x2F;&#x2F; 递归终止条件</span><br><span class="line">        if (start &#x3D;&#x3D; end) &#123;</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; start; i &lt;&#x3D; end; i++) &#123;</span><br><span class="line">            swap(arr, i, start);</span><br><span class="line">            fullSort(arr, start + 1, end);</span><br><span class="line">            swap(arr, i, start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int tmp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展应用：图书排列</p><p>题目描述：将编号为1~10的10本书排放在书架上，要求编号相邻的书不能放在相邻的位置。<br>请计算一共有多少种不同的排列方案。</p><p>注意，需要提交的是一个整数，不要填写任何多余的内容。</p><p>解题思路：这个题目有很多解法，这里只说明用全排列怎么解决，先求出全排列，也就是所有的排列方案，然后去掉不满足条件的情况，也就是编号相邻的书不能相邻这一条件。</p><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class BookSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] &#x3D; &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;</span><br><span class="line">        fullSort(arr, 0, arr.length - 1);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int res &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    static void fullSort(int[] arr, int start, int end) &#123;</span><br><span class="line">        &#x2F;&#x2F; 递归终止条件</span><br><span class="line">        if (start &#x3D;&#x3D; end) &#123;</span><br><span class="line">            &#x2F;&#x2F; 求出了全排列的一种情况，然后检查是否满足条件</span><br><span class="line">            if (check(arr))</span><br><span class="line">                res++;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; start; i &lt;&#x3D; end; i++) &#123;</span><br><span class="line">            swap(arr, start, i);</span><br><span class="line">            fullSort(arr, start + 1, end);</span><br><span class="line">            swap(arr, start, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int tmp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static boolean check(int[] arr) &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (Math.abs(arr[i] - arr[i - 1]) &#x3D;&#x3D; 1)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-穷举法"><a href="#9-穷举法" class="headerlink" title="9.穷举法"></a>9.穷举法</h4><p>平面内有n个矩形, 第i个矩形的左下角坐标为(x1[i], y1[i]), 右上角坐标为(x2[i], y2[i])。<br>如果两个或者多个矩形有公共区域则认为它们是相互重叠的(不考虑边界和角落)。<br>请你计算出平面内重叠矩形数量最多的地方,有多少个矩形相互重叠。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args) throws IOException&#123;</span><br><span class="line">        BufferedReader bf &#x3D; new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        int num &#x3D; Integer.parseInt(bf.readLine());</span><br><span class="line">        int [] x1 &#x3D; new int[num];</span><br><span class="line">        int [] y1 &#x3D; new int[num];</span><br><span class="line">        int [] x2 &#x3D; new int[num];</span><br><span class="line">        int [] y2 &#x3D; new int[num];</span><br><span class="line">        if(num &lt; 2 || num &gt; 50)</span><br><span class="line">            return;</span><br><span class="line">        else&#123;</span><br><span class="line">            String [] str &#x3D; bf.readLine().split(&quot; +&quot;);</span><br><span class="line">            for(int i &#x3D; 0;i&lt;num;i++)&#123;</span><br><span class="line">                x1[i] &#x3D; Integer.parseInt(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            str &#x3D; bf.readLine().split(&quot; +&quot;);</span><br><span class="line">            for(int i &#x3D; 0;i&lt;num;i++)&#123;</span><br><span class="line">                y1[i] &#x3D; Integer.parseInt(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            str &#x3D; bf.readLine().split(&quot; +&quot;);</span><br><span class="line">            for(int i &#x3D; 0;i&lt;num;i++)&#123;</span><br><span class="line">                x2[i] &#x3D; Integer.parseInt(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            str &#x3D; bf.readLine().split(&quot; +&quot;);</span><br><span class="line">            for(int i &#x3D; 0;i&lt;num;i++)&#123;</span><br><span class="line">                y2[i] &#x3D; Integer.parseInt(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(solution(num,x1,y1,x2,y2));</span><br><span class="line">    &#125;</span><br><span class="line">    public static int solution(int num,int[]x1,int[]y1,int[]x2,int[]y2)&#123;</span><br><span class="line">        int temp&#x3D;0,max&#x3D;0;</span><br><span class="line">        for(int x:x1)</span><br><span class="line">            for(int y:y1)&#123;</span><br><span class="line">                for(int i &#x3D; 0; i&lt;num ; i++)&#123;</span><br><span class="line">                    if(x&gt;&#x3D;x1[i] &amp;&amp; x&lt;x2[i]&amp;&amp; y&gt;&#x3D;y1[i]&amp;&amp;y&lt;y2[i])</span><br><span class="line">                        temp++;</span><br><span class="line">                &#125;</span><br><span class="line">                if(max &lt; temp)</span><br><span class="line">                    max &#x3D; temp;</span><br><span class="line">                temp &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        return max;</span><br><span class="line">                 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目描述</p><p>牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为w。<br>牛牛家里一共有n袋零食, 第i袋零食体积为v[i]。<br>牛牛想知道在总体积不超过背包容量的情况下,他一共有多少种零食放法(总体积为0也算一种放法)。</p><p>输入描述:</p><p>输入包括两行<br>第一行为两个正整数n和w(1 &lt;= n &lt;= 30, 1 &lt;= w &lt;= 2 * 10^9),表示零食的数量和背包的容量。<br>第二行n个正整数v[i](0 &lt;= v[i] &lt;= 10^9),表示每袋零食的体积。</p><p>输出描述:<br>输出一个正整数, 表示牛牛一共有多少种零食放法。</p><p>注意：总数sum要表示成long型，不然会越界</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    private static int result &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String strTemp &#x3D; scanner.nextLine();</span><br><span class="line">            if (strTemp.isEmpty())&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] str &#x3D; strTemp.split(&quot; &quot;);</span><br><span class="line">            int n &#x3D; Integer.parseInt(str[0]);</span><br><span class="line">            int m &#x3D;Integer.parseInt(str[1]);</span><br><span class="line"></span><br><span class="line">            String [] size &#x3D; scanner.nextLine().split(&quot; &quot;);</span><br><span class="line">            int [] sizeArray &#x3D; new int[size.length];</span><br><span class="line">            long sum &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size.length; i++) &#123;</span><br><span class="line">                sizeArray[i] &#x3D; Integer.parseInt(size[i]);</span><br><span class="line">                sum +&#x3D; sizeArray[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (sum&lt;&#x3D;m)&#123;</span><br><span class="line">                System.out.println((int)Math.pow(2,n));</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                sum &#x3D; 0;</span><br><span class="line">                result +&#x3D;1;</span><br><span class="line">                dfs(sizeArray, sum, m, 0);</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void dfs(int[] arraySize, long sum, int m, int position)&#123;</span><br><span class="line">        if (position&lt;arraySize.length)&#123;</span><br><span class="line">            if (sum&gt;&#x3D;m)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(arraySize, sum, m, position+1);</span><br><span class="line"></span><br><span class="line">            if (sum+arraySize[position]&lt;m)&#123;</span><br><span class="line">                result +&#x3D;1;</span><br><span class="line">                sum +&#x3D; arraySize[position];</span><br><span class="line">                dfs(arraySize, sum,m,position+1);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目描述</p><p>小易有一些立方体，每个立方体的边长为1，他用这些立方体搭了一些塔。<br>现在小易定义：这些塔的不稳定值为它们之中最高的塔与最低的塔的高度差。<br>小易想让这些塔尽量稳定，所以他进行了如下操作：每次从某座塔上取下一块立方体，并把它放到另一座塔上。</p><p>注意，小易不会把立方体放到它原本的那座塔上，因为他认为这样毫无意义。<br>现在小易想要知道，他进行了不超过k次操作之后，不稳定值最小是多少。</p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行两个数n,k (1 &lt;&#x3D; n &lt;&#x3D; 100, 0 &lt;&#x3D; k &lt;&#x3D; 1000)表示塔的数量以及最多操作的次数。</span><br><span class="line">第二行n个数，ai(1 &lt;&#x3D; ai &lt;&#x3D; 104)表示第i座塔的初始高度。</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行两个数s, m，表示最小的不稳定值和操作次数(m &lt;&#x3D; k)</span><br><span class="line">接下来m行，每行两个数x,y表示从第x座塔上取下一块立方体放到第y座塔上。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">5 8 5</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><p>每次都把数组进行排序，然后最大值-1，最小值+1，用ArrayList记录这一操作的痕迹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String strTemp &#x3D; scanner.nextLine();</span><br><span class="line"></span><br><span class="line">            String[] str &#x3D; strTemp.split(&quot; &quot;);</span><br><span class="line">            int n &#x3D; Integer.parseInt(str[0]);</span><br><span class="line">            int k &#x3D;Integer.parseInt(str[1]);</span><br><span class="line"></span><br><span class="line">            String [] size &#x3D; scanner.nextLine().split(&quot; &quot;);</span><br><span class="line">            int[] sizeArray &#x3D; new int[n];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size.length; i++) &#123;</span><br><span class="line">                sizeArray[i] &#x3D; Integer.parseInt(size[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            int count &#x3D; 0;</span><br><span class="line">            ArrayList&lt;Integer&gt; list1 &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            ArrayList&lt;Integer&gt; list2 &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">                int max &#x3D; findMaxPosition(sizeArray);</span><br><span class="line">                int min &#x3D; findMinPosition(sizeArray);</span><br><span class="line"></span><br><span class="line">                if (sizeArray[max]-sizeArray[min]&lt;&#x3D;1)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                count++;</span><br><span class="line">                sizeArray[max]--;</span><br><span class="line">                sizeArray[min]++;</span><br><span class="line">                list1.add(max+1);</span><br><span class="line">                list2.add(min+1);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sizeArray[findMaxPosition(sizeArray)] - sizeArray[findMinPosition(sizeArray)] +&quot; &quot;+count);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; list1.size(); i++) &#123;</span><br><span class="line">                System.out.println(list1.get(i) + &quot; &quot; + list2.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int findMaxPosition(int[] arraySize)&#123;</span><br><span class="line">        int[] temp &#x3D; Arrays.copyOfRange(arraySize, 0,arraySize.length);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(temp);</span><br><span class="line">        int max &#x3D; temp[temp.length-1];</span><br><span class="line">        int position &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arraySize.length; i++) &#123;</span><br><span class="line">            if (max &#x3D;&#x3D; arraySize[i])&#123;</span><br><span class="line">                position &#x3D; i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int findMinPosition(int[] arraySize)&#123;</span><br><span class="line">        int[] temp &#x3D; Arrays.copyOfRange(arraySize, 0,arraySize.length);</span><br><span class="line">        Arrays.sort(temp);</span><br><span class="line">        int min &#x3D; temp[0];</span><br><span class="line">        int position &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arraySize.length; i++) &#123;</span><br><span class="line">            if (min &#x3D;&#x3D; arraySize[i])&#123;</span><br><span class="line">                position &#x3D; i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-数学"><a href="#10-数学" class="headerlink" title="10.数学"></a>10.数学</h4><p>今天上课，老师教了小易怎么计算加法和乘法，乘法的优先级大于加法，但是如果一个运算加了括号，那么它的优先级是最高的。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1+2*3&#x3D;7</span><br><span class="line">1*(2+3)&#x3D;5</span><br><span class="line">1*2*3&#x3D;6</span><br><span class="line">(1+2)*3&#x3D;9</span><br></pre></td></tr></table></figure><p>现在小易希望你帮他计算给定3个数a，b，c，在它们中间添加”+”， “*”， “(“， “)”符号，能够获得的最大值。</p><p>输入描述:<br>一行三个数a，b，c (1 &lt;= a, b, c &lt;= 10)</p><p>输出描述:<br>能够获得的最大值</p><p>规律：<br>最小的数小于等于1时，那么最大的结果便是a+b的和再乘以c<br>若最小数大于1，则最大结果必然是三数的积</p><h4 id="11-动态规划"><a href="#11-动态规划" class="headerlink" title="11.动态规划"></a>11.动态规划</h4><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;String&gt; Permutation(String str) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        if (str !&#x3D; null &amp;&amp; str.length() &gt; 0) &#123;</span><br><span class="line">            PermutationHelper(str.toCharArray(), 0, res);</span><br><span class="line">            Collections.sort(res);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void PermutationHelper(char[] cs, int i, ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">        if(i &#x3D;&#x3D; cs.length - 1) &#123; &#x2F;&#x2F;解空间的一个叶节点</span><br><span class="line">            list.add(String.valueOf(cs)); &#x2F;&#x2F;找到一个解</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for(int j &#x3D; i; j &lt; cs.length; ++j) &#123;</span><br><span class="line">                if(j &#x3D;&#x3D; i || cs[j] !&#x3D; cs[i]) &#123;</span><br><span class="line">                    SwapUtil.swap(cs, i, j);</span><br><span class="line">                    PermutationHelper(cs, i + 1, list);</span><br><span class="line">                    SwapUtil.swap(cs, i, j); &#x2F;&#x2F;复位</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="12-不用动态规划简单些"><a href="#12-不用动态规划简单些" class="headerlink" title="12.不用动态规划简单些"></a>12.不用动态规划简单些</h4><p>给出2n(n≤100)个自然数(小于等于30000)。将这2n个自然数排成一列，游戏双方A和B从中取数，只允许从两端取数。A先取，然后双方轮流取数。取完时，谁取得数字总和最大为取胜方；若双方和相等，属B胜。试问A方是否有必胜策略？</p><p>输入</p><p>共2行，第1行一个整数n；第2行有2*n个自然数。</p><p>输出</p><p>只有1行，若A有必胜策略，则输出“YES”，否则输出“NO”。</p><p>样例输入</p><p>4<br>7 9 3 6 4 2 5 3</p><p>样例输出</p><p>YES</p><p>思路</p><p>因为第一手先走的人有，可以全奇数项或者全拿偶数项，<br>所以只需要判断一下奇数项的和和偶数项的和是不是相等就可以了。</p><h4 id="13-拼多多笔试题"><a href="#13-拼多多笔试题" class="headerlink" title="13.拼多多笔试题"></a>13.拼多多笔试题</h4><p>高程图</p><p><a href="https://imgchr.com/i/82I09f" target="_blank" rel="noopener"><img src="/images/loading/loading.gif" data-original="https://s1.ax1x.com/2020/03/20/82I09f.png" alt="82I09f.png"></a></p><p>思路：使用机器人邹迷宫寻找递归的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Mian1 &#123;</span><br><span class="line">    private static int[][] array;</span><br><span class="line">    private static int N;</span><br><span class="line">    private static int M;</span><br><span class="line">    private static int first &#x3D; 0;</span><br><span class="line">    private static int left &#x3D; 1;</span><br><span class="line">    private static int right &#x3D; 2;</span><br><span class="line">    private static int up &#x3D; 3;</span><br><span class="line">    private static int down &#x3D; 4;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(&quot;5 5\n1 3 1 2 1\n2 1 3 1 1\n1 4 2 6 1\n1 3 1 3 1\n1 1 5 1 1\n&quot;);</span><br><span class="line">        while(scanner.hasNextLine())&#123;</span><br><span class="line">            String [] strings &#x3D; scanner.nextLine().split(&quot; &quot;);</span><br><span class="line">            N &#x3D; Integer.parseInt(strings[0]);</span><br><span class="line">            M &#x3D; Integer.parseInt(strings[1]);</span><br><span class="line">            array &#x3D; new int[N][M];</span><br><span class="line">            int sumStart &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">                String [] str &#x3D; scanner.nextLine().split(&quot; &quot;);</span><br><span class="line">                for (int j &#x3D; 0; j &lt; M; j++) &#123;</span><br><span class="line">                    array[i][j] &#x3D; Integer.parseInt(str[j]);</span><br><span class="line">                    sumStart +&#x3D; array[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 1; i &lt; N-1; i++) &#123;</span><br><span class="line">                for (int j &#x3D; 1; j &lt; M-1; j++) &#123;</span><br><span class="line">                    array[i][j] &#x3D; findMin(array, i, j,first);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int sumEnd &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; M; j++) &#123;</span><br><span class="line">                    sumEnd +&#x3D; array[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(sumEnd-sumStart);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int findMin(int[][] array, int X, int Y,int direction)&#123;</span><br><span class="line">        int nextX &#x3D; X;</span><br><span class="line">        int nextY &#x3D; Y;</span><br><span class="line">        if (nextX &#x3D;&#x3D;0 || nextX &#x3D;&#x3D;N-1 || nextY&#x3D;&#x3D;0 || nextY&#x3D;&#x3D;M-1)&#123;</span><br><span class="line">            return array[X][Y];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (array[X][Y]&gt;array[X][Y-1] &amp;&amp; array[X][Y]&gt;array[X][Y+1] &amp;&amp; array[X][Y]&gt;array[X-1][Y] &amp;&amp; array[X][Y]&gt;array[X+1][Y])</span><br><span class="line">            return array[X][Y];</span><br><span class="line"></span><br><span class="line">        int nextLeft;</span><br><span class="line">        int nextRight;</span><br><span class="line">        int nextUp;</span><br><span class="line">        int nextDown;</span><br><span class="line">        switch (direction)&#123;</span><br><span class="line">            case 0:</span><br><span class="line">                nextLeft &#x3D; findMin(array,X,Y-1,right);</span><br><span class="line">                nextRight &#x3D; findMin(array,X,Y+1, left);</span><br><span class="line">                nextUp &#x3D; findMin(array,X-1,Y, down);</span><br><span class="line">                nextDown &#x3D; findMin(array,X+1,Y, up);</span><br><span class="line">                return Math.max(Math.min(Math.min(nextRight,nextLeft), Math.min(nextDown, nextUp)),array[X][Y]);</span><br><span class="line">            case 1:</span><br><span class="line">                nextRight &#x3D; findMin(array,X,Y+1, left);</span><br><span class="line">                nextUp &#x3D; findMin(array,X-1,Y, down);</span><br><span class="line">                nextDown &#x3D; findMin(array,X+1,Y, up);</span><br><span class="line">                return Math.max(Math.min(nextRight, Math.min(nextDown, nextUp)),array[X][Y]);</span><br><span class="line">            case 2:</span><br><span class="line">                nextLeft &#x3D; findMin(array,X,Y-1,right);</span><br><span class="line">                nextUp &#x3D; findMin(array,X-1,Y, down);</span><br><span class="line">                nextDown &#x3D; findMin(array,X+1,Y, up);</span><br><span class="line">                return Math.max(Math.min(nextLeft, Math.min(nextDown, nextUp)),array[X][Y]);</span><br><span class="line">            case 3:</span><br><span class="line">                nextLeft &#x3D; findMin(array,X,Y-1,right);</span><br><span class="line">                nextRight &#x3D; findMin(array,X,Y+1, left);</span><br><span class="line">                nextDown &#x3D; findMin(array,X+1,Y, up);</span><br><span class="line">                return Math.max(Math.min(Math.min(nextRight,nextLeft), nextDown),array[X][Y]);</span><br><span class="line">            case 4:</span><br><span class="line">                nextLeft &#x3D; findMin(array,X,Y-1,right);</span><br><span class="line">                nextRight &#x3D; findMin(array,X,Y+1, left);</span><br><span class="line">                nextUp &#x3D; findMin(array,X-1,Y, up);</span><br><span class="line">                return Math.max(Math.min(Math.min(nextRight,nextLeft), nextUp),array[X][Y]);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-利用一个数组实现两个栈"><a href="#14-利用一个数组实现两个栈" class="headerlink" title="14.利用一个数组实现两个栈"></a>14.利用一个数组实现两个栈</h4><p>方法1：利用奇偶位，分别存储栈1和栈2的数据；</p><p>方法2：从中间开始将数组一分为二，左边为栈1，右边为栈2；</p><p>方法3：栈1从头开始增长，栈2从尾向头进行增长，相遇后，增容；</p><p><a href="https://imgchr.com/i/8WS2Rg" target="_blank" rel="noopener"><img src="/images/loading/loading.gif" data-original="https://s1.ax1x.com/2020/03/21/8WS2Rg.png" alt="8WS2Rg.png"></a></p><h4 id="15-装满箱子"><a href="#15-装满箱子" class="headerlink" title="15.装满箱子"></a>15.装满箱子</h4><p>题目描述</p><p>有重量分别为3，5，7公斤的三种货物，和一个载重量为X公斤的箱子（不考虑体积等其它因素，只计算重量）需要向箱子内装满X公斤的货物，要求使用的货物个数尽可能少（三种货物数量无限）</p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入箱子载重量X(1 &lt;&#x3D; X &lt;&#x3D; 10000)，一个整数。</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果无法装满，输出 -1。</span><br><span class="line">如果可以装满，输出使用货物的总个数。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p>说明:无法装满</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    static int temp &#x3D; 0;</span><br><span class="line">    public static void dfs(int count, int rest) &#123;</span><br><span class="line">        if (rest &lt; 0) &#123;&#x2F;&#x2F;如果-3，-5或者-7小于0了，说明凑不齐，赶紧溜了</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (rest &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            System.out.println(temp*15+count);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(count + 1, rest - 7);</span><br><span class="line">        dfs(count + 1, rest - 5);</span><br><span class="line">        dfs(count + 1, rest - 3);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; sc.nextInt();</span><br><span class="line">        temp &#x3D; n &#x2F; 105;</span><br><span class="line">        dfs(0, n % 105);</span><br><span class="line">        System.out.println(-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16-回文子串"><a href="#16-回文子串" class="headerlink" title="16.回文子串"></a>16.回文子串</h4><p>回文子串的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">链接：https:&#x2F;&#x2F;www.nowcoder.com&#x2F;questionTerminal&#x2F;003482c395bd41c68082f6adc545a600</span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line">public class Solution14_回文子串 &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 方法一：中心扩散法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static int ans &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader bf &#x3D; new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        String s &#x3D; bf.readLine();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;考虑两种情况：aba 和 abba</span><br><span class="line">            centerSpread(s, i, i);</span><br><span class="line">            centerSpread(s, i, i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;判断回文串的中心扩散法</span><br><span class="line">    private static void centerSpread(String s, int left, int right) &#123;</span><br><span class="line">        while (left &gt;&#x3D; 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) &#x3D;&#x3D; s.charAt(right)) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;方法二：动态规划</span><br><span class="line">    private static int dp(String s) &#123;</span><br><span class="line">        int n &#x3D; s.length(), ans &#x3D; 0;</span><br><span class="line">        boolean[][] dp &#x3D; new boolean[n][n];</span><br><span class="line">        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            for (int j &#x3D; i; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] &#x3D; (s.charAt(i) &#x3D;&#x3D; s.charAt(j)) &amp;&amp; (j - i &lt;&#x3D; 2 || dp[i + 1][j - 1]);</span><br><span class="line">                if (dp[i][j]) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最长回文子串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">链接：https:&#x2F;&#x2F;www.nowcoder.com&#x2F;questionTerminal&#x2F;003482c395bd41c68082f6adc545a600</span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;1.动态规划</span><br><span class="line">    public static String longestPalindrome(String s) &#123;</span><br><span class="line">        int n &#x3D; s.length();</span><br><span class="line">        if (n &lt; 2) return s;</span><br><span class="line">        int maxLen &#x3D; 1;</span><br><span class="line">        String res &#x3D; s.substring(0, 1);</span><br><span class="line">        boolean[][] dp &#x3D; new boolean[n][n];</span><br><span class="line">        &#x2F;&#x2F;左边界一定小于右边界，因此从右边界开始</span><br><span class="line">        for (int r &#x3D; 1; r &lt; n; r++) &#123; &#x2F;&#x2F;表示右边界</span><br><span class="line">            for (int l &#x3D; 0; l &lt; r; l++) &#123; &#x2F;&#x2F;表示左边界</span><br><span class="line">                &#x2F;&#x2F; 区间应该慢慢放大</span><br><span class="line">                &#x2F;&#x2F; 状态转移方程：如果头尾字符相等并且中间也是回文</span><br><span class="line">                &#x2F;&#x2F; 在头尾字符相等的前提下，如果收缩以后不构成区间（最多只有 1 个元素），直接返回 True 即可</span><br><span class="line">                &#x2F;&#x2F; 否则要继续看收缩以后的区间的回文性</span><br><span class="line">                if (s.charAt(l) &#x3D;&#x3D; s.charAt(r) &amp;&amp; ((r - l) &lt;&#x3D; 2 || dp[l + 1][r - 1])) &#123;</span><br><span class="line">                    dp[l][r] &#x3D; true;</span><br><span class="line">                    if (r - l + 1 &gt; maxLen) &#123;</span><br><span class="line">                        maxLen &#x3D; r - l + 1;</span><br><span class="line">                        res &#x3D; s.substring(l, r + 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最长不连续回文子串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">链接：https:&#x2F;&#x2F;www.nowcoder.com&#x2F;questionTerminal&#x2F;003482c395bd41c68082f6adc545a600</span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line">public int longestPalindrome(String s) &#123;</span><br><span class="line">    int n &#x3D; s.length();</span><br><span class="line">    int[][] dp &#x3D; new int[n][n];&#x2F;&#x2F;dp[l][r]表示l-r中的最长回文串</span><br><span class="line">    for (int r &#x3D; 0; r &lt; n; r++) &#123;</span><br><span class="line">        dp[r][r] &#x3D; 1;</span><br><span class="line">        for (int l &#x3D; r - 1; l &gt;&#x3D; 0; l--) &#123;</span><br><span class="line">            if (s.charAt(l) &#x3D;&#x3D; s.charAt(r)) &#123;</span><br><span class="line">                dp[l][r] &#x3D; dp[l + 1][r - 1] + 2;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[l][r] &#x3D; Math.max(dp[l + 1][r], dp[l][r - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="reward-container"><div>你的支持就是我前进的动力</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/images/loading/loading.gif" data-original="/images/wechatpay.jpg" alt="Kongo 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/images/loading/loading.gif" data-original="/images/alipay.jpg" alt="Kongo 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tags"></i> 面试笔记</a><a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tags"></i> 算法</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2020/06/22/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" rel="prev" title="面试基础笔记"><i class="fa fa-chevron-left"></i> 面试基础笔记</a></div><div class="post-nav-item"> <a href="/2020/06/22/%E9%9D%9E%E8%AF%9A%E5%8B%BF%E6%89%B0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%93%E5%9C%BA/" rel="next" title="非诚勿扰——程序员专场">非诚勿扰——程序员专场<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、树"><span class="nav-text">一、树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-红黑树"><span class="nav-text">1.红黑树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-AVL树"><span class="nav-text">2.AVL树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-map底层为什么用红黑树实现"><span class="nav-text">3.map底层为什么用红黑树实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Top-K-问题"><span class="nav-text">4.Top(K)问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-红黑树较AVL树的优点："><span class="nav-text">5.红黑树较AVL树的优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-二叉树的层序遍历并输出（手写代码）"><span class="nav-text">6.二叉树的层序遍历并输出（手写代码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-序列化和反序列化二叉树。（手写代码）"><span class="nav-text">7.序列化和反序列化二叉树。（手写代码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-最近公共祖先"><span class="nav-text">8.最近公共祖先</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、堆和栈"><span class="nav-text">二、堆和栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-说一说你理解的stack-overflow，并举个简单例子导致栈溢出"><span class="nav-text">1.说一说你理解的stack overflow，并举个简单例子导致栈溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-堆和栈的区别"><span class="nav-text">2.堆和栈的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-大小根堆特点"><span class="nav-text">3.大小根堆特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-两个栈实现一个队列-和-用队列实现栈（手写代码）"><span class="nav-text">4.两个栈实现一个队列 和 用队列实现栈（手写代码）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、数组"><span class="nav-text">三、数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-数组与链表的区别"><span class="nav-text">1.数组与链表的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-二分法"><span class="nav-text">2.二分法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、排序"><span class="nav-text">四、排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-各种排序算法及时间复杂度"><span class="nav-text">1.各种排序算法及时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-稳定排序哪几种？"><span class="nav-text">2.稳定排序哪几种？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-请问求第k大的数的方法以及各自的复杂度是怎样的？"><span class="nav-text">3.请问求第k大的数的方法以及各自的复杂度是怎样的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-冒泡排序-手写代码-O-n-2"><span class="nav-text">4.冒泡排序(手写代码) O(n^2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-选择排序-O-n-2"><span class="nav-text">5.选择排序 O(n^2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-快速排序（手写代码）O-Nlog2N"><span class="nav-text">6.快速排序（手写代码）O(Nlog2N)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-归并排序（手写代码）O-Nlog2N"><span class="nav-text">7.归并排序（手写代码）O(Nlog2N)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-堆排序O-Nlog2N"><span class="nav-text">8.堆排序O(Nlog2N)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、哈希"><span class="nav-text">五、哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-hash表的实现"><span class="nav-text">1.hash表的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-哈希表的桶个数为什么是质数，合数有何不妥？"><span class="nav-text">2.哈希表的桶个数为什么是质数，合数有何不妥？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、动态规划"><span class="nav-text">六、动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-最长公共子序列（手写代码）"><span class="nav-text">1.最长公共子序列（手写代码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-最长公共子串"><span class="nav-text">2.最长公共子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-求一个字符串最长回文子串-手写代码"><span class="nav-text">3.求一个字符串最长回文子串(手写代码)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-硬币表示"><span class="nav-text">4.硬币表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-字符混编"><span class="nav-text">5.字符混编</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七、链表"><span class="nav-text">七、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-如何合并两个有序链表-手写代码"><span class="nav-text">1.如何合并两个有序链表(手写代码)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-反转链表（手写代码）"><span class="nav-text">2.反转链表（手写代码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-判断一个链表是否为回文链表，说出你的思路并手写代码"><span class="nav-text">3.判断一个链表是否为回文链表，说出你的思路并手写代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-如何判断两个单向链表是否相交"><span class="nav-text">4.如何判断两个单向链表是否相交</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八、高级算法"><span class="nav-text">八、高级算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-单向加密"><span class="nav-text">1.单向加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-对称加密"><span class="nav-text">2.对称加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-非对称加密"><span class="nav-text">3.非对称加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-LRU缓存"><span class="nav-text">4.LRU缓存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九、字符串处理"><span class="nav-text">九、字符串处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c"><span class="nav-text">1.给你一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十、贪心算法"><span class="nav-text">十、贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-安置路灯"><span class="nav-text">1.安置路灯</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十一、实战题目"><span class="nav-text">十一、实战题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-九宫格解锁方案（Vivo）"><span class="nav-text">1.九宫格解锁方案（Vivo）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-爬楼梯算法"><span class="nav-text">2.爬楼梯算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-两数之和"><span class="nav-text">3.两数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-最大回撤"><span class="nav-text">4.最大回撤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-合并两个有序数组"><span class="nav-text">5.合并两个有序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-最大连续子数组和"><span class="nav-text">6.最大连续子数组和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-最长不重复子串"><span class="nav-text">7.最长不重复子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-全排列-这是一道动态规划-排列组合的综合应用题"><span class="nav-text">8.全排列(这是一道动态规划+排列组合的综合应用题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-穷举法"><span class="nav-text">9.穷举法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-数学"><span class="nav-text">10.数学</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-动态规划"><span class="nav-text">11.动态规划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-不用动态规划简单些"><span class="nav-text">12.不用动态规划简单些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-拼多多笔试题"><span class="nav-text">13.拼多多笔试题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-利用一个数组实现两个栈"><span class="nav-text">14.利用一个数组实现两个栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-装满箱子"><span class="nav-text">15.装满箱子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-回文子串"><span class="nav-text">16.回文子串</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Kongo" src="/images/header.jpeg"><p class="site-author-name" itemprop="name">Kongo</p><div class="site-description" itemprop="description">闳的博客，记录技术、生活</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">19</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright"> &copy; 2018 – <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">闳</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div><br> Total<span id="busuanzi_value_site_pv"></span> views.<br> 您是闳的第<span id="busuanzi_value_site_uv"></span>个小伙伴<br><span id="busuanzi_value_page_pv"></span> Hits</div></footer></div><script color="0,0,0" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script size="300" alpha="0.6" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script defer="defer" src="/lib/three/three.min.js"></script><script defer="defer" src="/lib/three/three-waves.min.js"></script><script src="/js/local-search.js"></script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'PULSTRKS13DHxoOUR8UQhJPX-gzGzoHsz',
      appKey     : '7ax6bnBNLWRYJlQ6Qb9rWCIJ',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script><script async src="/js/cursor/fireworks.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/ Relative)",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"right",width:200,height:300},mobile:{show:!0},react:{opacityDefault:.7}})</script><script>window.imageLazyLoadSetting={isSPA:!1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=i;var e=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)void 0,0<=(t=r[a].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e()},n.src=i}()}i(),n.addEventListener("scroll",function(){var t,e;t=i,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script></body></html>